\documentclass[./UsersGuide.tex]{subfiles}
 
\begin{document}

\section{\texttt{UQpy} Modules, Classes, \& Functions}

\texttt{UQpy} is structured in five core modules, each centered around specific functionalities:
\begin{enumerate}
\item \texttt{SampleMethods}: This module contains a set of classes and functions to draw samples from random variables. These samples may be randomly drawn, as in Monte Carlo simulation, or they may be deterministically drawn as in stochastic collocation or quasi-Monte Carlo.
\item \texttt{Inference}: This module contains a set of classes and functions to conduct probabilistic inference. The module contains methods that are based on Bayesian, frequentist, likelihood, and information theories. 
\item \texttt{Reliability}: This module contains a set of classes and functions designed specifically to estimate probability of failure.
\item \texttt{Surrogate}: This module contains a set of classes and functions for building surrogate models, meta-models, or emulators.
\item \texttt{Sensitivity}: This module contains a set of classes and functions for performing global and local sensitivity analysis.
\item \texttt{RunModel}: This module contains a set of classes and functions that allows \texttt{UQpy} to initiate simulations using either python or third-party computational solvers.
\end{enumerate}
The following sections detail the classes and functions in each module with reference to examples that illustrate their use. Guidance is based on usage in IDE Model (see Section \ref{sec:IDE_Mode})

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									SampleMethods Module									%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{SampleMethods} Module}

The \texttt{SampleMethods} module consists of classes and functions to draw samples from random variables. It is imported in a python script using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy} {\color{blue} import} SampleMethods }
\vspace{4mm}

\noindent
The \texttt{SampleMethods} module has the following classes, each corresponding to a different sampling method:

\vspace{4mm}
\begin{center}
	\begin{tabular}{ |l|l| } 
		\hline
		\textbf{Class} &  \textbf{Method} \\
		\hline
		\texttt{MCS}&  Monte Carlo Sampling  \\ 
		\hline
		\texttt{LHS}&  Latin Hypercube Sampling  \\ 
		\hline
		\texttt{STS}&  Stratified Sampling  \\ 
		\hline
		\texttt{PSS}&  Partially Stratified Sampling  \\ 
		\hline
		\texttt{MCMC}&  Markov Chain Monte Carlo  \\ 
		\hline
		\texttt{SROM}&  Stochastic Reduced Order Model  \\ 
		\hline
	\end{tabular}
\end{center}
\vspace{4mm}

\noindent
Each class can be imported individually into a python script. For example, the MCMC class can be imported to a script using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy.SampleMethods} {\color{blue} import} MCMC}
\vspace{4mm}

\noindent
The following subsections describe each class, their respective inputs and attributes, and their use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Monte Carlo sampling

\subsubsection{\texttt{UQpy.SampleMethods.MCS}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Latin hypercube sampling

\subsubsection{\texttt{UQpy.SampleMethods.LHS}}

\begin{center}
	\begin{tabular}{ |l|c|l| } 
		\hline
		\textbf{Property} & \textbf{Type} & \textbf{Options} \\
		\hline
		\texttt{\#criterion}& \textit{string} &  'random', 'centered', 'maximin', 'correlate'  \\ 
		\hline
		\multirow{5}{*}{\texttt{\#distance}} & \multirow{5}{*}{\textit{string}} & 'braycurtis', 'canberra', 'chebyshev', 'cosine', \\ 
		&  &  'dice', 'euclidean', 'hamming', 'jaccard',  'cityblock',   \\ 
		&  &  'matching', 'minkowski', 'rogerstanimoto',  'correlation', \\ 
		&  & 'sokalmichener', 'sokalsneath', 'sqeuclidean',  \\ 
		&  & ' 'kulsinski', 'mahalanobis', 'russellrao', 'seuclidean',  \\ 
		\hline
	\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stratified Sampling

\subsubsection{\texttt{UQpy.SampleMethods.STS}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Partially Stratified Sampling

\subsubsection{\texttt{UQpy.SampleMethods.PSS}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MCMC

\subsubsection{\texttt{UQpy.SampleMethods.MCMC}}
\label{Sec:MCMC}

The \texttt{MCMC} class is imported using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy.SampleMethods} {\color{blue} import} MCMC}
\vspace{4mm}

\noindent
The attributes of the \texttt{MCMC} class are listed below:

\begin{center}
%	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|c|c| } 
				\hline
		\multicolumn{4}{|c|}{\texttt{MCMC} Class Attribute Definitions} \\
		\hline
		\textbf{Attribute} & \textbf{Input/Output} & \textbf{Required} & \textbf{Optional} \\
		\hline
		\texttt{dimension} & Input &  & $\star$  \\ 
		\hline
		\texttt{pdf\_proposal\_type} & Input & & $\star$   \\ 
		\hline
		\texttt{pdf\_proposal\_scale} & Input &  & $\star$  \\ 
		\hline
		\texttt{pdf\_target\_type}& Input &  &  $\star$  \\ 
		\hline
		\texttt{pdf\_target} & Input & $\star$ &   \\ 
		\hline
		\texttt{pdf\_target\_params} & Input  & &  $\star$  \\ 
		\hline
		\texttt{algorithm} & Input &  & $\star$  \\ 
		\hline
		\texttt{jump} & Input &  & $\star$  \\ 
		\hline
		\texttt{nsamples}& Input & $\star$ &    \\ 
		\hline
		\texttt{seed} & Input & & $\star$   \\ 
		\hline
		\texttt{nburn} & Input & & $\star$   \\ 
		\hline
		\texttt{samples} & Output & & \\
		\hline
	\end{tabular}%}
\end{center}

\noindent
A brief description of each attribute can be found in the table below:

\begin{center}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|c|c| } 
				\hline
		\multicolumn{4}{|c|}{\texttt{MCMC} Class Attributes} \\
		\hline
		\textbf{Attribute} & \textbf{Type} & \textbf{Options} & \textbf{Default} \\
		\hline
		\texttt{dimension} & {\it integer} &  & \texttt{dimension} = 1  \\ 
		\hline
		\texttt{algorithm} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{pdf\_proposal\_type} & {\it string} & \begin{tabular}[t]{c}`Normal'\\`Uniform' \end{tabular}& `Uniform'   \\ 
		\hline
		\texttt{pdf\_proposal\_scale} & \begin{tabular}[t]{c}{\it float}\\{\it float list} \end{tabular} &  & \begin{tabular}[t]{c}\texttt{algorithm} = `MMH' or `MH' \\ {[1,1,\dots,1]}\\ \texttt{algorithm}=`Stretch'\\ 2 \end{tabular}  \\ 
		\hline
		\texttt{pdf\_target\_type}& {\it string} & \begin{tabular}[t]{c}`marginal\_pdf'\\`joint\_pdf' \end{tabular} &  `joint\_pdf'  \\ 
		\hline
		\texttt{pdf\_target} & \begin{tabular}[t]{c}{\it function}\\{\it string} \end{tabular} &  & Normal($\mathbf{0},\mathbf{I}$)  \\ 
		\hline
		\texttt{pdf\_target\_params} & \begin{tabular}[t]{c}{\it float}\\{\it float list} \end{tabular}  & &  \texttt{None} \\ 
		\hline
		\texttt{jump} & {\it integer} &  & 1  \\ 
		\hline
		\texttt{nsamples}& {\it integer} &  & \texttt{None}   \\ 
		\hline
		\texttt{seed} & \begin{tabular}[t]{c}{\it nparray}\\{\it nparray list} \end{tabular} & & \begin{tabular}[t]{c}array(0,0,\dots,0)\\size = $1\times \texttt{dimension}$ \end{tabular}    \\ 
		\hline
		\texttt{nburn} & {\it integer} & & 0   \\ 
		\hline
		\texttt{samples} & {\it nparray} & & \\
		\hline
	\end{tabular}}
\end{center}

\noindent\textbf{Detailed Description of \texttt{MCMC} Class Attributes:}\\

\noindent\textit{Input Attributes}:
\begin{itemize}
\item \texttt{dimension}:\\ 
	A scalar integer value defining the dimension of the random variables. 
\item \texttt{algorithm}: \\ 
	Specifies the algorithm used to generate samples. \texttt{UQpy} currently supports three commonly used algorithms.
	\begin{itemize}
		\item `MH': \\ 
			Metropolis-Hastings algorithm. For a description of the algorithm, see \cite{Metropolis1953,Hastings1970,Au2001}. 
		\item `MMH': \\ 
			Component-wise modified Metropolis-Hastings algorithm. For a description of the algorithm, see \cite{Au2001}. 
		\item `Stretch': \\ 
			Affine invariant ensemble sampler employing ``stretch" moves. For a description of the algorithm, see \cite{Goodman2010}.
	\end{itemize} 
\item \texttt{pdf\_proposal\_type}:\\ 
	Type of proposal density function. This option is only invoked when \texttt{algorithm} = `MH' or `MMH'. \texttt{UQpy} currently supports two types of proposal densities:
	\begin{itemize}
		\item `Normal': \\
			The proposal density is specified as a normal distribution with mean value equal to the current state of the Markov Chain and standard deviation specified by 						\texttt{pdf\_proposal\_scale}. That is, a new candidate sample is generated as\\ $x_{i+1}\sim N(x_i,\texttt{pdf\_proposal\_scale})$.
		\item `Uniform': \\
			The proposal density is specified as a uniform distribution with centered at the current state of the Markov Chain with width equal to \texttt{pdf\_proposal\_scale}. That is, a 			new candidate sample is generated as\\ $x_{i+1}\sim U(x_i-\texttt{pdf\_proposal\_scale}/2,x_i+\texttt{pdf\_proposal\_scale}/2)$.
		\end{itemize}
		When $\texttt{dimension}>1$, \texttt{pdf\_proposal\_type} may be specified as a string or a list of strings assigned to each dimension. When \texttt{pdf\_proposal\_type} is 			specified as a string, the same proposal type is specified for all dimensions.
\item \texttt{pdf\_proposal\_scale}:\\ 
	Sets the scale of the proposal probability density. The scale of the proposal density depends on both the MCMC algorithm employed (\texttt{algorithm}) and the type of proposal 		density specified (\texttt{pdf\_proposal\_type}).
	\begin{itemize}
		\item For \texttt{algorithm} = `MH' or `MMH', this defines either the standard deviation of a normal proposal density or the width of a uniform density. See 							\texttt{pdf\_proposal\_type} above.
		\item For \texttt{algorithm} = `Stretch', this sets the scale of the stretch density $g(z)=\frac{1}{\sqrt{z}},\sim z\in[1/\texttt{pdf\_proposal\_scale}, \texttt{pdf\_proposal\_scale}]$. See 		\cite{Goodman2010}.
	\end{itemize}
	When $\texttt{dimension}>1$, \texttt{pdf\_proposal\_scale} may be specified as a scalar or a list of values assigned to each dimension. When \texttt{pdf\_proposal\_scale} is specified 	as a scalar, the same scale is specified for all dimensions. 
\item \texttt{pdf\_target\_type}: 

	[Use only with \texttt{algorithm} = `MMH']\\ 
	
	MCMC algorithms use acceptance-rejection based on a ratio of the target probability densities between the current state and the proposed state. In the `MH' algorithm and the 		`Stretch' algorithm, the ratio of probabilities is computed using the target joint pdf. For the `MMH' algorithm with independent random variables, acceptance/rejection can be computed 	based on the ratio of the marginals for each dimension. This variable specifies whether to use a ratio of target joint pdf's or a ratio of target marginal pdf's in the acceptance-rejection 	step for each dimension of the `MMH' algorithm. This option is not used for the `MH' and `Stretch' algorithms.
	\begin{itemize}
		\item `joint\_pdf': \\
			Compute the acceptance-rejection using the ratio of the target joint pdf's. [Always use when random variables are dependent.]
		\item `marginal\_pdf': \\
			Compute the acceptance-rejection using the ratio of target marginal pdf's in each dimension. [Only use when random variables are independent.]
	\end{itemize} 
\item \texttt{pdf\_target}:\\ 
	Specifies the target probability density function from which to draw MCMC samples (i.e.\ the stationary distribution of the Markov chain). \texttt{pdf\_target} must be passed into 		\texttt{MCMC} as a function. In \texttt{UQpy}, this can be achieved in two ways:
	\begin{itemize}
		\item Direct function definition:\\
		The easiest way to define \texttt{pdf\_target} is to create a function in the python script that calls \texttt{MCMC}. When the function is directly defined, \texttt{pdf\_target} is 			specified directly using the function name (not as a string). 
		\item Definition through `custom\_pdf.py':\\
		If the function is to be called frequently by the user or may need to be shared among python scripts in a project, the user may define the function in a python script 					`custom\_pdf.py' that resides in the user's working directory. When this is the case, \texttt{pdf\_target} is specified by a string that corresponds to the function name in 				`custom\_pdf.py'. See Section \ref{Sec:Distributions} for a detailed description of `custom\_pdf.py'.
	\end{itemize} 
	In both cases, the function must be defined to accept two parameters: 
	\begin{enumerate}
		\item The point at which to compute the pdf, 
		\item A list of parameters of the pdf specified through \texttt{pdf\_target\_params} 
	\end{enumerate}
	If the pdf does not have any user-defined parameters, the user still must define the function to accept a parameter list.\\

	When $\texttt{dimension}>1$ and \texttt{pdf\_target\_type} = `marginal\_pdf', \texttt{pdf\_target} may be specified as a string/function or a list of strings/functions assigned to each 		dimension. When specified as a string/function, the same marginal pdf is specified for all dimensions.
\item \texttt{pdf\_target\_params}:\\
	Parameters of the target pdf to be passed into the function defined by \texttt{pdf\_target}.
\item \texttt{jump}\\
	Specifies the number of samples between accepted states of the Markov chain. Setting \texttt{jump} = 1 corresponds to accepting every state. Setting $\texttt{jump} = n$ corresponds 	skipping $n-1$ states between accepted states of the chain.
\item \texttt{nsamples}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{seed}\\
	Specifies the initial state of the Markov chain. \\
	
	For \texttt{algorithm} = `MMH' or `MH', this is a numpy array of zeros with size $1\times \texttt{dimension}$.\\
	
	For \texttt{algorithm} = `Stretch', this is a list of $n_s$ points, each defined as numpy arrays with size $1\times \texttt{dimension}$, where $n_s$ is the size of the ensemble being 		propagated. \cite{Goodman2010}. The default value in the table above is not valid for  \texttt{algorithm} = `Stretch'.
\item \texttt{nburn}\\
	Specifies the number of samples at the start of the chain to be discarded as ``burn-in." This option is only applicable for \texttt{algorithm}=`MMH' and `MH'
\end{itemize}

\noindent\textit{Output Attributes}:
\begin{itemize}
\item \texttt{samples}:\\
	The only output of the \texttt{MCMC} class are the generated samples. The samples are returned as a numpy array of dimension $\texttt{nsamples}\times\texttt{dimension}$. 
\end{itemize}

\noindent\textbf{Examples:}\\
\noindent Two examples illustrating the use of the \texttt{MCMC} class are provided in the following Jupyter scripts.
\begin{itemize}
\item MCMC\_Example1.ipynb:\\
	In this example, the three MCMC algorithms are used to generate 1000 samples from a two-dimensional Rosenbrock pdf. The Rosenbrock pdf is defined as a function directly in the 	script.
\item MCMC\_Example2.ipynb:\\
	In this example, the three MCMC algorithms are used to generate 1000 samples from a two-dimensional Rosenbrock pdf. The Rosenbrock pdf is defined as a function in the 			`custom\_pdf.py' script.
\end{itemize}

%\begin{center}
%	\begin{tabular}{ |l|c|l| } 
%		\hline
%		\textbf{Property} & \textbf{Type} & \textbf{Description/Options} \\
%		\hline
%		\texttt{\#criterion}& \textit{string} &  'random', 'centered', 'maximin', 'correlate'  \\ 
%		\hline
%		\multirow{5}{*}{\texttt{\#distance}} & \multirow{5}{*}{\textit{string}} & 'braycurtis', 'canberra', 'chebyshev', 'cosine', \\ 
%		&  &  'dice', 'euclidean', 'hamming', 'jaccard',  'cityblock',   \\ 
%		&  &  'matching', 'minkowski', 'rogerstanimoto',  'correlation', \\ 
%		&  & 'sokalmichener', 'sokalsneath', 'sqeuclidean',  \\ 
%		&  & ' 'kulsinski', 'mahalanobis', 'russellrao', 'seuclidean',  \\ 
%		\hline
%	\end{tabular}
%\end{center}
%
%
%\begin{center}
%	\begin{tabular}{ |l|l| } 
%		\hline
%		\textbf{Property} &  \textbf{Options} \\
%		\hline
%		\texttt{\#target distribution}&   'multivariate\_pdf', 'marginal\_pdf', 'normal\_pdf'  \\ 
%		\hline
%		\texttt{\#proposal distribution}&   'Uniform', 'Normal'  \\ 
%		\hline
%		\texttt{\#algorithm}&   'MH', 'MMH'  \\ 
%		\hline
%	\end{tabular}
%\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SROM

\subsubsection{\texttt{UQpy.SampleMethods.SROM}}



\subsubsection{Adding a sampling method in \texttt{UQpy}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									Inference Module										%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{Inference} Module}

Coming soon\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									Reliability Module										%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{Reliability} Module}

The \texttt{Reliability} module consists of classes and functions to provide simulation-based estimates of probability of failure from a given user-defined computational model and failure criterion. It is imported in a python script using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy} {\color{blue} import} Reliability }
\vspace{4mm}

\noindent
The \texttt{Reliability} module has the following classes, each corresponding to a method for probability of failure estimation:

\vspace{4mm}
\begin{center}
	\begin{tabular}{ |l|l| } 
		\hline
		\textbf{Class} &  \textbf{Method} \\
		\hline
		\texttt{SubsetSimulation}&  Subset Simulation  \\ 
		\hline
		\texttt{FORM}&  First Order Reliability Method  \\ 
		\hline
		\texttt{SORM}& Second Order Reliability Method  \\ 
		\hline
	\end{tabular}
\end{center}
\vspace{4mm}

\noindent
Each class can be imported individually into a python script. For example, the \texttt{SubsetSimulation} class can be imported to a script using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy.SampleMethods} {\color{blue} import} SubsetSimulation}
\vspace{4mm}

\noindent
The following subsections describe each class, their respective inputs and attributes, and their use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Subset Simulation

\subsubsection{\texttt{UQpy.Reliability.SubsetSimulation}}


The \texttt{SubsetSimulation} class is imported using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy.Reliability} {\color{blue} import} SubsetSimulation}
\vspace{4mm}

\noindent
The attributes of the \texttt{SubsetSimulation} class are listed below:

\begin{center}
%	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|c|c| } 
				\hline
		\multicolumn{4}{|c|}{\texttt{SubsetSimulation} Class Attribute Definitions} \\
		\hline
		\textbf{Attribute} & \textbf{Input/Output} & \textbf{Required} & \textbf{Optional} \\
		\hline
		\texttt{dimension} & Input &  & $\star$  \\ 
		\hline
		\texttt{pdf\_target\_type}& Input &  &  $\star$  \\ 
		\hline
		\texttt{pdf\_target} & Input & $\star$ &   \\ 
		\hline
		\texttt{pdf\_target\_params} & Input  & &  $\star$  \\ 
		\hline
		\texttt{pdf\_proposal\_type} & Input & & $\star$   \\ 
		\hline
		\texttt{pdf\_proposal\_scale} & Input &  & $\star$  \\ 
		\hline
		\texttt{nsamples\_ss}& Input & $\star$ &    \\ 
		\hline
		\texttt{algorithm} & Input &  & $\star$  \\ 
		\hline
		\texttt{model\_type}& Input & $\star$ &    \\ 
		\hline
		\texttt{model\_script}& Input & $\star$ &    \\ 
		\hline
		\texttt{input\_script}& Input & $\star$ &    \\ 
		\hline
		\texttt{output\_script}& Input & $\star$ &    \\ 
		\hline
		\texttt{p\_cond}& Input & $\star$ &    \\ 
		\hline
		\texttt{ss\_jump} & Input &  & $\star$  \\ 
		\hline
		\texttt{samples} & Output & & \\
		\hline
		\texttt{g} & Output & & \\
		\hline
		\texttt{g\_level} & Output & & \\
		\hline
		\texttt{pf} & Output & & \\
		\hline
	\end{tabular}%}
\end{center}


\noindent
A brief description of each attribute can be found in the table below:

\begin{center}
	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|c|c| } 
				\hline
		\multicolumn{4}{|c|}{\texttt{SubsetSimulation} Class Attributes} \\
		\hline
		\textbf{Attribute} & \textbf{Type} & \textbf{Options} & \textbf{Default} \\
		\hline
		\texttt{dimension} & {\it integer} &  & \texttt{dimension} = 1  \\ 
		\hline
		\texttt{pdf\_target\_type}& {\it string} & \begin{tabular}[t]{c}`marginal\_pdf'\\`joint\_pdf' \end{tabular} &  `marginal\_pdf'  \\ 
		\hline
		\texttt{pdf\_target} & \begin{tabular}[t]{c}{\it function}\\{\it string} \end{tabular} &  & Normal($\mathbf{0},\mathbf{I}$)  \\ 
		\hline
		\texttt{pdf\_target\_params} & \begin{tabular}[t]{c}{\it float}\\{\it float list} \end{tabular}  & &  \texttt{None} \\ 
		\hline
		\texttt{pdf\_proposal\_type} & {\it string} & \begin{tabular}[t]{c}`Normal'\\`Uniform' \end{tabular}& `Uniform'   \\ 
		\hline
		\texttt{pdf\_proposal\_scale} & \begin{tabular}[t]{c}{\it float}\\{\it float list} \end{tabular} &  & \begin{tabular}[t]{c}\texttt{algorithm} = `MMH' or `MH' \\ {[1,1,\dots,1]}\\ \texttt{algorithm}=`Stretch'\\ 2 \end{tabular}  \\ 
		\hline
		\texttt{nsamples\_ss}& {\it integer} &  & \texttt{None}   \\ 
		\hline
		\texttt{algorithm} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{model\_type} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{model\_script} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{input\_script} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{output\_script} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{p\_cond} & {\it string} & \begin{tabular}[t]{c}`MH'\\`MMH'\\`Stretch' \end{tabular} & `MMH'  \\ 
		\hline
		\texttt{ss\_jump} & {\it integer} &  & 1  \\ 
		\hline
		\texttt{samples} & {\it nparray} & & \\
		\hline
		\texttt{g} & \begin{tabular}[t]{c}{\it nparray}\\{\it nparray list} \end{tabular} & & \begin{tabular}[t]{c}array(0,0,\dots,0)\\size = $1\times \texttt{dimension}$ \end{tabular}    \\ 
		\hline
		\texttt{g\_level} & {\it integer} & & 0   \\ 
		\hline
		\texttt{pf} & \begin{tabular}[t]{c}{\it nparray}\\{\it nparray list} \end{tabular} & & \begin{tabular}[t]{c}array(0,0,\dots,0)\\size = $1\times \texttt{dimension}$ \end{tabular}    \\ 
		\hline
	\end{tabular}}
\end{center}


\noindent\textbf{Detailed Description of \texttt{SubsetSimulation} Class Attributes:}\\

\noindent\textit{Input Attributes}:
\begin{itemize}
\item \texttt{dimension}:\\ 
	A scalar integer value defining the dimension of the random variables. 
\item \texttt{pdf\_target\_type}:\\ 
	This is used for Markov Chain Monte Carlo (MCMC) sampling from the conditional probability densities in subset simulation. For details, the user is referred to documentation for 		\texttt{UQpy.SampleMethods.MCMC} in Section \ref{Sec:MCMC}
\item \texttt{pdf\_target}:\\ 
	This is used for Markov Chain Monte Carlo (MCMC) sampling from the conditional probability densities in subset simulation. For details, the user is referred to documentation for 		\texttt{UQpy.SampleMethods.MCMC} in Section \ref{Sec:MCMC}
\item \texttt{pdf\_target\_params}:\\
	This is used for Markov Chain Monte Carlo (MCMC) sampling from the conditional probability densities in subset simulation. For details, the user is referred to documentation for 		\texttt{UQpy.SampleMethods.MCMC} in Section \ref{Sec:MCMC}
\item \texttt{pdf\_proposal\_type}:\\ 
	This is used for Markov Chain Monte Carlo (MCMC) sampling from the conditional probability densities in subset simulation. For details, the user is referred to documentation for 		\texttt{UQpy.SampleMethods.MCMC} in Section \ref{Sec:MCMC}
\item \texttt{pdf\_proposal\_scale}:\\ 
	This is used for Markov Chain Monte Carlo (MCMC) sampling from the conditional probability densities in subset simulation. For details, the user is referred to documentation for 		\texttt{UQpy.SampleMethods.MCMC} in Section \ref{Sec:MCMC}
\item \texttt{nsamples\_ss}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{algorithm}: \\ 
	Specifies the algorithm used to generate samples. \texttt{UQpy} currently supports three commonly used algorithms.
	\begin{itemize}
		\item `MH': \\ 
			Metropolis-Hastings algorithm. For a description of the algorithm, see \cite{Metropolis1953,Hastings1970,Au2001}. 
		\item `MMH': \\ 
			Component-wise modified Metropolis-Hastings algorithm. For a description of the algorithm, see \cite{Au2001}. 
		\item `Stretch': \\ 
			Affine invariant ensemble sampler employing ``stretch" moves. For a description of the algorithm, see \cite{Goodman2010}.
	\end{itemize} 
\item \texttt{model\_type}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{model\_script}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{input\_script}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{output\_script}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{p\_cond}\\
	Specifies the number of samples to be generated (not including skipped states of the chain). \texttt{nsamples} must be specified. There is no default value.
\item \texttt{ss\_jump}\\
	Specifies the number of samples between accepted states of the Markov chain. Setting \texttt{jump} = 1 corresponds to accepting every state. Setting $\texttt{jump} = n$ corresponds 	skipping $n-1$ states between accepted states of the chain.
\end{itemize}

\noindent\textit{Output Attributes}:
\begin{itemize}
\item \texttt{samples}:\\
	The only output of the \texttt{MCMC} class are the generated samples. The samples are returned as a numpy array of dimension $\texttt{nsamples}\times\texttt{dimension}$. 
\item \texttt{g}\\
	Specifies the initial state of the Markov chain. \\
	
	For \texttt{algorithm} = `MMH' or `MH', this is a numpy array of zeros with size $1\times \texttt{dimension}$.\\
	
	For \texttt{algorithm} = `Stretch', this is a list of $n_s$ points, each defined as numpy arrays with size $1\times \texttt{dimension}$, where $n_s$ is the size of the ensemble being 		propagated. \cite{Goodman2010}. The default value in the table above is not valid for  \texttt{algorithm} = `Stretch'.
\item \texttt{g\_level}\\
	Specifies the number of samples at the start of the chain to be discarded as ``burn-in." This option is only applicable for \texttt{algorithm}=`MMH' and `MH'
\item \texttt{pf}\\
	Specifies the initial state of the Markov chain. \\
	
	For \texttt{algorithm} = `MMH' or `MH', this is a numpy array of zeros with size $1\times \texttt{dimension}$.\\
	
	For \texttt{algorithm} = `Stretch', this is a list of $n_s$ points, each defined as numpy arrays with size $1\times \texttt{dimension}$, where $n_s$ is the size of the ensemble being 		propagated. \cite{Goodman2010}. The default value in the table above is not valid for  \texttt{algorithm} = `Stretch'.
\end{itemize}

\noindent\textbf{\texttt{SubsetSimulation} Examples:}\\
\noindent Two examples illustrating the use of the \texttt{MCMC} class are provided in the following Jupyter scripts.
\begin{itemize}
\item MCMC\_Example1.ipynb:\\
	In this example, the three MCMC algorithms are used to generate 1000 samples from a two-dimensional Rosenbrock pdf. The Rosenbrock pdf is defined as a function directly in the 	script.
\item MCMC\_Example2.ipynb:\\
	In this example, the three MCMC algorithms are used to generate 1000 samples from a two-dimensional Rosenbrock pdf. The Rosenbrock pdf is defined as a function in the 			`custom\_pdf.py' script.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORM

\subsubsection{\texttt{UQpy.Reliability.FORM}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SORM

\subsubsection{\texttt{UQpy.Reliability.SORM}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									Surrogate Module										%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{Surrogate} Module}

Coming soon\dots

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									Sensitivity Module										%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{Sensitivity} Module}

Coming soon\dots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%																						%
% 									RunModel Module										%
%																						%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\texttt{RunModel} Module}

The \texttt{RunModel} module is how \texttt{UQpy} calls user-defined computational models and collects the results from the output of those simulations. Using the \texttt{RunModel} module requires the user to be familiar with either shell scripting or python scripting.  The \texttt{RunModel} module consists of a single class, also called \texttt{RunModel}, that can be imported using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy.RunModel} {\color{blue} import} RunModel}
\vspace{4mm}

\noindent There are two general workflows for the \texttt{RunModel} class. In the first, a model is defined or called through python scripts, which allows all message passing to be performed internally  and therefore has less computational ``overhead." In the second workflow, information is passed between \texttt{UQpy} and a third-party solver through text files. The following sections detail these two workflows.

\subsubsection{\texttt{RunModel} with direct Python communications (\texttt{model\_type} = `python')}

The fastest, simplest, and preferred way to run a model using \texttt{UQpy} is by linking \texttt{UQpy} to a Python script that calls or runs the model. This link occurs by calling the \texttt{RunModel} class, setting \texttt{model\_type} = `python', and pointing it to the user-defined Python script that will execute the model. \texttt{RunModel} is pointed to the Python script by defining the input parameter \texttt{model\_script} as a string having the name of the Python script (note this file must be a .py file). More details on defining \texttt{model\_script} can be found in Section \ref{sec:RM_attributes}. Figure \ref{fig:RunModel_Python} shows a general flow-chart for the \texttt{RunModel} class.
\begin{figure}[!ht]
	\centering	{\includegraphics[width=0.5\textwidth]{RunModel_Python}}
	\caption{General workflow for running a model from a python script (\texttt{model\_type} = `pthon') using the \texttt{RunModel} class of \texttt{UQpy}.}
	\label{fig:RunModel_Python}
\end{figure}

\texttt{UQpy} calls the Python script defined by \texttt{model\_script} through the class \texttt{RunPythonModel}, which must be present in \texttt{model\_script} and defined as follows:

\vspace{4mm}
\texttt{{\color{blue} class} \texttt{RunPythonModel:}}\\

\hspace{1cm} \texttt{def \_\_init\_\_(self, samples=None, dimension=None):}\\

\hspace{1cm} \texttt{self.samples = samples}

\hspace{1cm} \texttt{self.dimension = dimension}

\hspace{1cm} \texttt{self.QOI = list()}
\vspace{4mm}

\noindent The \texttt{RunPythonModel} class in \texttt{model\_script} must accept, as input, a set of samples and the dimension of the samples and return, as output, a list containing the quantity of interest (\texttt{self.QOI}) computed for each sample. The attributes of the \texttt{RunPythonModel} are described below. Beyond these minimal requirements, the user has complete freedom to perform whatever operations she/he desires. That is, \texttt{model\_script} may be used directly to perform some operations on the samples (e.g. solve a set of differential equations having parameters defined by the samples) or to call a third-party model (e.g.\ Matlab, Abaqus, or a custom simulation code). 


\begin{center}
%	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|l| } 
				\hline
		\multicolumn{3}{|c|}{\texttt{RunPythonModel} Class Attributes} \\
		\hline
		\textbf{Attribute} & \textbf{Type} & \textbf{Description}  \\
		\hline
		\texttt{dimension} & {\it integer} & Dimension of the samples array. \\ 
		\hline
		\texttt{samples} & {\it nparray} & Sample points at which to evaluate the model. \\ 
		\hline
		\texttt{QOI} & {\it nparray} & A list containing the quantity of interest returned from the model. Each item of the list corresponds to an associated sample value and may be of arbitrary data type.  \\ 
		\hline
	\end{tabular}%}
\end{center}

\noindent\textbf{Examples:}\\
\noindent An example illustrating the use of the \texttt{RunModel} class with \texttt{model\_type} = `python' is provided in the following Jupyter script.
\begin{itemize}
\item Run\_Python\_Model.ipynb:\\
	In this example, the component-wise modified Metropolis-Hasting algorithm for MCMC is used to generate 15 (approximately) independent samples from a two-dimensional Rosenbrock pdf. The Rosenbrock pdf is defined as a function directly in the script. The samples are then passed to a Python model that evaluates the sum of the components of each sample and returns the sum as the quantity of interest (\texttt{x.model\_eval.QOI}).
\end{itemize}

Running a model in Python is strongly preferred both from the perspective of flexibility for the user, but also because it alleviates the burden of file passing as a means of communication between \texttt{UQpy} and model input/output. This is the topic of the next section.

\subsubsection{\texttt{RunModel} with file passing communications (\texttt{model\_type = None})}
The \texttt{RunModel} class supports an alternate means of running a model for users who prefer shell scripting or who prefer a more prescriptive workflow. This alternate means of running uses a set of scripts and text files to pass information from \texttt{UQpy} to a third-party model. This method of running the model supports both serial computation and parallel processing across multiple cores. It does not currently support distributed processing across multiple nodes in an HPC. 

\begin{figure}[!ht]
	\centering	{\includegraphics[width=\textwidth]{RunModel}}
	\caption{}
	\label{template_model}
\end{figure}

\begin{figure}[!ht]
	\centering	{\includegraphics[width=0.5\textwidth]{input_script}}
	\caption{}
	\label{template_model}
\end{figure}


\begin{figure}[!ht]
	\centering	{\includegraphics[width=0.5\textwidth]{model_script}}
	\caption{Need to edit this to include the model running on a computer}
	\label{template_model}
\end{figure}

\begin{figure}[!ht]
	\centering	{\includegraphics[width=0.5\textwidth]{output_script}}
	\caption{}
	\label{template_model}
\end{figure}

\subsubsection{Calling \texttt{RunModel} and defining its attributes}
\label{sec:RM_attributes}

\subsubsection{Necessary files and scripts}

\subsection{Supporting Modules, Functions, and Files}

\subsubsection{\texttt{Distributions} Module}
\label{Sec:Distributions}

The \texttt{Distributions} module is a support module that performs probability distribution related operations.  This includes functions for computing probabilities densities, cumulative distributions, and their inverses for common distribution types. 

The \texttt{Distributions} module is imported in a Python script using the following command:

\vspace{4mm}
\texttt{{\color{blue} from} \texttt{UQpy} {\color{blue} import} Distributions}
\vspace{4mm}

The \texttt{Distributions} module contains the following functions:

\vspace{4mm}
\begin{center}
	\begin{tabular}{ |l|l| } 
		\hline
		\textbf{Function} &  \textbf{Operation} \\
		\hline
		\texttt{pdf}& Probability Density Function  \\ 
		\hline
	\end{tabular}
\end{center}
\vspace{4mm}

The input and output of the \texttt{pdf} function are described in the table below.

\begin{center}
%	\resizebox{\textwidth}{!}{
	\begin{tabular}{ |l|c|c|c| } 
				\hline
		\multicolumn{4}{|c|}{\texttt{pdf} Function I/O} \\
		\hline
		\textbf{Attribute}  & Input/Output & \textbf{Type} & \textbf{Options} \\
		\hline
		\texttt{dist} & Input & {\it string} & Custom \\ 
		\hline
		\texttt{return} & Output & {\it float} & N/A \\ 
		\hline
	\end{tabular}%}
\end{center}

\noindent The \texttt{pdf} function enables the evaluation of a standard pdf or an arbitrary user-defined probability density function. When a custom pdf is used, the pdf is defined through the Python script `custom\_pdf.py', which must be located in the current working directory. Details follow.\\

\noindent\textbf{Description of \texttt{custom\_pdf.py}}\\

\noindent The script `custom\_pdf.py' allows the user to define a custom probability density function. In the script, the user may define a function that computes the pdf at a specified sample point. The function definition follows standard Python scripting conventions. For compatibility with \texttt{UQpy}, each function must be defined as follows:

\vspace{4mm}
\texttt{{\color{blue} def} func\_name(x, params)}\\
\hspace*{1.3cm} \texttt{pdf\_value = [User-defined operations]}\\
\hspace*{1.3cm} \texttt{return pdf\_value}
\vspace{4mm}

\noindent The name of the function, \texttt{func\_name}, can be specified arbitrarily by the user but must be identical to the name provided as a {\it string} to the value of \texttt{dist} from the \texttt{pdf} function described above.\\

\noindent The function is required to take two inputs: 
\begin{itemize}
\item \texttt{x}: (type = {\it float})\\ 
	The sample value at which to evaluate the probability density function.
\item \texttt{params}: (type = {\it list})\\
	A list of parameters for the probability density function. If the function does not require any parameters, the function must still take \texttt{params} as input. The user may then pass an 	empty list.
\end{itemize}

\noindent The function returns only the value of the pdf evaluate at \texttt{x}, defined by \texttt{pdf\_value}.\\

\noindent An example `custom\_pdf.py' file is provided with the second example from the \texttt{MCMC} class, MCMC\_Example2.ipynb. See Examples from Section \ref{Sec:MCMC}.

\end{document}