
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.Distributions &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.Distributions</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functionality for all probability distributions supported in ``UQpy``.</span>

<span class="sd">The ``Distributions`` module is  used  to  define  probability  distribution  objects.   These  objects  possess various</span>
<span class="sd">methods  that  allow the user  to:  compute  the  probability  density/mass  function ``pdf/pmf``, the cumulative</span>
<span class="sd">distribution  function ``cdf``, the logarithm of the pdf/pmf ``log_pdf/log_pmf``, return the moments ``moments``, draw</span>
<span class="sd">independent samples ``rvs`` and compute the maximum likelihood estimate of the parameters from data ``mle``.</span>

<span class="sd">The module contains the following parent classes - probability distributions are defined via sub-classing those parent</span>
<span class="sd">classes:</span>

<span class="sd">- ``Distribution``: Parent class to all distributions.</span>
<span class="sd">- ``DistributionContinuous1D``: Parent class to 1-dimensional continuous probability distributions.</span>
<span class="sd">- ``DistributionDiscrete1D``: Parent class to 1-dimensional discrete probability distributions.</span>
<span class="sd">- ``DistributionND``: Parent class to multivariate probability distributions.</span>
<span class="sd">- ``Copula``: Parent class to copula to model dependency between marginals.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">MethodType</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>

<span class="kn">from</span> <span class="nn">.Utilities</span> <span class="k">import</span> <span class="n">check_input_dims</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Define the probability distribution of the random parameters</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="Distribution"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Distribution">[docs]</a><span class="k">class</span> <span class="nc">Distribution</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class to all ``Distribution`` classes.</span>

<span class="sd">    All distributions possess a number of methods to perform basic probabilistic operations. For most of the predefined</span>
<span class="sd">    distributions in ``UQpy`` these methods are inherited from the ``scipy.stats`` package. These include standard</span>
<span class="sd">    operations such as computing probability density/mass functions, cumulative distribution functions and their</span>
<span class="sd">    inverse, drawing random samples, computing moments and parameter fitting. However, for user-defined distributions,</span>
<span class="sd">    any desired method can be constructed into the child class structure.</span>

<span class="sd">    For bookkeeping purposes, all ``Distribution`` objects possesses ``get_params`` and ``update_params`` methods. These</span>
<span class="sd">    are described in more detail below.</span>

<span class="sd">    Any ``Distribution`` further inherits from one of the following classes:</span>

<span class="sd">    - ``DistributionContinuous1D``: Parent class to 1-dimensional continuous probability distributions.</span>
<span class="sd">    - ``DistributionDiscrete1D``: Parent class to 1-dimensional discrete probability distributions.</span>
<span class="sd">    - ``DistributionND``: Parent class to multivariate probability distributions.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **order_params** (`list`):</span>
<span class="sd">        Ordered list of parameter names, useful when parameter values are stored in vectors and must be passed to the</span>
<span class="sd">        ``update_params`` method.</span>

<span class="sd">    * **params** (`dict`):</span>
<span class="sd">        Parameters of the distribution. Note: this attribute is not defined for certain ``Distribution`` objects such as</span>
<span class="sd">        those of type ``JointInd`` or ``JointCopula``. The user is advised to use the ``get_params`` method to access</span>
<span class="sd">        the parameters.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    **cdf** *(x)*</span>
<span class="sd">        Evaluate the cumulative distribution function.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `cdf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated cdf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **pdf** *(x)*</span>
<span class="sd">        Evaluate the probability density function of a continuous or multivariate mixed continuous-discrete</span>
<span class="sd">        distribution.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `pdf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated pdf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **pmf** *(x)*</span>
<span class="sd">        Evaluate the probability mass function of a discrete distribution.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `pmf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated pmf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **log_pdf** *(x)*</span>
<span class="sd">        Evaluate the logarithm of the probability density function of a continuous or multivariate mixed</span>
<span class="sd">        continuous-discrete distribution.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `log_pdf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated log-pdf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **log_pmf** *(x)*</span>
<span class="sd">        Evaluate the logarithm of the probability mass function of a discrete distribution.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `log_pmf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated log-pmf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **icdf** *(x)*</span>
<span class="sd">        Evaluate the inverse cumulative distribution function for univariate distributions.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Point(s) at which to evaluate the `icdf`, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Evaluated icdf values, `ndarray` of shape `(npoints,)`.</span>

<span class="sd">    **rvs** *(nsamples=1, random_state=None)*</span>
<span class="sd">        Sample independent identically distributed (iid) realizations.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of iid samples to be drawn. Default is 1.</span>

<span class="sd">        * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">            Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">            If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">            object itself can be passed directly.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`):</span>
<span class="sd">            Generated iid samples, `ndarray` of shape `(npoints, dimension)`.</span>

<span class="sd">    **moments** *(moments2return=&#39;mvsk&#39;)*</span>
<span class="sd">        Computes the mean &#39;m&#39;, variance/covariance (&#39;v&#39;), skewness (&#39;s&#39;) and/or kurtosis (&#39;k&#39;) of the distribution.</span>

<span class="sd">        For a univariate distribution, mean, variance, skewness and kurtosis are returned. For a multivariate</span>
<span class="sd">        distribution, the mean vector, covariance and vectors of marginal skewness and marginal kurtosis are returned.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **moments2return** (`str`):</span>
<span class="sd">            Indicates which moments are to be returned (mean, variance, skewness and/or kurtosis). Default is &#39;mvsk&#39;.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`tuple`):</span>
<span class="sd">            ``mean``: mean, ``var``:  variance/covariance, ``skew``: skewness, ``kurt``: kurtosis.</span>

<span class="sd">    **fit** *(data)*</span>
<span class="sd">        Compute the maximum-likelihood parameters from iid data.</span>

<span class="sd">        Computes the mle analytically if possible. For univariate continuous distributions, it leverages the fit</span>
<span class="sd">        method of the scipy.stats package.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **data** (`ndarray`):</span>
<span class="sd">            Data array, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`dict`):</span>
<span class="sd">            Maximum-likelihood parameter estimates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="n">order_params</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions between order_params tuple and params dictionary.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Distribution.update_params"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Distribution.update_params">[docs]</a>    <span class="k">def</span> <span class="nf">update_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * keyword arguments:</span>
<span class="sd">            Parameters to be updated, designated by their respective keywords.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong parameter name.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="Distribution.get_params"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Distribution.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`dict`):</span>
<span class="sd">            Parameters of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span></div></div>


<div class="viewcode-block" id="DistributionContinuous1D"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.DistributionContinuous1D">[docs]</a><span class="k">class</span> <span class="nc">DistributionContinuous1D</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for univariate continuous probability distributions.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the dimension of input x - must be an ndarray of shape (npoints,) or (npoints, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong dimension in x.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_construct_from_scipy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_continuous</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">icdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">moments2return</span><span class="o">=</span><span class="s1">&#39;mvsk&#39;</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">moments</span><span class="o">=</span><span class="n">moments2return</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">tmp_fit</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">fixed_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dist</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fixed_params</span><span class="p">[</span><span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">params_fitted</span> <span class="o">=</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">fixed_params</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">order_params</span><span class="p">,</span> <span class="n">params_fitted</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="n">tmp_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Univariate Continuous Distributions</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="Beta"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Beta">[docs]</a><span class="k">class</span> <span class="nc">Beta</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Beta distribution having probability density function</span>

<span class="sd">    .. math:: f(x|a,b) = \dfrac{\Gamma(a+b)x^{a-1}(1-x)^{b-1}}{\Gamma(a)\Gamma(b)}</span>

<span class="sd">    for :math:`0\le x\ge 0`, :math:`a&gt;0, b&gt;0`. Here :math:`\Gamma(a)` refers to the Gamma function.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`, the distribution is defined over the interval (0, 1). Use `loc` and</span>
<span class="sd">    `scale` to shift the distribution to interval `(loc, loc + scale)`. Specifically, this is equivalent to computing</span>
<span class="sd">    :math:`f(y|a,b)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **a** (`float`):</span>
<span class="sd">        first shape parameter</span>
<span class="sd">    * **b** (float):</span>
<span class="sd">        second shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Beta``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cauchy"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Cauchy">[docs]</a><span class="k">class</span> <span class="nc">Cauchy</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cauchy distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{1}{\pi(1+x^2)}</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Cauchy``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ploc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">cauchy</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChiSquare"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.ChiSquare">[docs]</a><span class="k">class</span> <span class="nc">ChiSquare</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chi-square distribution having probability density:</span>

<span class="sd">    .. math:: f(x|k) = \dfrac{1}{2^{k/2}\Gamma(k/2)}x^{k/2-1}\exp{(-x/2)}</span>

<span class="sd">    for :math:`x\ge 0`, :math:`k&gt;0`. Here :math:`\Gamma(\cdot)` refers to the Gamma function.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y|k)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **df** (`float`):</span>
<span class="sd">        shape parameter (degrees of freedom) (given by `k` in the equation above)</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``ChiSquare``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Exponential"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Exponential">[docs]</a><span class="k">class</span> <span class="nc">Exponential</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exponential distribution having probability density function:</span>

<span class="sd">    .. math:: f(x) = \exp(-x)</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    A common parameterization for Exponential is in terms of the rate parameter :math:`\lambda`, which corresponds to</span>
<span class="sd">    using :math:`scale = 1 / \lambda`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Exponential``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">expon</span><span class="p">)</span></div>


<div class="viewcode-block" id="Gamma"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Gamma">[docs]</a><span class="k">class</span> <span class="nc">Gamma</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gamma distribution having probability density function:</span>

<span class="sd">    .. math:: f(x|a) = \dfrac{x^{a-1}\exp(-x)}{\Gamma(a)}</span>

<span class="sd">    for :math:`x\ge 0`, :math:`a&gt;0`. Here :math:`\Gamma(a)` refers to the Gamma function.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **a** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Gamma``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenExtreme"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.GenExtreme">[docs]</a><span class="k">class</span> <span class="nc">GenExtreme</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generalized Extreme Value distribution having probability density function:</span>

<span class="sd">    .. math:: `f(x|c) = \exp(-(1-cx)^{1/c})(1-cx)^{1/c-1}`</span>

<span class="sd">    for :math:`x\le 1/c, c&gt;0`.</span>

<span class="sd">    For `c=0`</span>

<span class="sd">    .. math:: f(x) = \exp(\exp(-x))\exp(-x)</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **c** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``GenExtreme``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">genextreme</span><span class="p">)</span></div>


<div class="viewcode-block" id="InvGauss"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.InvGauss">[docs]</a><span class="k">class</span> <span class="nc">InvGauss</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse Gaussian distribution having probability density function</span>

<span class="sd">    .. math:: f(x|\mu) = \dfrac{1}{2\pi x^3}\exp{(-\dfrac{(x\\mu)^2}{2x\mu^2})}</span>

<span class="sd">    for :math:`x&gt;0`. ``cdf`` method returns `NaN` for :math:`\mu&lt;0.0028`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **mu** (`float`):</span>
<span class="sd">        shape parameter, :math:`\mu`</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    The following methods are available for ``InvGauss``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="p">)</span></div>


<div class="viewcode-block" id="Laplace"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Laplace">[docs]</a><span class="k">class</span> <span class="nc">Laplace</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Laplace distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{1}{2}\exp{-|x|}</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Laplace``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">laplace</span><span class="p">)</span></div>


<div class="viewcode-block" id="Levy"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Levy">[docs]</a><span class="k">class</span> <span class="nc">Levy</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levy distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{1}{\sqrt{2\pi x^3}}\exp(-\dfrac{1}{2x})</span>

<span class="sd">    for :math:`x\ge 0`.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Levy``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">levy</span><span class="p">)</span></div>


<div class="viewcode-block" id="Logistic"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Logistic">[docs]</a><span class="k">class</span> <span class="nc">Logistic</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logistic distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{\exp(-x)}{(1+\exp(-x))^2}</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Logistic``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lognormal"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Lognormal">[docs]</a><span class="k">class</span> <span class="nc">Lognormal</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lognormal distribution having probability density function</span>

<span class="sd">    .. math:: f(x|s) = \dfrac{1}{sx\sqrt{2\pi}}\exp(-\dfrac{\log^2(x)}{2s^2})</span>

<span class="sd">    for :math:`x&gt;0, s&gt;0`.</span>

<span class="sd">    A common parametrization for a lognormal random variable Y is in terms of the mean, mu, and standard deviation,</span>
<span class="sd">    sigma, of the gaussian random variable X such that exp(X) = Y. This parametrization corresponds to setting</span>
<span class="sd">    s = sigma and scale = exp(mu).</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **s** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Lognormal``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="p">)</span></div>


<div class="viewcode-block" id="Maxwell"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Maxwell">[docs]</a><span class="k">class</span> <span class="nc">Maxwell</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maxwell-Boltzmann distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \sqrt{2/\pi}x^2\exp(-x^2/2)</span>

<span class="sd">    for :math:`x\ge0`.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Maxwell``:</span>
<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">maxwell</span><span class="p">)</span></div>


<div class="viewcode-block" id="Normal"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Normal">[docs]</a><span class="k">class</span> <span class="nc">Normal</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normal distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{\exp(-x^2/2)}{\sqrt{2\pi}}</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        mean</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        standard deviation</span>

<span class="sd">    The following methods are available for ``Normal``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">mle_loc</span><span class="p">,</span> <span class="n">mle_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;scale&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mle_loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mle_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mle_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mle_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mle_loc</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">mle_loc</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">mle_scale</span><span class="p">}</span></div>


<div class="viewcode-block" id="Pareto"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Pareto">[docs]</a><span class="k">class</span> <span class="nc">Pareto</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pareto distribution having probability density function</span>

<span class="sd">    .. math:: f(x|b) = \dfrac{b}{x^{b+1}}</span>

<span class="sd">    for :math:`x\ge 1, b&gt;0`.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **b** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Pareto``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">pareto</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rayleigh"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Rayleigh">[docs]</a><span class="k">class</span> <span class="nc">Rayleigh</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rayleigh distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = x\exp(-x^2/2)</span>

<span class="sd">    for :math:`x\ge 0`.</span>

<span class="sd">    In this standard form `(loc=0, scale=1)`. Use `loc` and `scale` to shift and scale the distribution. Specifically,</span>
<span class="sd">    this is equivalent to computing :math:`f(y)` where :math:`y=(x-loc)/scale`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``Rayleigh``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">)</span></div>


<div class="viewcode-block" id="TruncNorm"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.TruncNorm">[docs]</a><span class="k">class</span> <span class="nc">TruncNorm</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Truncated normal distribution</span>

<span class="sd">    The standard form of this distribution (i.e, loc=0., scale=1) is a standard normal truncated to the range [a, b].</span>
<span class="sd">    Note that a and b are defined over the domain of the standard normal.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **a** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **b** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        scale parameter</span>

<span class="sd">    The following methods are available for ``TruncNorm``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">truncnorm</span><span class="p">)</span></div>


<div class="viewcode-block" id="Uniform"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Uniform">[docs]</a><span class="k">class</span> <span class="nc">Uniform</span><span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uniform distribution having probability density function</span>

<span class="sd">    .. math:: f(x|a, b) = \dfrac{1}{b-a}</span>

<span class="sd">    where :math:`a=loc` and :math:`b=loc+scale`</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        lower bound</span>
<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        range</span>

<span class="sd">    The following methods are available for ``Uniform``:</span>

<span class="sd">    * ``cdf``, ``pdf``, ``log_pdf``, ``icdf``, ``rvs``, ``moments``, ``fit``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Univariate Discrete Distributions</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="DistributionDiscrete1D"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.DistributionDiscrete1D">[docs]</a><span class="k">class</span> <span class="nc">DistributionDiscrete1D</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for univariate discrete distributions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the dimension of input x - must be an ndarray of shape (npoints,) or (npoints, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong dimension in x.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_construct_from_scipy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">rv_discrete</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pmf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">icdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">moments2return</span><span class="o">=</span><span class="s1">&#39;mvsk&#39;</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">moments</span><span class="o">=</span><span class="n">moments2return</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">scipy_name</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="Binomial"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Binomial">[docs]</a><span class="k">class</span> <span class="nc">Binomial</span><span class="p">(</span><span class="n">DistributionDiscrete1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binomial distribution having probability mass function:</span>

<span class="sd">    .. math:: f(x) = {n \choose x} p^x(1-p)^{n-x}</span>

<span class="sd">    for :math:`x\in\{0, 1, 2, ..., n\}`.</span>

<span class="sd">    In this standard form `(loc=0)`. Use `loc` to shift the distribution. Specifically, this is equivalent to computing</span>
<span class="sd">    :math:`f(y)` where :math:`y=x-loc`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **n** (`int`):</span>
<span class="sd">        number of trials, integer &gt;= 0</span>
<span class="sd">    * **p** (`float`):</span>
<span class="sd">        success probability for each trial, real number in [0, 1]</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>

<span class="sd">    The following methods are available for ``Binomial``:</span>

<span class="sd">    * ``cdf``, ``pmf``, ``log_pmf``, ``icdf``, ``rvs, moments``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">binom</span><span class="p">)</span></div>


<div class="viewcode-block" id="Poisson"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Poisson">[docs]</a><span class="k">class</span> <span class="nc">Poisson</span><span class="p">(</span><span class="n">DistributionDiscrete1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Poisson distribution having probability mass function:</span>

<span class="sd">    .. math:: f(x) = \exp{(-\mu)}\dfrac{\mu^k}{k!}</span>

<span class="sd">    for :math:`x\ge 0`.</span>

<span class="sd">    In this standard form `(loc=0)`. Use `loc` to shift the distribution. Specifically, this is equivalent to computing</span>
<span class="sd">    :math:`f(y)` where :math:`y=x-loc`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **mu** (`float`):</span>
<span class="sd">        shape parameter</span>
<span class="sd">    * **loc** (`float`):</span>
<span class="sd">        location parameter</span>

<span class="sd">    The following methods are available for ``Poisson``:</span>

<span class="sd">    * ``cdf``, ``pmf``, ``log_pmf``, ``icdf``, ``rvs``, ``moments``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_from_scipy</span><span class="p">(</span><span class="n">scipy_name</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Multivariate Continuous Distributions</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="DistributionND"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.DistributionND">[docs]</a><span class="k">class</span> <span class="nc">DistributionND</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for multivariate probability distributions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the dimension of input x - must be an ndarray of shape (npoints, d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong dimension in x.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong dimension in x.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="MVNormal"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.MVNormal">[docs]</a><span class="k">class</span> <span class="nc">MVNormal</span><span class="p">(</span><span class="n">DistributionND</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multivariate normal distribution having probability density function</span>

<span class="sd">    .. math:: f(x) = \dfrac{1}{\sqrt{(2\pi)^k\det\Sigma}}\exp{-\dfrac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)}</span>

<span class="sd">    where :math:`\mu` is the mean vector, :math:`\Sigma` is the covariance matrix, and :math:`k` is the dimension of</span>
<span class="sd">    `x`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **mean** (`ndarray`):</span>
<span class="sd">        mean vector, `ndarray` of shape `(dimension, )`</span>
<span class="sd">    * **cov** (`float` or `ndarray`):</span>
<span class="sd">        covariance, `float` or `ndarray` of shape `(dimension, )` or `(dimension, dimension)`. Default is 1.</span>

<span class="sd">    The following methods are available for ``MVNormal``:</span>

<span class="sd">    * ``pdf``, ``log_pdf``, ``rvs``, ``fit``, ``moments``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input mean must be a 1D array.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input cov must be a float or ndarray of appropriate dimensions.&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">pdf_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">logpdf_val</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">logpdf_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input nsamples must be an integer &gt; 0.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">mle_mu</span><span class="p">,</span> <span class="n">mle_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;cov&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mle_mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mle_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mle_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mle_mu</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">mle_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">tmp_x</span><span class="p">,</span> <span class="n">tmp_x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mle_mu</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">:</span> <span class="n">mle_cov</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moments2return</span><span class="o">=</span><span class="s1">&#39;mv&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;cov&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;mv&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;cov&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: moments2return must be &quot;m&quot;, &quot;v&quot; or &quot;mv&quot;.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Multinomial"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Multinomial">[docs]</a><span class="k">class</span> <span class="nc">Multinomial</span><span class="p">(</span><span class="n">DistributionND</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multinomial distribution having probability mass function</span>

<span class="sd">    .. math:: f(x) = \dfrac{n!}{x_1!\dots x_k!}p_1^{x_1}\dots p_k^{x_k}</span>

<span class="sd">    for :math:`x=\{x_1,\dots,x_k\}` where each :math:`x_i` is a non-negative integer and :math:`\sum_i x_i = n`.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **n** (`int`):</span>
<span class="sd">        number of trials</span>
<span class="sd">    * **p** (`array_like`):</span>
<span class="sd">        probability of a trial falling into each category; should sum to 1</span>

<span class="sd">    The following methods are available for ``Multinomial``:</span>

<span class="sd">    * ``pmf``, ``log_pmf``, ``rvs``, ``moments``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">multinomial</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">pdf_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">log_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">logpdf_val</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">multinomial</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">logpdf_val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input nsamples must be an integer &gt; 0.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">multinomial</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moments2return</span><span class="o">=</span><span class="s1">&#39;mv&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">mean</span>
        <span class="k">elif</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">cov</span>
        <span class="k">elif</span> <span class="n">moments2return</span> <span class="o">==</span> <span class="s1">&#39;mv&#39;</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;p&#39;</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">p</span>
            <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: moments2return must be &quot;m&quot;, &quot;v&quot; or &quot;mv&quot;.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="JointInd"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.JointInd">[docs]</a><span class="k">class</span> <span class="nc">JointInd</span><span class="p">(</span><span class="n">DistributionND</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a joint distribution from its independent marginals. ``JointInd`` is a child class of ``DistributionND``.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **marginals** (`list`):</span>
<span class="sd">        list of ``DistributionContinuous1D`` or ``DistributionDiscrete1D`` objects that define the marginals.</span>

<span class="sd">    Such a multivariate distribution possesses the following methods, on condition that all its univariate marginals</span>
<span class="sd">    also possess them:</span>

<span class="sd">    * ``pdf``, ``log_pdf``, ``cdf``, ``rvs``, ``fit``, ``moments``.</span>

<span class="sd">    The parameters of the distribution are only stored as attributes of the marginal objects. However, the</span>
<span class="sd">    *get_params* and *update_params* method can still be used for the joint. Note that, for this purpose, each parameter</span>
<span class="sd">    of the joint is assigned a unique string identifier as `key_index` - where `key` is the parameter name and `index`</span>
<span class="sd">    the index of the marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">marginals</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">order_params</span><span class="p">])</span>

        <span class="c1"># Check and save the marginals</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">marginals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">DistributionDiscrete1D</span><span class="p">))</span>
                                                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">marginals</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input marginals must be a list of Distribution1d objects.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span> <span class="o">=</span> <span class="n">marginals</span>

        <span class="c1"># If all marginals have a method, the joint has it to</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;pmf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_pdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute pdf of independent marginals</span>
                <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">))</span>
                <span class="k">for</span> <span class="n">ind_m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">],</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                        <span class="n">pdf_val</span> <span class="o">*=</span> <span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pdf_val</span> <span class="o">*=</span> <span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">]</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">pdf_val</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;log_pmf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_log_pdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute pdf of independent marginals</span>
                <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
                <span class="k">for</span> <span class="n">ind_m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">],</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
                        <span class="n">pdf_val</span> <span class="o">+=</span> <span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pdf_val</span> <span class="o">+=</span> <span class="n">marginals</span><span class="p">[</span><span class="n">ind_m</span><span class="p">]</span><span class="o">.</span><span class="n">log_pmf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">pdf_val</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_log_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pmf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_log_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_cdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute cdf of independent marginals</span>
                <span class="n">cdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                                            <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">cdf_val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_cdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_rvs</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Go through all marginals</span>
                <span class="n">rv_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                    <span class="n">rv_s</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">marg</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
                <span class="k">return</span> <span class="n">rv_s</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_rvs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_fit</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># Compute ml estimates of independent marginal parameters</span>
                <span class="n">mle_all</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                    <span class="n">mle_i</span> <span class="o">=</span> <span class="n">marg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                    <span class="n">mle_all</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind_m</span><span class="p">):</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mle_i</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
                <span class="k">return</span> <span class="n">mle_all</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_fit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;moments&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_moments</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">moments2return</span><span class="o">=</span><span class="s1">&#39;mvsk&#39;</span><span class="p">):</span>
                <span class="c1"># Go through all marginals</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">moments2return</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">moments2return</span><span class="o">=</span><span class="n">moments2return</span><span class="p">)</span> <span class="k">for</span> <span class="n">marg</span> <span class="ow">in</span> <span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">])</span>
                <span class="n">moments_</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">),</span> <span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">moments2return</span><span class="p">))]</span>
                <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                    <span class="n">moments_i</span> <span class="o">=</span> <span class="n">marg</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">moments2return</span><span class="o">=</span><span class="n">moments2return</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">moments2return</span><span class="p">)):</span>
                        <span class="n">moments_</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">ind_m</span><span class="p">]</span> <span class="o">=</span> <span class="n">moments_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">moments_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_moments</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`dict`):</span>
<span class="sd">            Parameters of the distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="n">params_m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params_m</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">update_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * keyword arguments:</span>
<span class="sd">            Parameters to be updated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check arguments</span>
        <span class="n">all_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># update the marginal parameters</span>
        <span class="k">for</span> <span class="n">key_indexed</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key_indexed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized keyword argument &#39;</span> <span class="o">+</span> <span class="n">key_indexed</span><span class="p">)</span>
            <span class="n">key_split</span> <span class="o">=</span> <span class="n">key_indexed</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="JointCopula"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.JointCopula">[docs]</a><span class="k">class</span> <span class="nc">JointCopula</span><span class="p">(</span><span class="n">DistributionND</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a joint distribution from a list of marginals and a copula to introduce dependency. ``JointCopula`` is a</span>
<span class="sd">    child class of ``DistributionND``.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **marginals** (`list`):</span>
<span class="sd">        `list` of ``DistributionContinuous1D`` or ``DistributionDiscrete1D`` objects that define the marginals</span>

<span class="sd">    * **copula** (`object`):</span>
<span class="sd">        object of class ``Copula``</span>

<span class="sd">    A ``JointCopula`` distribution may possess a ``cdf``, ``pdf`` and ``log_pdf`` methods if the copula allows for it</span>
<span class="sd">    (i.e., if the copula possesses the necessary ``evaluate_cdf`` and ``evaluate_pdf`` methods).</span>

<span class="sd">    The parameters of the distribution are only stored as attributes of the marginals/copula objects. However, the</span>
<span class="sd">    ``get_params`` and ``update_params`` methods can still be used for the joint. Note that each parameter of the joint</span>
<span class="sd">    is assigned a unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of</span>
<span class="sd">    the marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`); and `key_c` for copula</span>
<span class="sd">    parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">,</span> <span class="n">copula</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">marginals</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">order_params</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_c&#39;</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">copula</span><span class="o">.</span><span class="n">order_params</span><span class="p">])</span>

        <span class="c1"># Check and save the marginals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span> <span class="o">=</span> <span class="n">marginals</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">DistributionDiscrete1D</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input marginals must be a list of 1d continuous Distribution objects.&#39;</span><span class="p">)</span>

        <span class="c1"># Check the copula. Also, all the marginals should have a cdf method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copula</span> <span class="o">=</span> <span class="n">copula</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="p">,</span> <span class="n">Copula</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input copula should be a Copula object.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All the marginals should have a cdf method in order to define a joint with copula.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">check_marginals</span><span class="p">(</span><span class="n">marginals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)</span>

        <span class="c1"># Check if methods should exist, if yes define them bound them to the object</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="p">,</span> <span class="s1">&#39;evaluate_cdf&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_cdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute cdf of independent marginals</span>
                <span class="n">unif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span> <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># Compute copula</span>
                <span class="n">cdf_val</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">evaluate_cdf</span><span class="p">(</span><span class="n">unif</span><span class="o">=</span><span class="n">unif</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">cdf_val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_cdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="p">,</span> <span class="s1">&#39;evaluate_pdf&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_pdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute pdf of independent marginals</span>
                <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                                            <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Add copula term</span>
                <span class="n">unif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span> <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">c_</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">evaluate_pdf</span><span class="p">(</span><span class="n">unif</span><span class="o">=</span><span class="n">unif</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">c_</span> <span class="o">*</span> <span class="n">pdf_val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="p">,</span> <span class="s1">&#39;evaluate_pdf&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">joint_log_pdf</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">_check_x_dimension</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="c1"># Compute pdf of independent marginals</span>
                <span class="n">logpdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span>
                                              <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Add copula term</span>
                <span class="n">unif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">marg</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">ind_m</span><span class="p">])</span> <span class="k">for</span> <span class="n">ind_m</span><span class="p">,</span> <span class="n">marg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">c_</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">evaluate_pdf</span><span class="p">(</span><span class="n">unif</span><span class="o">=</span><span class="n">unif</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span> <span class="o">+</span> <span class="n">logpdf_val</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">joint_log_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`dict`):</span>
<span class="sd">            Parameters of the distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;_c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">update_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * keyword arguments:</span>
<span class="sd">            Parameters to be updated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check arguments</span>
        <span class="n">all_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># update the marginal parameters</span>
        <span class="k">for</span> <span class="n">key_indexed</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key_indexed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unrecognized keyword argument &#39;</span> <span class="o">+</span> <span class="n">key_indexed</span><span class="p">)</span>
            <span class="n">key_split</span> <span class="o">=</span> <span class="n">key_indexed</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Copulas</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="Copula"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Copula">[docs]</a><span class="k">class</span> <span class="nc">Copula</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a copula for a multivariate distribution whose dependence structure is defined with a copula.</span>

<span class="sd">    This class is used in support of the ``JointCopula`` distribution class.</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **params** (`dict`):</span>
<span class="sd">        Parameters of the copula.</span>

<span class="sd">    * **order_params** (`list`):</span>
<span class="sd">        List of parameter names</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    **evaluate_cdf** *(unif)*</span>
<span class="sd">        Compute the copula cdf :math:`C(u_1, u_2, ..., u_d)` for a `d`-variate uniform distribution.</span>

<span class="sd">        For a generic multivariate distribution with marginal cdfs :math:`F_1, ..., F_d` the joint cdf is computed as:</span>

<span class="sd">        :math:`F(x_1, ..., x_d) = C(u_1, u_2, ..., u_d)`</span>

<span class="sd">        where :math:`u_i = F_i(x_i)` is uniformly distributed. This computation is performed in the ``JointCopula.cdf``</span>
<span class="sd">        method.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **unif** (`ndarray`):</span>
<span class="sd">            Points (uniformly distributed) at which to evaluate the copula cdf, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`tuple`):</span>
<span class="sd">            Values of the cdf, `ndarray` of shape `(npoints, )`.</span>

<span class="sd">    **evaluate_pdf** *(unif)*</span>
<span class="sd">        Compute the copula pdf :math:`c(u_1, u_2, ..., u_d)` for a `d`-variate uniform distribution.</span>

<span class="sd">        For a generic multivariate distribution with marginals pdfs :math:`f_1, ..., f_d` and marginals cdfs</span>
<span class="sd">        :math:`F_1, ..., F_d`, the joint pdf is computed as:</span>

<span class="sd">        :math:`f(x_1, ..., x_d) = c(u_1, u_2, ..., u_d) f_1(x_1) ... f_d(x_d)`</span>

<span class="sd">        where :math:`u_i = F_i(x_i)` is uniformly distributed. This computation is performed in the ``JointCopula.pdf``</span>
<span class="sd">        method.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **unif** (`ndarray`):</span>
<span class="sd">            Points (uniformly distributed) at which to evaluate the copula pdf, must be of shape `(npoints, dimension)`.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`tuple`):</span>
<span class="sd">            Values of the copula pdf term, ndarray of shape `(npoints, )`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="n">order_params</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions between order_params tuple and params dictionary.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Copula.check_marginals"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Copula.check_marginals">[docs]</a>    <span class="k">def</span> <span class="nf">check_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform some checks on the marginals, raise errors if necessary.</span>

<span class="sd">        As an example, Archimedian copula are only defined for bi-variate continuous distributions, thus this method</span>
<span class="sd">        checks that marginals is of length 2 and continuous, and raise an error if that is not the case.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **unif** (ndarray):</span>
<span class="sd">            Points (uniformly distributed) at which to evaluate the copula pdf, must be of shape</span>
<span class="sd">            ``(npoints, dimension)``.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        No outputs, this code raises errors if necessary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

    <span class="k">def</span> <span class="nf">update_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong parameter name.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Gumbel"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Gumbel">[docs]</a><span class="k">class</span> <span class="nc">Gumbel</span><span class="p">(</span><span class="n">Copula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gumbel copula having cumulative distribution function</span>

<span class="sd">    .. math:: F(u_1, u_2) = \exp(-(-\log(u_1))^{\Theta} + (-\log(u_2))^{\Theta})^{1/{\Theta}}</span>

<span class="sd">    where :math:`u_1 = F_1(x_1), u_2 = F_2(x_2)` are uniformly distributed on the interval `[0, 1]`.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **theta** (`float`):</span>
<span class="sd">        Parameter of the Gumbel copula, real number in :math:`[1, +\infty)`.</span>

<span class="sd">    This copula possesses the following methods:</span>

<span class="sd">    * ``evaluate_cdf``, ``evaluate_pdf`` and ``check_copula``</span>

<span class="sd">    (``check_copula`` checks that `marginals` consist of solely 2 continuous univariate distributions).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Check the input copula_params</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input theta should be a float in [1, +oo).&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unif</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unif</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Gumbel Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">unif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
        <span class="n">cdf_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">theta</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cdf_val</span>

    <span class="k">def</span> <span class="nf">evaluate_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unif</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unif</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Gumbel Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">unif</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">theta</span><span class="p">))</span>

        <span class="n">pdf_val</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">u</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">v</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span> \
             <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
             <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="n">theta</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pdf_val</span>

    <span class="k">def</span> <span class="nf">check_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that marginals contains 2 continuous univariate distributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marginals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Gumbel Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">marginals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Marginals should be 1d continuous distributions.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Clayton"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Clayton">[docs]</a><span class="k">class</span> <span class="nc">Clayton</span><span class="p">(</span><span class="n">Copula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clayton copula having cumulative distribution function</span>

<span class="sd">    .. math:: F(u_1, u_2) = \max(u_1^{-\Theta} + u_2^{-\Theta} - 1, 0)^{-1/{\Theta}}</span>

<span class="sd">    where :math:`u_1 = F_1(x_1), u_2 = F_2(x_2)` are uniformly distributed on the interval `[0, 1]`.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **theta** (`float`):</span>
<span class="sd">        Parameter of the copula, real number in [-1, +oo)\{0}.</span>

<span class="sd">    This copula possesses the following methods:</span>

<span class="sd">    * ``evaluate_cdf`` and ``check_copula``</span>

<span class="sd">    (``check_copula`` checks that `marginals` consist of solely 2 continuous univariate distributions).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Check the input copula_params</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input theta should be a float in [-1, +oo)\</span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unif</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unif</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Clayton Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">unif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
        <span class="n">cdf_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">u</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">v</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cdf_val</span>

    <span class="k">def</span> <span class="nf">check_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marginals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Clayton Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">marginals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Marginals should be 1d continuous distributions.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Frank"><a class="viewcode-back" href="../../distributions.html#UQpy.Distributions.Frank">[docs]</a><span class="k">class</span> <span class="nc">Frank</span><span class="p">(</span><span class="n">Copula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Frank copula having cumulative distribution function</span>

<span class="sd">    :math:`F(u_1, u_2) = -\dfrac{1}{\Theta} \log(1+\dfrac{(\exp(-\Theta u_1)-1)(\exp(-\Theta u_2)-1)}{\exp(-\Theta)-1})`</span>

<span class="sd">    where :math:`u_1 = F_1(x_1), u_2 = F_2(x_2)` are uniformly distributed on the interval `[0, 1]`.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **theta** (`float`):</span>
<span class="sd">        Parameter of the copula, real number in R\{0}.</span>

<span class="sd">    This copula possesses the following methods:</span>

<span class="sd">    * ``evaluate_cdf`` and ``check_copula``</span>

<span class="sd">    (``check_copula`` checks that `marginals` consist of solely 2 continuous univariate distributions).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="c1"># Check the input copula_params</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">theta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input theta should be a float in R\</span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unif</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unif</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Clayton Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">unif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">unif</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
        <span class="n">tmp_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">cdf_val</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">tmp_ratio</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cdf_val</span>

    <span class="k">def</span> <span class="nf">check_marginals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginals</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marginals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Frank Copula is 2.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">marginals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Marginals should be 1d continuous distributions.&#39;</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">#        Old code</span>
<span class="c1">########################################################################################################################</span>
<span class="c1"># The supported univariate distributions are:</span>
<span class="n">list_univariates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;binomial&#39;</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="s1">&#39;genextreme&#39;</span><span class="p">,</span> <span class="s1">&#39;chisquare&#39;</span><span class="p">,</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;cauchy&#39;</span><span class="p">,</span> <span class="s1">&#39;levy&#39;</span><span class="p">,</span> <span class="s1">&#39;logistic&#39;</span><span class="p">,</span> <span class="s1">&#39;laplace&#39;</span><span class="p">,</span> <span class="s1">&#39;maxwell&#39;</span><span class="p">,</span> <span class="s1">&#39;inverse gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;pareto&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;rayleigh&#39;</span><span class="p">,</span> <span class="s1">&#39;truncnorm&#39;</span><span class="p">]</span>
<span class="c1"># The supported multivariate distributions are:</span>
<span class="n">list_multivariates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mvnormal&#39;</span><span class="p">]</span>
<span class="c1"># All scipy supported distributions</span>
<span class="n">list_all_scipy</span> <span class="o">=</span> <span class="n">list_univariates</span> <span class="o">+</span> <span class="n">list_multivariates</span>

<span class="k">class</span> <span class="nc">Distribution_old</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a probability distribution and invoke methods of a distribution</span>

<span class="sd">    This is the main distribution class in UQpy. The user can define a probability distribution by providing:</span>

<span class="sd">    - A name that points to a univariate/multivariate distribution.</span>
<span class="sd">    - A list of names of univariate distributions. In that case, a multivariate  distribution is built for which all</span>
<span class="sd">      dimensions are independent</span>
<span class="sd">    - A list of names of univariate distributions and a copula. In that case a multivariate distribution is built</span>
<span class="sd">      using the univariate distributions for the marginal pdfs and the prescribed copula for the dependence structure.</span>

<span class="sd">    The Distribution class provides a number of methods as well for computing the probability density function and its</span>
<span class="sd">    logarithm, computing the cumulative distribution function and its inverse, generating samples of random variables</span>
<span class="sd">    following the distribution, fitting a distribution, and computing the moments of the distribuiton. Note that all</span>
<span class="sd">    methods do not exist for all distributions.</span>

<span class="sd">    The helper function exist_method described below indicates which methods are defined for various types of</span>
<span class="sd">    distributions (i.e., univariate vs. multivariate, with or without copula, user-defined).</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_name: Name of the marginal distribution(s). The following distributions are available: &#39;normal&#39;,</span>
<span class="sd">                      &#39;uniform&#39;, &#39;binomial&#39;, &#39;beta&#39;, &#39;genextreme&#39;, &#39;chisquare&#39;, &#39;lognormal&#39;, &#39;gamma&#39;, &#39;exponential&#39;,</span>
<span class="sd">                      &#39;cauchy&#39;, &#39;levy&#39;, &#39;logistic&#39;, &#39;laplace&#39;, &#39;maxwell&#39;, &#39;inverse gauss&#39;, &#39;pareto&#39;, &#39;rayleigh&#39;,</span>
<span class="sd">                      &#39;truncnorm&#39;, &#39;mvnormal&#39;.</span>

<span class="sd">    :type dist_name: string or list of strings</span>

<span class="sd">    :param params: Parameters for the marginal distribution(s) (must be a list if distribution is multivariate).</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    :param copula: Name of copula to create dependence between dimensions, used only if dist_name is a list</span>

<span class="sd">                   Default: None</span>
<span class="sd">    :type copula: str</span>

<span class="sd">    :param copula_params: Parameters of the copula.</span>
<span class="sd">    :type copula_params: list or ndarray</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    Note that methods here are defined using *types.MethodType* because all of the methods listed below do not exist for</span>
<span class="sd">    all distributions. See the function *UQpy.Distributions.exist_method* below for further details on which methods</span>
<span class="sd">    are available for each distribution.</span>

<span class="sd">    :param self.pdf: Dynamic method that computes the probability density function (input arguments are x, params,</span>
<span class="sd">                     copula_params). Invoking this method executes the *UQpy.Distributions.pdf* function described</span>
<span class="sd">                     below.</span>
<span class="sd">    :type self.pdf: Callable</span>

<span class="sd">    :param self.cdf: Dynamic method that computes the cumulative distribution function. Invoking this method executes</span>
<span class="sd">                     the *UQpy.Distributions.cdf* function described below.</span>
<span class="sd">    :type self.cdf: Callable</span>

<span class="sd">    :param self.icdf: Dynamic method that computes the inverse cumulative distribution function. Invoking this method</span>
<span class="sd">                      executes the *UQpy.Distributions.icdf* function described below.</span>
<span class="sd">    :type self.icdf: Callable</span>

<span class="sd">    :param self.rvs: Dynamic method that generates random samples from the distribution. Invoking this method executes</span>
<span class="sd">                     the *UQpy.Distributions.rvs* function described below.</span>
<span class="sd">    :type self.rvs: Callable</span>

<span class="sd">    :param self.log_pdf: Dynamic method that computes the logarithm of the probability density function. Invoking this</span>
<span class="sd">                         method executes the *UQpy.Distributions.log_pdf* function described below.</span>
<span class="sd">    :type self.log_pdf: Callable</span>

<span class="sd">    :param self.fit: Dynamic method that estimates distribution parameters from provided data. Invoking this method</span>
<span class="sd">                     executes the *UQpy.Distributions.fit* function described below.</span>
<span class="sd">    :type self.fit: Callable</span>

<span class="sd">    :param self.moments: Dynamic method that calculates the first four moments of the distribution. Invoking this</span>
<span class="sd">                         method executes the *UQpy.Distributions.moments* function described below.</span>
<span class="sd">    :type self.moments: Callable</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Dimitris Giovanis, Audrey Olivier, Michael D. Shields</span>

<span class="sd">    Last Modified: 4/17/20 by Audrey Olivier &amp; Michael D. Shields</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_name</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Check dist_name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_all_scipy</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dist_name</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dist_name should be a supported density or name of an existing .py file&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d_</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">dist_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([(</span><span class="n">d_</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_all_scipy</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d_</span> <span class="o">+</span> <span class="s1">&#39;.py&#39;</span><span class="p">)))</span>
                        <span class="k">for</span> <span class="n">d_</span> <span class="ow">in</span> <span class="n">dist_name</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dist_name should be a list of supported densities or names of an existing .py file&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;dist_name should be a (list of) string(s)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Instantiate copula</span>
        <span class="k">if</span> <span class="n">copula</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copula</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: when provided, copula should be a string.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: dist_name must be a list of strings to define a copula.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copula_obj</span> <span class="o">=</span> <span class="n">Copula_old</span><span class="p">(</span><span class="n">copula_name</span><span class="o">=</span><span class="n">copula</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copula_params</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Method that saves the parameters as attributes of the class if they are provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">)</span>

        <span class="c1"># Other methods: you first need to check that they exist</span>
        <span class="n">exist_methods</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="s1">&#39;moments&#39;</span><span class="p">]:</span>
            <span class="n">exist_methods</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">exist_method</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span>
                                                 <span class="n">has_copula</span><span class="o">=</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;pdf&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;cdf&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;icdf&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">icdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">icdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rvs</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">rvs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;log_pdf&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist_methods</span><span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of a ``Distributions`` object.</span>

<span class="sd">        To update the parameters of a ``JointInd`` or a ``JointCopula`` distribution, each parameter is assigned a</span>
<span class="sd">        unique string identifier as `key_index` - where `key` is the parameter name and `index` the index of the</span>
<span class="sd">        marginal (e.g., location parameter of the 2nd marginal is identified as `loc_1`).</span>

<span class="sd">        **Input:**</span>

<span class="sd">        :param params: Parameters for the marginal distribution(s) (must be a list if distribution is multivariate).</span>
<span class="sd">        :type params: list or ndarray</span>

<span class="sd">        :param copula_params: Parameters of the copula.</span>
<span class="sd">        :type copula_params: list or ndarray</span>

<span class="sd">        **Output/Returns**</span>

<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">if</span> <span class="n">copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copula_params</span> <span class="o">=</span> <span class="n">copula_params</span>


<span class="c1"># Define the function that computes pdf</span>
<span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the probability density function of a distribution dist_object at input points x.</span>

<span class="sd">    This is a utility function used to define the pdf method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.pdf(x, params, copula_params). If given, inputs params/copula_params overwrite the params/copula_params</span>
<span class="sd">    attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param x: Point(s) at which to evaluate the pdf.</span>
<span class="sd">    :type x: ndarray of shape (npoints, dimension)</span>

<span class="sd">    :param params: Parameters for the distribution</span>
<span class="sd">    :type params: list of lists or ndarray</span>

<span class="sd">    :param copula_params: Parameters of the copula</span>
<span class="sd">    :type copula_params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param pdf_values: Value(s) of the pdf at point(s) x.</span>
<span class="sd">    :type pdf_values: ndarray of shape (npoints, )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">check_input_dims</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions in inputs dist_name and params.&#39;</span><span class="p">)</span>
        <span class="n">pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
            <span class="n">pdf_values</span> <span class="o">=</span> <span class="n">pdf_values</span> <span class="o">*</span> <span class="n">subdistribution_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                                          <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">c_</span> <span class="o">=</span> <span class="n">dist_object</span><span class="o">.</span><span class="n">copula_obj</span><span class="o">.</span><span class="n">evaluate_copula</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                                       <span class="n">copula_params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">copula_params</span><span class="p">)</span>
            <span class="n">pdf_values</span> <span class="o">*=</span> <span class="n">c_</span>
        <span class="k">return</span> <span class="n">pdf_values</span>


<span class="c1"># Function that computes the cdf</span>
<span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the cumulative distribution function at input points x.</span>

<span class="sd">    This is a utility function used to define the cdf method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.cdf(x, params, copula_params). If given, inputs params/copula_params overwrite the params/copula_params</span>
<span class="sd">    attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param x: Point(s) at which to evaluate the cdf.</span>
<span class="sd">    :type x: ndarray of shape (npoints, dimension)</span>

<span class="sd">    :param params: Parameters for the distribution</span>
<span class="sd">    :type params: list of lists or ndarray</span>

<span class="sd">    :param copula_params: Parameters of the copula</span>
<span class="sd">    :type copula_params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param cdf_values: Values of the cdf at points x.</span>
<span class="sd">    :type cdf_values: ndarray of shape (npoints, )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">check_input_dims</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_cdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions in inputs dist_name and params.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">cdfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
                <span class="n">cdfs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdistribution_cdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                                 <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">cdfs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cdf_values</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dist_object</span><span class="o">.</span><span class="n">copula</span><span class="o">.</span><span class="n">evaluate_copula</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="n">copula_params</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cdf_values</span>


<span class="c1"># Method that computes the icdf</span>
<span class="k">def</span> <span class="nf">icdf</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the inverse distribution function at inputs points x (only for univariate distributions).</span>

<span class="sd">    This is a utility function used to define the icdf method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.icdf(x, params). If given, input params overwrites the params attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param x: Point(s) where to evaluate the icdf.</span>
<span class="sd">    :type x: ndarray of shape (npoints, 1)</span>

<span class="sd">    :param params: Parameters for the distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param icdf_values: Values of the icdf at points x.</span>
<span class="sd">    :type icdf_values: ndarray of shape (npoints, )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">check_input_dims</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_icdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Method icdf not defined for multivariate distributions.&#39;</span><span class="p">)</span>


<span class="c1"># Method that generates RVs</span>
<span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample iid realizations from the distribution - does not support distributions with copula.</span>

<span class="sd">    This is a utility function used to define the rvs method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.rvs(x, params). If given, input params overwrites the params attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param nsamples: An integer providing the desired number of iid samples to be drawn.</span>

<span class="sd">                     Default: 1</span>
<span class="sd">    :type nsamples:  int</span>

<span class="sd">    :param params: Parameters for the distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output:**</span>

<span class="sd">    :return rv_s: Realizations from the distribution</span>
<span class="sd">    :rtype rv_s: ndarray of shape (nsamples, dimension)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_rvs</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: Inconsistent dimensions&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">rv_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
                <span class="n">rv_s</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdistribution_rvs</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span>
                                                 <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">rv_s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Method rvs not defined for distributions with copula.&#39;</span><span class="p">)</span>


<span class="c1"># Define the function that computes the log pdf</span>
<span class="k">def</span> <span class="nf">log_pdf</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the logarithm of the probability density function of a distribution at input points x.</span>

<span class="sd">    This is a utility function used to define the log_pdf method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.log_pdf(x, params, copula_params). If given, inputs params/copula_params overwrite the</span>
<span class="sd">    params/copula_params attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param x: Points where to estimate the log-pdf.</span>
<span class="sd">    :type x: 2D ndarray (npoints, dimension)</span>

<span class="sd">    :param params: Parameters of the distribution.</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    :param copula_params: Parameters of the copula.</span>
<span class="sd">    :type copula_params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param log_pdf_values: Values of the log-pdf evaluated at points x.</span>
<span class="sd">    :type log_pdf_values: ndarray of shape (npoints, )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">check_input_dims</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_log_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions in inputs dist_name and params.&#39;</span><span class="p">)</span>
        <span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
            <span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">log_pdf_values</span> <span class="o">+</span> <span class="n">subdistribution_log_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                      <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                                                      <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">c_</span> <span class="o">=</span> <span class="n">dist_object</span><span class="o">.</span><span class="n">copula_obj</span><span class="o">.</span><span class="n">evaluate_copula</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">copula_params</span><span class="p">)</span>
            <span class="n">log_pdf_values</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">log_pdf_values</span>


<span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the MLE parameters of a distribution from data x - does not support distributions with copula.</span>

<span class="sd">    This is a utility function used to define the fit method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.fit(x).</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param x: Vector of data x, contains iid samples from the distribution</span>
<span class="sd">    :type x: ndarray of shape (nsamples, dimension)</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param params_fit: MLE parameters.</span>
<span class="sd">    :type params_fit: ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">check_input_dims</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_fit</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inconsistent dimensions in inputs dist_name and x.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">params_fit</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
                <span class="n">params_fit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subdistribution_fit</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">params_fit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Method fit not defined for distributions with copula.&#39;</span><span class="p">)</span>


<span class="c1"># Method that computes moments</span>
<span class="k">def</span> <span class="nf">moments</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute marginal moments (mean, variance, skewness, kurtosis). Does not support distributions with copula.</span>

<span class="sd">    This is a utility function used to define the moments method of the Distribution class. This method is called as</span>
<span class="sd">    dist_object.moments(params). If given, input params overwrites the params attributes of the dist_object.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dist_object: Object of the Distribution class defining the distribution</span>
<span class="sd">    :type dist_object: Object of *UQpy.Distributions.Distribution*</span>

<span class="sd">    :param params: Parameters of the distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param mean: Mean value(s).</span>
<span class="sd">    :type mean: list</span>

<span class="sd">    :param var: Variance(s).</span>
<span class="sd">    :type var: list</span>

<span class="sd">    :param skew: Skewness value(s).</span>
<span class="sd">    :type skew: list</span>

<span class="sd">    :param kurt: Kurtosis value(s).</span>
<span class="sd">    :type kurt: list</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">dist_object</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">subdistribution_moments</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: Inconsistent dimensions&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;copula&#39;</span><span class="p">):</span>
            <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">),</span> \
                                    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">),</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)):</span>
                <span class="n">mean</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">var</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">skew</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">kurt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdistribution_moments</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                                            <span class="n">params</span><span class="o">=</span><span class="n">dist_object</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Method moments not defined for distributions with copula.&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Copula_old</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a copula for a multivariate distribution whose dependence structure is defined with a copula.</span>

<span class="sd">    This class is used in support of the main Distribution class. The following copula are supported: Gumbel.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param copula_name: Name of copula.</span>
<span class="sd">    :type copula_name: string</span>

<span class="sd">    :param dist_name: Names of the marginal distributions.</span>
<span class="sd">    :type dist_name: list of strings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copula_name</span><span class="p">,</span> <span class="n">dist_name</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">copula_name</span> <span class="o">=</span> <span class="n">copula_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>

    <span class="k">def</span> <span class="nf">evaluate_copula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dist_params</span><span class="p">,</span> <span class="n">copula_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the copula cdf c and copula density c_ necessary to evaluate the cdf and pdf, respectively, of the</span>
<span class="sd">        associated multivariate distribution.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        :param x: Points at which to evaluate the copula cdf and pdf.</span>
<span class="sd">        :type x: ndarray of shape (npoints, dimension)</span>

<span class="sd">        :param dist_params: Parameters of the marginal distributions.</span>
<span class="sd">        :type dist_params: list of lists or ndarray</span>

<span class="sd">        :param copula_params: Parameter of the copula.</span>
<span class="sd">        :type copula_params: list or ndarray</span>

<span class="sd">        **Output/Returns**</span>

<span class="sd">        :param c: Copula cdf</span>
<span class="sd">        :type c: ndarray</span>

<span class="sd">        :param c\_: Copula pdf</span>
<span class="sd">        :type c\_: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copula_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gumbel&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum dimension for the Gumbel Copula is 2.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copula_params</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">copula_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">copula_params</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter for Gumbel copula must be defined in [1, +oo)&#39;</span><span class="p">)</span>

            <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">uu</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdistribution_cdf</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                               <span class="n">params</span><span class="o">=</span><span class="n">dist_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">uu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">uu</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">uu</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span>
                            <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

                <span class="n">c_</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="n">u</span><span class="o">*</span><span class="mi">1</span><span class="o">/</span><span class="n">v</span><span class="o">*</span><span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> \
                    <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>\
                    <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                                   <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">**</span> <span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">copula_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Copula type not supported!&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">exist_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">dist_name</span><span class="p">,</span> <span class="n">has_copula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether a method exists for a given distribution.</span>

<span class="sd">    In particular:</span>

<span class="sd">    - All methods exist for univariate scipy distributions,</span>
<span class="sd">    - Multivariate scipy distributions have pdf, logpdf, cdf and rvs,</span>
<span class="sd">    - icdf method does not exist for any multivariate distribution,</span>
<span class="sd">    - rvs, fit and moments method do not exist for multivariate distributions with copula.</span>
<span class="sd">    - For any multivariate distribution with independent marginals, a method exists if it exists for all its marginals.</span>
<span class="sd">    - For custom distributions, only methods provided within the corresponding .py file exist.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param method: Name of the method to be checked (pdf, cdf, icdf, rvs, log_pdf, moments, fit)</span>
<span class="sd">    :type method: str</span>

<span class="sd">    :param dist_name: Name of the marginal distribution(s)</span>
<span class="sd">    :type dist_name: str or list of str</span>

<span class="sd">    :param has_copula: indicates whether a copula exists</span>
<span class="sd">    :type has_copula: bool</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param method_exist: Indicates whether the method exists for this distribution</span>
<span class="sd">    :type method_exist: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>    <span class="c1"># check the subdistribution</span>
        <span class="k">return</span> <span class="n">subdistribution_exist_method</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>    <span class="c1"># Check all the subdistributions</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;icdf&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># distributions with copula do not have rvs, fit, moments</span>
        <span class="k">if</span> <span class="n">has_copula</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;moments&#39;</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># method exist if all subdistributions have the corresponding method</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">subdistribution_exist_method</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dist_name</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># The following functions are helper functions for subdistributions, i.e., distributions where dist_name</span>
<span class="c1"># is only a string</span>

<span class="k">def</span> <span class="nf">subdistribution_exist_method</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether a method exists for a given sub-distribution (i.e., a distribution defined by a single string,</span>
<span class="sd">    univariate marginal or custom file).</span>

<span class="sd">    This is a helper function, used within the main Distribution class and exist_method function.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param method: name of the method to be checked (pdf, cdf, icdf, rvs, log_pdf, moments, fit)</span>
<span class="sd">    :type method: str</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param method_exist: indicates whether the method exist for this distribution</span>
<span class="sd">    :type method_exist: bool</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># Multivariate scipy distributions have pdf, logpdf, cdf and rvs</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># User defined distributions: check !</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">subdistribution_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate pdf for sub-distribution (i.e., distribution defined by a single string, univariate marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param x: points where to evaluate the pdf</span>
<span class="sd">    :type x: ndarray</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param pdf_val: values of the pdf evaluated at points in x</span>
<span class="sd">    :type pdf_val: ndarray of shape (npoints,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">subdistribution_cdf</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate cdf for sub-distribution (i.e., distribution defined by a single string, univariate marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param x: points where to evaluate the cdf</span>
<span class="sd">    :type x: ndarray</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param cdf_val: values of the cdf evaluated at points in x</span>
<span class="sd">    :type cdf_val: ndarray of shape (npoints,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">subdistribution_icdf</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate inverse cdf for sub-distribution (i.e., distribution defined by a single string, univariate marginal</span>
<span class="sd">    or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param x: points where to evaluate the icdf</span>
<span class="sd">    :type x: ndarray</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param icdf_val: values of the icdf evaluated at points in x</span>
<span class="sd">    :type icdf_val: ndarray of shape (npoints,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">subdistribution_rvs</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample realizations from sub-distribution (i.e., distribution defined by a single string, marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param nsamples: number of realizations to sample</span>
<span class="sd">    :type nsamples: int</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param samples: realizations of the sub-distribution</span>
<span class="sd">    :type samples: ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">list_univariates</span> <span class="o">+</span> <span class="n">list_multivariates</span><span class="p">):</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">rv_s</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">)</span>
        <span class="n">rv_s</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rv_s</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">rv_s</span><span class="p">]])</span>    <span class="c1"># one sample in a 1d space</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rv_s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rv_s</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>    <span class="c1"># one sample in a d-dimensional space</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rv_s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>    <span class="c1"># several samples in a one-dimensional space</span>
    <span class="k">return</span> <span class="n">rv_s</span>


<span class="k">def</span> <span class="nf">subdistribution_log_pdf</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate logpdf for sub-distribution (i.e., distribution defined by a single string, univariate marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param x: points where to evaluate the log-pdf</span>
<span class="sd">    :type x: ndarray</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param logpdf_val: values of the log-pdf evaluated at points in x</span>
<span class="sd">    :type logpdf_val: ndarray of shape (npoints,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">subdistribution_fit</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit parameters of sub-distribution (i.e., distribution defined by a single string, univariate marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param x: data used for fitting</span>
<span class="sd">    :type x: ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param mle_params: fitted parameters</span>
<span class="sd">    :type mle_params: ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_multivariates</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">subdistribution_moments</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute moments of sub-distribution (i.e., distribution defined by a single string, univariate marginal or custom).</span>

<span class="sd">    This is a helper function, used within the main Distribution class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param moments: moments of sub-distribution (mean, var, skewness, kurtosis)</span>
<span class="sd">    :type moments: ndarray of shape (4,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it is a supported scipy distribution:</span>
    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">list_univariates</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurt</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">moments</span><span class="o">=</span><span class="s1">&#39;mvsk&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">skew</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">kurt</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="c1"># Otherwise it must be a file</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">custom_dist</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">custom_dist</span><span class="p">,</span> <span class="s1">&#39;moments&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">scipy_distributions</span><span class="p">(</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a scipy distribution object and map argument params to the scipy parameters.</span>

<span class="sd">    This is a helper function, used within the main Distribution class that serves to translate UQpy distribution</span>
<span class="sd">    parameters to scipy distribution parameters in order to leverage scipy distribution objects.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    :param dist_name: name of the sub-distribution</span>
<span class="sd">    :type dist_name: str</span>

<span class="sd">    :param params: parameters of the sub-distribution</span>
<span class="sd">    :type params: list or ndarray</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    :param dist: scipy.stats distribution object</span>
<span class="sd">    :type dist: object</span>

<span class="sd">    :param params_dict: dictionary that maps the scipy parameters (scale, loc...) to elements of vector params</span>
<span class="sd">    :type params_dict: dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

    <span class="k">if</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span> <span class="ow">or</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">binom</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;beta&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;genextreme&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">genextreme</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;chisquare&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;df&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;lognormal&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;exponential&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">expon</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cauchy&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">cauchy</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;inverse gauss&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;logistic&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">logistic</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;pareto&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">pareto</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;rayleigh&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;levy&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">levy</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;laplace&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">laplace</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;maxwell&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">maxwell</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;truncnorm&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;loc&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">truncnorm</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">elif</span> <span class="n">dist_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mvnormal&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;cov&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dimension_reduction.html">Dimension reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, SURG, JHU.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>