
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.SampleMethods &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.SampleMethods</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;This module contains functionality for all the sampling methods supported in UQpy.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Monte Carlo Simulation</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS">[docs]</a><span class="k">class</span> <span class="nc">MCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Monte Carlo sampling (MCS) of random variables.</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">                        Probability distribution of each random variable. Must be an object of type ``Distribution``.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">                     Number of samples to be drawn from each distribution.</span>

<span class="sd">    * **random_state** ((list of) `int(s)`):</span>
<span class="sd">                        The random seed to initialize the *Mersenne Twister* pseudo-random number generator.</span>

<span class="sd">    * **verbose** (Boolean):</span>
<span class="sd">                        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">                        Default value: False</span>

<span class="sd">    **Output/Returns:**</span>

<span class="sd">    * **samples** (`ndarray` or `list`):</span>
<span class="sd">                        Generated samples. If a list of ``DistributionContinuous1D``, ``DistributionContinuous1D``</span>
<span class="sd">                        objects is provided then **samples** is an array with</span>
<span class="sd">                        ``samples.shape=(nsamples, len(dist_object))``. If  ``DistributionContinuous1D`` object is</span>
<span class="sd">                        provided then **samples** is an array with ``samples.shape=(nsamples, 1)``. If a</span>
<span class="sd">                        ``DistributionContinuousND`` object is provided then **samples** is an array with</span>
<span class="sd">                        ``samples.shape=(nsamples, ND)``. If a list of ``DistributionContinuous1D``,</span>
<span class="sd">                        ``DistributionContinuousND`` is provided then **samples** is a list with</span>
<span class="sd">                        ``len(samples)=nsamples`` and ``len(samples[i]) = len(dist_object)``.</span>

<span class="sd">    * **samplesU01** (`ndarray` (`list`)):</span>
<span class="sd">                        If the ``Distribution`` object has a ``cdf`` method, MCS also returns the samples in the</span>
<span class="sd">                        Uniform(0,1) hypercube using the method ``transform_u01``.</span>

<span class="sd">    **Methods**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Check if a Distribution object is provided.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dist_object</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: A Distribution object is required.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Distribution</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                        <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="n">add_continuous_1d</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionND</span><span class="p">):</span>
                        <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="n">add_continuous_nd</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">add_continuous_1d</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_state</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Incompatible dimensions between random_state and dist_object.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">random_state</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Incompatible dimensions between random_state and dist_object.&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>

        <span class="c1"># Instantiate the output attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="c1"># ==============================================================================================================</span>
        <span class="c1">#                                       Run Monte Carlo sampling</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="MCS.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``run`` method of the ``MCS`` class can be invoked many times and the generated samples are appended to the</span>
<span class="sd">        existing samples. For example, to the 5 samples in object ``x1`` we can add two more by running</span>

<span class="sd">        &gt;&gt;&gt; print(x1)</span>
<span class="sd">            &lt;UQpy.SampleMethods.MCS object at 0x1a148ba85&gt;</span>
<span class="sd">        &gt;&gt;&gt; x1.run(nsamples=2, random_state=[123, 567])</span>
<span class="sd">        &gt;&gt;&gt; print(x1.samples)</span>
<span class="sd">            [[ 1.62434536  1.78862847]</span>
<span class="sd">             [-0.61175641  0.43650985]</span>
<span class="sd">             [-0.52817175  0.09649747]</span>
<span class="sd">             [-1.07296862 -1.8634927 ]</span>
<span class="sd">             [ 0.86540763 -0.2773882 ]</span>
<span class="sd">             [ 1.62434536  1.78862847]</span>
<span class="sd">             [-0.61175641  0.43650985]]</span>

<span class="sd">        The total number of samples is now</span>

<span class="sd">        &gt;&gt;&gt; print(x1.nsamples)</span>
<span class="sd">            7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if a random_state is provided.</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_state</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Incompatible dimensions between random_state and dist_object.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Incompatible dimensions between random_state and dist_object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Number of samples must be defined.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples should be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Monte Carlo Sampling.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">temp_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                    <span class="n">temp_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: rvs method is missing.&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_samples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                <span class="n">temp_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">temp_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If self.samples already has existing samples, append the new samples to the existing attribute.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Monte Carlo Sampling Complete.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MCS.transform_u01"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCS.transform_u01">[docs]</a>    <span class="k">def</span> <span class="nf">transform_u01</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``transform_u01`` method of the ``MCS`` is used to transform samples from the parameter space to the</span>
<span class="sd">        Uniform [0, 1] space. ``Distribution`` objects need to have a ``cdf`` method.</span>

<span class="sd">        &gt;&gt;&gt; print(x1)</span>
<span class="sd">            &lt;UQpy.SampleMethods.MCS object at 0x1a18c03450&gt;</span>
<span class="sd">        &gt;&gt;&gt; x1.transform_u01()</span>
<span class="sd">        &gt;&gt;&gt; print(x1.samplesU01)</span>
<span class="sd">            [[0.94784894 0.96316267]</span>
<span class="sd">             [0.27034947 0.66876657]</span>
<span class="sd">             [0.29869007 0.53843726]</span>
<span class="sd">             [0.1416426  0.03119649]</span>
<span class="sd">             [0.80659245 0.39074102]</span>
<span class="sd">             [0.94784894 0.96316267]</span>
<span class="sd">             [0.27034947 0.66876657]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">temp_samples_u01</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">][:]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span>
                <span class="n">temp_samples_u01</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">temp_samples_u01</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Latin hypercube sampling  (LHS)</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="LHS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS">[docs]</a><span class="k">class</span> <span class="nc">LHS</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Latin hypercube sampling (MCS) of random variables.</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">                    List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">                    Number of samples to be drawn from each distribution.</span>


<span class="sd">    * **criterion** (`str` or `callable`):</span>
<span class="sd">                The criterion for generating sample points</span>
<span class="sd">                    Options:</span>
<span class="sd">                        1. &#39;random&#39; - completely random. \n</span>
<span class="sd">                        2. centered&#39; - points only at the centre. \n</span>
<span class="sd">                        3. &#39;maximin - maximizing the minimum distance between points. \n</span>
<span class="sd">                        4. &#39;correlate&#39; - minimizing the correlation between the points. \n</span>
<span class="sd">                        5. `callable` - User-defined method.</span>

<span class="sd">                Default: &#39;random&#39;</span>

<span class="sd">    * **metric** (`str` or `callable`):</span>
<span class="sd">                The distance metric to use.</span>
<span class="sd">                    Options:</span>
<span class="sd">                        1. `str` - Available options are: `braycurtis`, `canberra`, `chebyshev`, `cityblock`,</span>
<span class="sd">                        `correlation`, `cosine`, `dice`, `euclidean`, `hamming`, `jaccard`, `jensenshannon`,</span>
<span class="sd">                        `kulsinski`, `mahalanobis`, `matching`, `minkowski`, `rogerstanimoto`, `russellrao`,</span>
<span class="sd">                        `seuclidean`, `sokalmichener`, `sokalsneath`, `sqeuclidean`, `yule`.</span>

<span class="sd">                    2. User-defined function.</span>

<span class="sd">                Default: `euclidean`.</span>

<span class="sd">    * **iterations** (`int`):</span>
<span class="sd">                The number of iteration to run. Required only for ``maximin`` and ``correlate`` criterion.</span>

<span class="sd">                Default: 100.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">                    A boolean declaring whether to write text to the terminal.</span>

<span class="sd">                    Default value: False</span>


<span class="sd">    **Output/Returns:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">                    `ndarray` containing the generated samples.</span>

<span class="sd">    **Methods**</span>

<span class="sd">    The LHS class supports the following LHS design methods:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                 <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>  <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Check if a Distribution object is provided.</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D object must be provided.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D or JointInd object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">,</span> <span class="s1">&#39;maximin&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs criteria: &#39;random&#39;, &#39;centered&#39;, &#39;maximin&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;correlate&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span> <span class="s1">&#39;canberra&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;dice&#39;</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;kulsinski&#39;</span><span class="p">,</span> <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span> <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span> <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span> <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs distances: &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;cityblock&#39;,&quot;</span> <span class="s2">&quot; &#39;correlation&#39;, &#39;cosine&#39;,&#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;jaccard&#39;, &quot;</span> <span class="s2">&quot;&#39;kulsinski&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;rogerstanimoto&#39;,&quot;</span> <span class="s2">&quot;&#39;russellrao&#39;, &#39;seuclidean&#39;,&#39;sokalmichener&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;sokalsneath&#39;, &#39;sqeuclidean&#39;.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="n">iterations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of iterations must be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of samples must be specified.&#39;</span><span class="p">)</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Latin Hypercube sampling...&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">u_ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
            <span class="n">u_ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;maximin&#39;</span><span class="p">:</span>
            <span class="n">u_ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_min</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
            <span class="n">u_ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlate</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">u_ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: A valid criterion is required.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u_ab</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u_ab</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">u_ab</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of LHS design.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="LHS.random"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.random">[docs]</a>    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Latin hypercube design based on sampling randomly inside each bin.</span>

<span class="sd">        &gt;&gt;&gt; from UQpy.Distributions import Uniform</span>
<span class="sd">        &gt;&gt;&gt; from UQpy.SampleMethods import LHS</span>
<span class="sd">        &gt;&gt;&gt; dist1 = Uniform(loc=3., scale=2.)</span>
<span class="sd">        &gt;&gt;&gt; dist2 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        Run LHS with the ``random`` method:</span>
<span class="sd">        &gt;&gt;&gt; x = LHS(dist_object=[dist1, dist2], criterion=&#39;correlate&#39;, nsamples=5, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(x.samples)</span>
<span class="sd">        UQpy: Running Latin Hypercube sampling...</span>
<span class="sd">        UQpy: Achieved max_min distance of  0.44043282285181284</span>
<span class="sd">        Successful execution of LHS design.</span>
<span class="sd">        [[3.75621818 0.97949371]</span>
<span class="sd">         [4.85220593 0.37270871]</span>
<span class="sd">         [3.1521886  0.4610569 ]</span>
<span class="sd">         [4.41441601 0.10184899]</span>
<span class="sd">         [3.89444322 0.6775048 ]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="LHS.centered"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.centered">[docs]</a>    <span class="k">def</span> <span class="nf">centered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Latin hypercube design based on sampling the centers of the bins.</span>

<span class="sd">        &gt;&gt;&gt; from UQpy.Distributions import Uniform</span>
<span class="sd">        &gt;&gt;&gt; from UQpy.SampleMethods import LHS</span>
<span class="sd">        &gt;&gt;&gt; dist1 = Normal(loc=0., scale=1.)</span>
<span class="sd">        &gt;&gt;&gt; dist2 = Normal(loc=2., scale=1.)</span>
<span class="sd">        Run LHS with the ``centered`` method:</span>
<span class="sd">        &gt;&gt;&gt; x = LHS(dist_object=[dist1, dist2], criterion=&#39;correlate&#39;, nsamples=5, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(x.samples)</span>
<span class="sd">        UQpy: Running Latin Hypercube sampling...</span>
<span class="sd">        Successful execution of LHS design.</span>
<span class="sd">        [[-1.28155157  0.71844843]</span>
<span class="sd">         [ 0.52440051  2.52440051]</span>
<span class="sd">         [ 1.28155157  2.        ]</span>
<span class="sd">         [ 0.          3.28155157]</span>
<span class="sd">         [-0.52440051  1.47559949]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="LHS.max_min"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.max_min">[docs]</a>    <span class="k">def</span> <span class="nf">max_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Latin hypercube design based on maximizing the inter-site distances.</span>

<span class="sd">        &gt;&gt;&gt; from UQpy.Distributions import Uniform</span>
<span class="sd">        &gt;&gt;&gt; from UQpy.SampleMethods import LHS</span>
<span class="sd">        &gt;&gt;&gt; dist1 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        &gt;&gt;&gt; dist2 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        Run LHS with the ``max_min`` method:</span>
<span class="sd">        &gt;&gt;&gt; x = LHS(dist_object=[dist1, dist2], criterion=&#39;correlate&#39;, nsamples=5, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(x.samples)</span>
<span class="sd">        UQpy: Running Latin Hypercube sampling...</span>
<span class="sd">        UQpy: Achieved max_min distance of  0.44043282285181284</span>
<span class="sd">        Successful execution of LHS design.</span>
<span class="sd">        [[0.33874957 0.31460038]</span>
<span class="sd">         [0.91109051 0.44301033]</span>
<span class="sd">         [0.059657   0.77562892]</span>
<span class="sd">         [0.67762949 0.03327944]</span>
<span class="sd">         [0.59516606 0.90984061]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">max_min_dist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">samples_try</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">max_min_dist</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved maximum distance of &#39;</span><span class="p">,</span> <span class="n">max_min_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="LHS.correlate"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.correlate">[docs]</a>    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Latin hypercube design based on minimizing the pairwise correlations.</span>

<span class="sd">        &gt;&gt;&gt; from UQpy.Distributions import Uniform</span>
<span class="sd">        &gt;&gt;&gt; from UQpy.SampleMethods import LHS</span>
<span class="sd">        &gt;&gt;&gt; dist1 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        &gt;&gt;&gt; dist2 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        Run LHS with the ``correlate`` method:</span>
<span class="sd">        &gt;&gt;&gt; x = LHS(dist_object=[dist1, dist2], criterion=&#39;correlate&#39;, nsamples=5, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(x.samples)</span>
<span class="sd">        UQpy: Running Latin Hypercube sampling...</span>
<span class="sd">        UQpy: Achieved minimum correlation of  0.00019327853813977584</span>
<span class="sd">        Successful execution of LHS design.</span>
<span class="sd">        [[0.22585805 0.87167809]</span>
<span class="sd">         [0.12410009 0.0665815 ]</span>
<span class="sd">         [0.50548145 0.78194119]</span>
<span class="sd">         [0.903594   0.43153321]</span>
<span class="sd">         [0.73471617 0.35147028]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterations</span><span class="p">):</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples_try</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_corr</span><span class="p">:</span>
                <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved minimum correlation of &#39;</span><span class="p">,</span> <span class="n">min_corr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="LHS.transform_u01"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.LHS.transform_u01">[docs]</a>    <span class="k">def</span> <span class="nf">transform_u01</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``transform_u01`` method of the ``LHS`` is used to transform samples from the parameter space to the</span>
<span class="sd">        Uniform [0, 1] space. ``Distribution`` objects need to have a ``cdf`` method.</span>

<span class="sd">        &gt;&gt;&gt; from UQpy.Distributions import Uniform</span>
<span class="sd">        &gt;&gt;&gt; from UQpy.SampleMethods import LHS</span>
<span class="sd">        &gt;&gt;&gt; dist1 = Uniform(loc=0., scale=1.)</span>
<span class="sd">        &gt;&gt;&gt; dist2 = Normal(loc=2., scale=1.)</span>
<span class="sd">        Run LHS with the ``correlate`` method:</span>
<span class="sd">        &gt;&gt;&gt; x = LHS(dist_object=[dist1, dist2], criterion=&#39;centered&#39;, nsamples=5, verbose=True)</span>
<span class="sd">        &gt;&gt;&gt; print(x.samples)</span>
<span class="sd">        UQpy: Running Latin Hypercube sampling...</span>
<span class="sd">        Successful execution of LHS design.</span>
<span class="sd">        [[0.1        1.47559949]</span>
<span class="sd">         [0.3        2.52440051]</span>
<span class="sd">         [0.9        0.71844843]</span>
<span class="sd">         [0.5        2.        ]</span>
<span class="sd">         [0.7        3.28155157]]</span>

<span class="sd">         &gt;&gt;&gt; x.transform_u01()</span>
<span class="sd">         &gt;&gt;&gt; print(x.samplesU01)</span>
<span class="sd">         [[0.1        0.02871656]</span>
<span class="sd">         [0.3        0.04456546]</span>
<span class="sd">         [0.7        0.09680048]</span>
<span class="sd">         [0.5        0.0668072 ]</span>
<span class="sd">         [0.9        0.13566606]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Stratified Sampling  (STS)</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">STS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate samples from an assigned probability density function using Stratified Sampling.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. M.D. Shields, K. Teferra, A. Hapij, and R.P. Daddazio, &quot;Refined Stratified Sampling for efficient Monte</span>
<span class="sd">       Carlo based uncertainty quantification,&quot; Reliability Engineering and System Safety,vol.142, pp.310-325,2015.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param dimension: A scalar value defining the dimension of target density function.</span>
<span class="sd">                      Default: Length of sts_design.</span>
<span class="sd">    :type dimension: int</span>

<span class="sd">    :param dist_name: A list containing the names of the distributions of the random variables.</span>
<span class="sd">                      Distribution names must match those in the Distributions module.</span>
<span class="sd">                      If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                      provide custom_dist.py.</span>
<span class="sd">                      The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                      dimension.</span>
<span class="sd">    :type dist_name: string list</span>

<span class="sd">    :param dist_params: Parameters of the distribution</span>
<span class="sd">                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                        Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                        distribution, dist[i].</span>
<span class="sd">    :type dist_params: list</span>

<span class="sd">    param: distribution: An object list containing the distributions of the random variables.</span>
<span class="sd">                         Each item in the list is an object of the Distribution class (see Distributions.py).</span>
<span class="sd">                         The list has length equal to dimension.</span>
<span class="sd">    :type distribution: list</span>

<span class="sd">    :param sts_design: Specifies the number of strata in each dimension</span>
<span class="sd">    :type sts_design: int list</span>

<span class="sd">    :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                       Default: None.</span>
<span class="sd">    :type input_file: string</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :return: STS.samples: Set of stratified samples.</span>
<span class="sd">    :rtype: STS.samples: ndarray</span>

<span class="sd">    :return: STS.samplesU01: Set of uniform stratified samples on [0, 1]^dimension</span>
<span class="sd">    :rtype: STS.samplesU01: ndarray</span>

<span class="sd">    :return: STS.strata: Instance of the class SampleMethods.Strata</span>
<span class="sd">    :rtype: STS.strata: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Michael Shields</span>
<span class="sd">    Last modified: 6/7/2018 by Dimitris Giovanis &amp; Michael Shields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sts_design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sts_criterion</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="s1">&#39;Rectangular&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_iters</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">=</span> <span class="n">stype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="o">=</span> <span class="n">sts_design</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">=</span> <span class="n">sts_criterion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span> <span class="o">=</span> <span class="n">n_iters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_sts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_sts</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sts</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute stratified sampling</span>

<span class="sd">        This is an instance method that runs stratified sampling. It is automatically called when the STS class is</span>
<span class="sd">        instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">samples_u_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                                          <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;centered&quot;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>

                <span class="n">samples_u_to_x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Successful execution of STS design..&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">samples_u_to_x</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>

            <span class="n">samples_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iters</span><span class="p">):</span>
                <span class="c1"># x = self.in_hypercube(samples_init)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="n">samples_init</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="n">samples_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_points</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                               <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">in_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>

        <span class="n">in_cube</span> <span class="o">=</span> <span class="kc">True</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">in_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">in_cube</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">in_cube</span>

    <span class="k">def</span> <span class="nf">init_sts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>

        <span class="c1"># Check for dimensional consistency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Dimension must be specified.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_name</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of i_cdf should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Check dist_params</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Length of dist_params list should be 1 or equal to dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure that distribution parameters are assigned</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Distribution parameters not defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Stratum design is not defined.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">input_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;sts_design&#39;.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">Strata</span><span class="p">(</span><span class="n">n_strata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sts_design</span><span class="p">)</span>

        <span class="c1"># Check sampling criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported sts criteria: &#39;random&#39;, &#39;centered&#39;&quot;</span><span class="p">)</span>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Strata</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">Strata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a rectilinear stratification of the n-dimensional unit hypercube [0, 1]^dimension with N strata.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param n_strata: A list of dimension n defining the number of strata in each of the n dimensions</span>
<span class="sd">                    Creates an equal stratification with strata widths equal to 1/n_strata</span>
<span class="sd">                    The total number of strata, N, is the product of the terms of n_strata</span>
<span class="sd">                    Example -</span>
<span class="sd">                    n_strata = [2, 3, 2] creates a 3d stratification with:</span>
<span class="sd">                    2 strata in dimension 0 with stratum widths 1/2</span>
<span class="sd">                    3 strata in dimension 1 with stratum widths 1/3</span>
<span class="sd">                    2 strata in dimension 2 with stratum widths 1/2</span>
<span class="sd">    :type n_strata int list</span>

<span class="sd">    :param input_file: File path to input file specifying stratum origins and stratum widths.</span>
<span class="sd">                       Default: None</span>
<span class="sd">    :type input_file: string</span>

<span class="sd">    :param origins: An array of dimension N x n specifying the origins of all strata</span>
<span class="sd">                    The origins of the strata are the coordinates of the stratum orthotope nearest the global</span>
<span class="sd">                    origin.</span>
<span class="sd">                    Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                    origins = [[0, 0]</span>
<span class="sd">                              [0, 0.5]</span>
<span class="sd">                              [0.5, 0]</span>
<span class="sd">                              [0.5, 0.5]]</span>
<span class="sd">    :type origins: numpy array</span>

<span class="sd">    :param widths: An array of dimension N x n specifying the widths of all strata in each dimension</span>
<span class="sd">                   Example - A 2D stratification with 2 strata in each dimension</span>
<span class="sd">                   widths = [[0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]</span>
<span class="sd">                             [0.5, 0.5]]</span>
<span class="sd">    :type widths: numpy array</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param Strata.weights: An array of dimension 1 x N containing sample weights.</span>
<span class="sd">                    Sample weights are equal to the product of the strata widths (i.e. they are equal to the</span>
<span class="sd">                    size of the strata in the [0, 1]^n space.</span>
<span class="sd">    :type Strata.weights: numpy array</span>

<span class="sd">    **Author:**</span>

<span class="sd">    Michael D. Shields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="o">=</span> <span class="n">n_strata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">origins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span>

        <span class="c1"># Read a stratified design from an input file.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The strata are not fully defined. Must provide [n_strata], &#39;</span>
                             <span class="s1">&#39;input file, or [origins] and [widths].&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read the strata from the specified input file</span>
                <span class="c1"># See documentation for input file formatting</span>
                <span class="n">array_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>

                <span class="c1"># Check to see that the strata are space-filling</span>
                <span class="n">space_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is not space-filling.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Error: The stratum design is over-filling.&#39;</span><span class="p">)</span>

        <span class="c1"># Define a rectilinear stratification by specifying the number of strata in each dimension via nstrata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullfact</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origins</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_strata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fullfact</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a full-factorial design</span>

<span class="sd">        Note: This function has been modified from pyDOE, released under BSD License (3-Clause)</span>
<span class="sd">        Copyright (C) 2012 - 2013 - Michael Baudin</span>
<span class="sd">        Copyright (C) 2012 - Maria Christopoulou</span>
<span class="sd">        Copyright (C) 2010 - 2011 - INRIA - Michael Baudin</span>
<span class="sd">        Copyright (C) 2009 - Yann Collette</span>
<span class="sd">        Copyright (C) 2009 - CEA - Jean-Marc Martinez</span>
<span class="sd">        Original source code can be found at:</span>
<span class="sd">        https://pythonhosted.org/pyDOE/#</span>
<span class="sd">        or</span>
<span class="sd">        https://pypi.org/project/pyDOE/</span>
<span class="sd">        or</span>
<span class="sd">        https://github.com/tisimst/pyDOE/</span>

<span class="sd">        **Input:**</span>

<span class="sd">        :param levels: A list of integers that indicate the number of levels of each input design factor.</span>
<span class="sd">        :type levels: list</span>

<span class="sd">        **Output:**</span>

<span class="sd">        :return ff: Full-factorial design matrix.</span>
<span class="sd">        :rtype ff: ndarray</span>

<span class="sd">        **Author:**</span>

<span class="sd">        Michael D. Shields</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Number of factors</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="c1"># Number of combinations</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_comb</span><span class="p">,</span> <span class="n">n_factors</span><span class="p">))</span>

        <span class="n">level_repeat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">range_repeat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_factors</span><span class="p">):</span>
            <span class="n">range_repeat</span> <span class="o">//=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lvl</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">level_repeat</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">lvl</span> <span class="o">*</span> <span class="n">range_repeat</span>
            <span class="n">level_repeat</span> <span class="o">*=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ff</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="k">return</span> <span class="n">ff</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Refined Stratified Sampling (RSS)</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">RSS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate new samples using adaptive sampling methods, i.e. Refined Stratified Sampling and Gradient</span>
<span class="sd">    Enhanced Refined Stratified Sampling.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. Michael D. Shields, Kirubel Teferra, Adam Hapij and Raymond P. Daddazio, &quot;Refined Stratified Sampling for</span>
<span class="sd">       efficient Monte Carlo based uncertainty quantification&quot;, Reliability Engineering &amp; System Safety,</span>
<span class="sd">       ISSN: 0951-8320, Vol: 142, Page: 310-325, 2015.</span>
<span class="sd">    2. M. D. Shields, &quot;Adaptive Monte Carlo analysis for strongly nonlinear stochastic systems&quot;,</span>
<span class="sd">       Reliability Engineering &amp; System Safety, ISSN: 0951-8320, Vol: 175, Page: 207-224, 2018.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param run_model_object: A RunModel object, which is used to evaluate the function value</span>
<span class="sd">    :type run_model_object: class</span>

<span class="sd">    :param sample_object: A SampleMethods class object, which contains information about existing samples</span>
<span class="sd">    :type sample_object: class</span>

<span class="sd">    :param krig_object: A kriging class object, only  required if meta is &#39;Kriging&#39;.</span>
<span class="sd">    :type krig_object: class</span>

<span class="sd">    :param local: Indicator to update surrogate locally.</span>
<span class="sd">    :type local: boolean</span>

<span class="sd">    :param max_train_size: Minimum size of training data around new sample used to update surrogate.</span>
<span class="sd">                           Default: nsamples</span>
<span class="sd">    :type max_train_size: int</span>
<span class="sd">    :param step_size: Step size to calculate the gradient using central difference. Only required if Delaunay is</span>
<span class="sd">                      used as surrogate approximation.</span>
<span class="sd">    :type step_size: float</span>

<span class="sd">    :param n_add: Number of samples generated in each iteration</span>
<span class="sd">    :type n_add: int</span>

<span class="sd">    :param verbose: A boolean declaring whether to write text to the terminal.</span>
<span class="sd">    :type verbose: bool</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param: RSS.sample_object.samples: Final/expanded samples.</span>
<span class="sd">    :type: RSS.sample_object.samples: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Mohit S. Chauhan</span>
<span class="sd">    Last modified: 01/07/2020 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_model_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Initialize attributes that are common to all approaches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span> <span class="o">=</span> <span class="n">sample_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="o">=</span> <span class="n">run_model_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">stype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Run Initial Error Checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_rss</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="o">=</span> <span class="n">max_train_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - Running the initial sample set.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute refined stratified sampling.</span>

<span class="sd">        This is an instance method that runs refined stratified sampling. It is automatically called when the RSS class</span>
<span class="sd">        is instantiated.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param nsamples: Final size of the samples.</span>
<span class="sd">        :type nsamples: int</span>

<span class="sd">        :param n_add: Number of samples to generate with each iteration.</span>
<span class="sd">        :type n_add: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;UQpy Error: The number of requested samples must be larger than the existing &#39;</span>
                                      <span class="s1">&#39;sample set.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_gerss</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_rss</span><span class="p">()</span>

    <span class="c1">###################################################</span>
    <span class="c1"># Run Gradient-Enhanced Refined Stratified Sampling</span>
    <span class="c1">###################################################</span>
    <span class="k">def</span> <span class="nf">run_gerss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples are generated using Gradient Enhanced-Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --------------------------</span>
        <span class="c1"># RECTANGULAR STRATIFICATION</span>
        <span class="c1"># --------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing GE-RSS with rectangular stratification...&#39;</span><span class="p">)</span>

            <span class="c1"># Initialize the training points for the surrogate model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Initialize the vector of gradients at each training point</span>
            <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                        <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

                <span class="c1"># ---------------------------------------------------</span>
                <span class="c1"># Compute the gradients at the existing sample points</span>
                <span class="c1"># ---------------------------------------------------</span>

                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
                    <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">+</span>
                                                       <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">)</span>

                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                    <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">))</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># Recompute the gradient only at the nearest neighbor points.</span>
                    <span class="n">dy_dx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">+</span>
                                                                         <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span>
                                                                             <span class="n">neighbors</span><span class="p">]))</span>

                <span class="c1"># Define the gradient vector for application of the Delta Method</span>
                <span class="n">dy_dx1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># ------------------------------</span>
                <span class="c1"># Determine the stratum to break</span>
                <span class="c1"># ------------------------------</span>

                <span class="c1"># Estimate the variance within each stratum by assuming a uniform distribution over the stratum.</span>
                <span class="c1"># All input variables are independent</span>
                <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Estimate the variance over the stratum by Delta Method</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Break the &#39;p&#39; stratum with the maximum weight</span>
                <span class="n">bin2break</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">bin2break</span><span class="p">))</span>

                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Cut the stratum in the direction of maximum gradient</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dy_dx1</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">]))]</span>

                    <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">/</span><span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                    <span class="c1"># Add a uniform random sample inside the new stratum</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># Adding new sample to training points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Run the model at the new sample point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># ----------------------</span>
        <span class="c1"># VORONOI STRATIFICATION</span>
        <span class="c1"># ----------------------</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Delaunay_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>
            <span class="kn">from</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">import</span> <span class="n">Delaunay</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="ow">or</span> \
                    <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-10</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">])</span>

            <span class="c1"># Define the simplex mesh to be used for gradient estimation and sampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">furthest_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Defining attributes of Delaunay, so that pycharm can check that it exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">:</span> <span class="nb">classmethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>
            <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">compute_Delaunay_centroid_volume</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                        <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

                <span class="c1"># ---------------------------------------------------</span>
                <span class="c1"># Compute the gradients at the existing sample points</span>
                <span class="c1"># ---------------------------------------------------</span>

                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> \
                        <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">:</span>
                    <span class="n">dy_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">)</span>

                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># Build a mapping from the new vertex indices to the old vertex indices.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                    <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                    <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                    <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">))</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                               <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># For every simplex, check if at least dimension-1 vertices are in the neighbor set.</span>
                    <span class="c1"># Only update the gradient in simplices that meet this criterion.</span>
                    <span class="n">update_list</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">18</span>
                        <span class="n">v_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                        <span class="n">v_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_list</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">18</span><span class="p">)]))):</span>
                                <span class="n">update_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                    <span class="n">update_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">update_list</span><span class="p">)</span>

                    <span class="c1"># Initialize the gradient vector</span>
                    <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>

                    <span class="c1"># For those simplices that will not be updated, use the previous gradient</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dy_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dy_dx_old</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]</span>

                    <span class="c1"># For those simplices that will be updated, compute the new gradient</span>
                    <span class="n">dy_dx</span><span class="p">[</span><span class="n">update_array</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">update_array</span><span class="p">])</span>

                <span class="c1"># ----------------------------------------------------</span>
                <span class="c1"># Determine the simplex to break and draw a new sample</span>
                <span class="c1"># ----------------------------------------------------</span>

                <span class="c1"># Estimate the variance over each simplex by Delta Method. Moments of the simplices are computed using</span>
                <span class="c1"># Eq. (19) from the following reference:</span>
                <span class="c1"># Good, I.J. and Gaskins, R.A. (1971). The Centroid Method of Numerical Integration. Numerische</span>
                <span class="c1">#       Mathematik. 16: 343--359.</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]][:,</span> <span class="n">k</span><span class="p">])</span>
                        <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">/</span>
                                     <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="n">dy_dx</span>

                <span class="c1"># Identify the stratum with the maximum weight</span>
                <span class="n">bin2add</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

                <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum variance</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Create a sub-simplex within the simplex with maximum variance.</span>
                    <span class="n">tmp_vertices</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]]</span>
                    <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">)</span>  <span class="c1"># node: an array containing mid-point of edges</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

                    <span class="c1"># Using the Simplex class to generate a new sample in the sub-simplex</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

                <span class="c1"># Update the matrices to have recognize the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">p</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

                <span class="c1"># Update the Delaunay triangulation mesh to include the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

                <span class="c1"># Update the sample arrays to include the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Identify the new point in the parameter space and update the sample array to include the new point.</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Run the mode at the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">new_point</span><span class="p">)</span>

                <span class="c1"># Compute the strata weights.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1">#################################</span>
    <span class="c1"># Run Refined Stratified Sampling</span>
    <span class="c1">#################################</span>
    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples are generated using Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --------------------------</span>
        <span class="c1"># RECTANGULAR STRATIFICATION</span>
        <span class="c1"># --------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Rectangular&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing RSS with rectangular stratification...&#39;</span><span class="p">)</span>

            <span class="c1"># Initialize the training points for the surrogate model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>
                <span class="c1"># ------------------------------</span>
                <span class="c1"># Determine the stratum to break</span>
                <span class="c1"># ------------------------------</span>
                <span class="c1"># Estimate the weight corresponding to each stratum</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Break the &#39;p&#39; stratum with the maximum weight</span>
                <span class="n">bin2break</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
                <span class="n">bin2break</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">bin2break</span><span class="p">))</span>

                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="c1"># Cut the stratum in the direction of maximum length</span>
                    <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]</span>
                    <span class="n">dir2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:]])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dir2break</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">/</span><span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                    <span class="c1"># Add a uniform random sample inside the new stratum</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">origins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>

                <span class="c1"># Adding new sample to training points, samplesU01 and samples attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">i_cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># ----------------------</span>
        <span class="c1"># VORONOI STRATIFICATION</span>
        <span class="c1"># ----------------------</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="s1">&#39;Voronoi&#39;</span><span class="p">:</span>

            <span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">compute_Delaunay_centroid_volume</span><span class="p">,</span> <span class="n">voronoi_unit_hypercube</span>
            <span class="kn">from</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">import</span> <span class="n">Delaunay</span>
            <span class="kn">import</span> <span class="nn">math</span>
            <span class="kn">import</span> <span class="nn">itertools</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>

            <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="ow">or</span> \
                        <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="p">])</span>

            <span class="c1"># Define the simplex mesh to be used for sampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">furthest_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Defining attributes of Delaunay, so that pycharm can check that it exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">:</span> <span class="nb">classmethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span>
            <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

            <span class="c1"># Primary loop for adding samples and performing refinement.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nexist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

                <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">compute_Delaunay_centroid_volume</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                <span class="c1"># ----------------------------------------------------</span>
                <span class="c1"># Determine the simplex to break and draw a new sample</span>
                <span class="c1"># ----------------------------------------------------</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="c1"># Identify the stratum with the maximum weight</span>
                <span class="n">bin2add</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin2add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2add</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>

                <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum weight</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="n">tmp_vertices</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]]</span>
                    <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                        <span class="n">tmp_vertices</span><span class="p">)</span>  <span class="c1"># node: an array containing mid-point of edges</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

                    <span class="c1"># Using the Simplex class to generate a new sample in the sub-simplex</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

                <span class="c1"># Update the matrices to have recognize the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">p</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

                <span class="c1"># Update the Delaunay triangulation mesh to include the new point.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
                <span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>

                <span class="c1"># Update the sample arrays to include the new point</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Identify the new point in the parameter space and update the sample array to include the new point.</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                                              <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

                <span class="c1"># Compute the strata weights.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">compute_Voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># Support functions for RSS and GE-RSS</span>

    <span class="k">def</span> <span class="nf">estimate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimating gradients with a metamodel (surrogate).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param x: Samples in the training data.</span>
<span class="sd">        :type x: numpy array</span>

<span class="sd">        :param y: Function values evaluated at the samples in the training data.</span>
<span class="sd">        :type y: numpy array</span>

<span class="sd">        :param xt: Samples where gradients are computed.</span>
<span class="sd">        :type xt: numpy array</span>

<span class="sd">        **Outputs:**</span>
<span class="sd">        :return gr: First-order gradient evaluated at the points &#39;xt&#39;.</span>
<span class="sd">        :rtype gr: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">UQpy.Reliability</span> <span class="k">import</span> <span class="n">TaylorSeries</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Krig&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;GaussianProcessRegressor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">predict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">LinearNDInterpolator</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span>

        <span class="n">gr</span> <span class="o">=</span> <span class="n">TaylorSeries</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">xt</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">tck</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span>
                                   <span class="n">df_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gr</span>

    <span class="k">def</span> <span class="nf">init_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;STS&#39;</span><span class="p">,</span> <span class="s1">&#39;RSS&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: sample_object must be an object of the STS or RSS class.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RunModel&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: run_model_object must be an object of the RunModel class.&quot;</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                        Generating random samples inside a Simplex</span>
<span class="c1">########################################################################################################################</span>

<span class="k">class</span> <span class="nc">Simplex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random samples inside a simplex using uniform probability distribution.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. W. N. Edelinga, R. P. Dwightb, P. Cinnellaa, &quot;Simplex-stochastic collocation method with improved</span>
<span class="sd">       calability&quot;,Journal of Computational Physics, 310:301–328 2016.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param nodes: The vertices of the simplex</span>
<span class="sd">    :type nodes: ndarray</span>

<span class="sd">    :param nsamples: The number of samples to be generated inside the simplex</span>
<span class="sd">    :type nsamples: int</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :return Simplex.samples: New random samples distributed uniformly inside the simplex.</span>
<span class="sd">    :rtype Simplex.samples: ndarray</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Dimitris G.Giovanis</span>
<span class="sd">    Last modified: 11/28/2018 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Dimitris G.Giovanis</span>
    <span class="c1"># Last modified: 11/28/2018 by Mohit S. Chauhan</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_sis</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates uniformly distributed random samples inside the simplex.</span>

<span class="sd">        This is an instance method that generates samples. It is automatically called when the Simplex class is</span>
<span class="sd">        instantiated.</span>

<span class="sd">        **Output:**</span>

<span class="sd">        :return sample: Random samples</span>
<span class="sd">        :rtype sample: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dimension</span><span class="p">])</span>
                <span class="n">ad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">b_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                        <span class="n">ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="n">b_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="n">ad</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">b_</span><span class="p">))</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">init_sis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Number of samples to be generated &#39;nsamples&#39; should be a positive &quot;</span>
                                      <span class="s2">&quot;integer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Size of simplex (nodes) is not consistent.&quot;</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                  Adaptive Kriging-Monte Carlo Simulation (AK-MCS)</span>
<span class="c1">########################################################################################################################</span>
<span class="k">class</span> <span class="nc">AKMCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate new samples using different active learning method and properties of kriging surrogate along with</span>
<span class="sd">    MCS.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. B. Echard, N. Gayton and M. Lemaire, &quot;AK-MCS: An active learning reliability method combining Kriging and</span>
<span class="sd">        Monte Carlo Simulation&quot;, Structural Safety, Pages 145-154, 2011.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    :param run_model_object: A RunModel object, which is used to evaluate the function value</span>
<span class="sd">    :type run_model_object: class</span>

<span class="sd">    :param samples: A 2d-array of samples</span>
<span class="sd">    :type samples: ndarray</span>

<span class="sd">    :param krig_object: A kriging class object</span>
<span class="sd">    :type krig_object: class</span>

<span class="sd">    :param population: Sample which are used as learning set by AKMCS class.</span>
<span class="sd">    :type population: ndarray</span>

<span class="sd">    :param nlearn: Number of sample generated using MCS, which are used as learning set by AKMCS. Only required</span>
<span class="sd">                   if population is not defined.</span>
<span class="sd">    :type nlearn: int</span>

<span class="sd">    :param nstart: Number of initial samples generated using LHS. Only required if sample_object is not defined.</span>
<span class="sd">    :type nstart: int</span>

<span class="sd">    :param dist_name: A list containing the names of the distributions of the random variables. This is only</span>
<span class="sd">                      required if sample_object is not defined.</span>
<span class="sd">                      Distribution names must match those in the Distributions module.</span>
<span class="sd">                      If the distribution does not match one from the Distributions module, the user must</span>
<span class="sd">                      provide custom_dist.py.</span>
<span class="sd">                      The length of the string must be 1 (if all distributions are the same) or equal to</span>
<span class="sd">                      dimension.</span>
<span class="sd">    :type dist_name: string list</span>

<span class="sd">    :param dist_params: Parameters of the distribution</span>
<span class="sd">                        Parameters for each random variable are defined as ndarrays.</span>
<span class="sd">                        Each item in the list, dist_params[i], specifies the parameters for the corresponding</span>
<span class="sd">                        distribution, dist[i].</span>
<span class="sd">    :type dist_params: list</span>

<span class="sd">    :param lf: Learning function used as selection criteria to identify the new samples.</span>
<span class="sd">               Options: U, Weighted-U, EFF, EIF and EGIF</span>
<span class="sd">    :type lf: str/function</span>

<span class="sd">    :param n_add: Number of samples to be selected per iteration.</span>
<span class="sd">    :type n_add: int</span>

<span class="sd">    :param min_cov: Minimum Covariance used as the stopping criteria of AKMCS method in case of reliability</span>
<span class="sd">                    analysis.</span>
<span class="sd">    :type min_cov: float</span>

<span class="sd">    :param max_p: Maximum possible value of probability density function of samples. Only required with</span>
<span class="sd">                  &#39;Weighted-U&#39; learning function.</span>
<span class="sd">    :type max_p: float</span>

<span class="sd">    :param save_pf: Indicator to estimate probability of failure after each iteration. Only required if</span>
<span class="sd">                    user-defined learning function is used.</span>
<span class="sd">    :type save_pf: boolean</span>

<span class="sd">    :param verbose: A boolean declaring whether to write text to the terminal.</span>
<span class="sd">    :type verbose: bool</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    :param: AKMCS.sample_object.samples: Final/expanded samples.</span>
<span class="sd">    :type: AKMCS..sample_object.samples: ndarray</span>

<span class="sd">    :param: AKMCS.krig_model: Prediction function for the final surrogate model.</span>
<span class="sd">    :type: AKMCS.krig_model: function</span>

<span class="sd">    :param: AKMCS.pf: Probability of failure after every iteration of AKMCS. Available as an output only for</span>
<span class="sd">                       Reliability Analysis.</span>
<span class="sd">    :type: AKMCS.pf: float list</span>

<span class="sd">    :param: AKMCS.cov_pf: Covariance of probability of failure after every iteration of AKMCS. Available as an</span>
<span class="sd">                           output only for Reliability Analysis.</span>
<span class="sd">    :type: AKMCS.pf: float list</span>

<span class="sd">    **Authors:**</span>

<span class="sd">    Authors: Mohit S. Chauhan</span>
<span class="sd">    Last modified: 01/07/2020 by Mohit S. Chauhan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_model_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nlearn</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">nstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lf</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">min_cov</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">max_p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kriging</span><span class="o">=</span><span class="s1">&#39;UQpy&#39;</span><span class="p">,</span> <span class="n">save_pf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Initialize the internal variables of the class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="o">=</span> <span class="n">run_model_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span> <span class="o">=</span> <span class="n">nlearn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cov</span> <span class="o">=</span> <span class="n">min_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">=</span> <span class="n">max_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span> <span class="o">=</span> <span class="n">dist_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span> <span class="o">=</span> <span class="n">dist_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">population</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">=</span> <span class="n">kriging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="n">save_pf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize and run preliminary error checks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_akmcs</span><span class="p">()</span>

        <span class="c1"># Run AKMCS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_akmcs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes Adaptive Kriging - Monte Carlo Method.</span>

<span class="sd">        This is an instance method that check initial sample design an evaluate model at the training points. It is</span>
<span class="sd">        automatically called when the STS class is instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the initial sample design does not exists, run the initial calculations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Generating the initial sample set using Latin hypercube sampling.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nstart</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Running the initial sample set using RunModel.&#39;</span><span class="p">)</span>

        <span class="c1"># Evaluate model at the training points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterative procedure is applied to learn samples based on metamodel and learning function, and then metamodel is</span>
<span class="sd">        updated based on new samples.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param samples: A 2d-array of samples</span>
<span class="sd">        :type samples: ndarray</span>

<span class="sd">        :param n_add: Number of samples to be selected per iteration.</span>
<span class="sd">        :type n_add: int</span>

<span class="sd">        :param append_samples: If &#39;True&#39;, new samples are append to existing samples in sample_object. Otherwise,</span>
<span class="sd">                               existing samples are discarded.</span>
<span class="sd">        :type append_samples: boolean</span>

<span class="sd">        :param nsamples: Number of samples to generate. No Default Value: nsamples must be prescribed.</span>
<span class="sd">        :type nsamples: int</span>

<span class="sd">        :param lf: Learning function used as selection criteria to identify the new samples. Only required, if</span>
<span class="sd">                   samples are generated using multiple criterion</span>
<span class="sd">                   Options: U, Weighted-U, EFF, EIF and EGIF</span>
<span class="sd">        :type lf: str/function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">!=</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">if</span> <span class="n">n_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="k">if</span> <span class="n">lf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># New samples are appended to existing samples, if append_samples is TRUE</span>
            <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Running the provided sample set using RunModel.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="n">append_samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing AK-MCS design...&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the population of samples at which to evaluate the learning function and from which to draw in the</span>
        <span class="c1"># sampling.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="n">MCS</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">dist_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">,</span>
                                  <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span><span class="p">)</span>

        <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

        <span class="c1"># Train the initial Kriging model.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>  <span class="c1"># disable printing output comments</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">interpolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

        <span class="c1"># ---------------------------------------------</span>
        <span class="c1"># Primary loop for learning and adding samples.</span>
        <span class="c1"># ---------------------------------------------</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
            <span class="c1"># Find all of the points in the population that have not already been integrated into the training set</span>
            <span class="n">rest_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

            <span class="c1"># Apply the learning function to identify the new point to run the model.</span>

            <span class="n">new_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">)</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">[</span><span class="n">new_ind</span><span class="p">])</span>

            <span class="c1"># Add the new points to the training set and to the sample set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

            <span class="c1"># Run the model at the new points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">))</span>

            <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span><span class="o">.</span><span class="n">qoi_list</span>

            <span class="c1"># Retrain the Kriging surrogate model</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">suppress_stdout</span><span class="p">():</span>
                    <span class="c1"># disable printing output comments</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">interpolate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="k">import</span> <span class="n">GaussianProcessRegressor</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="p">,</span> <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">rest_pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">n_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
                <span class="n">pf</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pf</span> <span class="o">*</span> <span class="n">n_</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS complete&#39;</span><span class="p">)</span>

    <span class="c1"># ------------------</span>
    <span class="c1"># LEARNING FUNCTIONS</span>
    <span class="c1"># ------------------</span>
    <span class="k">def</span> <span class="nf">eigf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Improvement for Global Fit (EIGF) as learning function</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. J.N Fuhg, &quot;Adaptive surrogate models for parametric studies&quot;, Master&#39;s Thesis</span>
<span class="sd">           (Link: https://arxiv.org/pdf/1905.05345.pdf)</span>

<span class="sd">        **Inputs:**</span>
<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="c1"># Evaluation of the learning function</span>
        <span class="c1"># First, find the nearest neighbor in the training set for each point in the population.</span>
        <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">))</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">qoi_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])</span>

        <span class="c1"># Compute the learning function at every point in the population.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">qoi_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on U-function as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. B. Echard, N. Gayton and M. Lemaire, &quot;AK-MCS: An active learning reliability method combining Kriging and</span>
<span class="sd">        Monte Carlo Simulation&quot;, Structural Safety, Pages 145-154, 2011.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">weighted_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Probability Weighted U-function as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. V.S. Sundar and M.S. Shields, &quot;RELIABILITY ANALYSIS USING ADAPTIVE KRIGING SURROGATES WITH MULTIMODEL</span>
<span class="sd">           INFERENCE&quot;.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">p2</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">p1</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">distribution</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">p2</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_params</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_p</span><span class="p">)</span>
        <span class="c1"># u_ = u * p1/max(p1)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Feasibilty Function (EFF) as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. B.J. Bichon, M.S. Eldred, L.P.Swiler, S. Mahadevan, J.M. McFarland, &quot;Efficient Global Reliability Analysis</span>
<span class="sd">           for Nonlinear Implicit Performance Functions&quot;, AIAA JOURNAL, Volume 46, 2008.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="c1"># Reliability threshold: a_ = 0</span>
        <span class="c1"># EGRA method: epshilon = 2*sigma(x)</span>
        <span class="n">a_</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sig</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">+</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">eff</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">a_</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="o">-</span><span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="n">ep</span> <span class="o">*</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">:]</span>

        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">n_</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">pf</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">iin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">iin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pf</span> <span class="o">*</span> <span class="n">n_</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="c1"># This learning function has not yet been tested.</span>
    <span class="k">def</span> <span class="nf">eif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Learns new samples based on Expected Improvement Function (EIF) as learning function.</span>

<span class="sd">        **References:**</span>

<span class="sd">        1. D.R. Jones, M. Schonlau, W.J. Welch, &quot;Efficient Global Optimization of Expensive Black-Box Functions&quot;,</span>
<span class="sd">           Journal of Global Optimization, Pages 455–492, 1998.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        :param pop: Remaining sample population (new samples are learn from this population)</span>
<span class="sd">        :type pop: numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kriging</span> <span class="o">==</span> <span class="s1">&#39;UQpy&#39;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">sig</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="n">fm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">+</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">rows</span>

    <span class="k">def</span> <span class="nf">learning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines the leaning function used to generate new samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">,</span> <span class="s1">&#39;EIF&#39;</span><span class="p">,</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: The provided learning function is not recognized.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;EIF&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eif</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">==</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff</span>

    <span class="k">def</span> <span class="nf">init_akmcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preliminary error checks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_model_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS requires a predefined RunModel object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save_pf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">learning</span><span class="p">()</span>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Markov Chain Monte Carlo</span>
<span class="c1">########################################################################################################################</span>


<span class="k">class</span> <span class="nc">MCMC_old</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Description:</span>
<span class="sd">            Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo.</span>
<span class="sd">            This class generates samples using Metropolis-Hastings(MH), Modified Metropolis-Hastings,</span>
<span class="sd">            or Affine Invariant Ensemble Sampler with stretch moves.</span>
<span class="sd">            References:</span>
<span class="sd">            S.-K. Au and J. L. Beck,“Estimation of small failure probabilities in high dimensions by subset simulation,”</span>
<span class="sd">                Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263–277, Oct. 2001.</span>
<span class="sd">            J. Goodman and J. Weare, “Ensemble samplers with affine invariance,” Commun. Appl. Math. Comput. Sci.,vol.5,</span>
<span class="sd">                no. 1, pp. 65–80, 2010.</span>
<span class="sd">        Input:</span>
<span class="sd">            :param dimension: A scalar value defining the dimension of target density function.</span>
<span class="sd">                              Default: 1</span>
<span class="sd">            :type dimension: int</span>
<span class="sd">            :param pdf_proposal_type: Type of proposal density function for MCMC. Only used with algorithm =&#39;MH&#39; or&#39;MMH&#39;</span>
<span class="sd">                            Options:</span>
<span class="sd">                                    &#39;Normal&#39; : Normal proposal density.</span>
<span class="sd">                                    &#39;Uniform&#39; : Uniform proposal density.</span>
<span class="sd">                            Default: &#39;Uniform&#39;</span>
<span class="sd">                            If dimension &gt; 1 and algorithm = &#39;MMH&#39;, this may be input as a list to assign different</span>
<span class="sd">                            proposal densities to each dimension. Example pdf_proposal_name = [&#39;Normal&#39;,&#39;Uniform&#39;].</span>
<span class="sd">                            If dimension &gt; 1, algorithm = &#39;MMH&#39; and this is input as a string, the proposal densities</span>
<span class="sd">                            for all dimensions are set equal to the assigned proposal type.</span>
<span class="sd">            :type pdf_proposal_type: str or str list</span>
<span class="sd">            :param pdf_proposal_scale: Scale of the proposal distribution</span>
<span class="sd">                            If algorithm == &#39;MH&#39; or &#39;MMH&#39;</span>
<span class="sd">                                For pdf_proposal_type = &#39;Uniform&#39;</span>
<span class="sd">                                    Proposal is Uniform in [x-pdf_proposal_scale/2, x+pdf_proposal_scale/2].</span>
<span class="sd">                                For pdf_proposal_type = &#39;Normal&#39;</span>
<span class="sd">                                    Proposal is Normal with standard deviation equal to pdf_proposal_scale.</span>
<span class="sd">                            If algorithm == &#39;Stretch&#39;</span>
<span class="sd">                                pdf_proposal_scale sets the scale of the stretch density.</span>
<span class="sd">                                    g(z) = 1/sqrt(z) for z in [1/pdf_proposal_scale, pdf_proposal_scale].</span>
<span class="sd">                            Default value: dimension x 1 list of ones.</span>
<span class="sd">            :type pdf_proposal_scale: float or float list</span>
<span class="sd">                            If dimension &gt; 1, this may be defined as float or float list.</span>
<span class="sd">                                If input as float, pdf_proposal_scale is assigned to all dimensions.</span>
<span class="sd">                                If input as float list, each element is assigned to the corresponding dimension.</span>
<span class="sd">            :param pdf_target: Target density function from which to draw random samples</span>
<span class="sd">                            The target joint probability density must be a function, or list of functions, or a string.</span>
<span class="sd">                            If type == &#39;str&#39;</span>
<span class="sd">                                The assigned string must refer to a custom pdf defined in the file custom_pdf.py in the</span>
<span class="sd">                                 working directory.</span>
<span class="sd">                            If type == function</span>
<span class="sd">                                The function must be defined in the python script calling MCMC.</span>
<span class="sd">                            If dimension &gt; 1 and pdf_target_type=&#39;marginal_pdf&#39;, the input to pdf_target is a list of</span>
<span class="sd">                            size [dimensions x 1] where each item of the list defines a marginal pdf.</span>
<span class="sd">                            Default: Multivariate normal distribution having zero mean and unit standard deviation.</span>
<span class="sd">            :type pdf_target: function, function list, or str</span>
<span class="sd">            :param pdf_target_params: Parameters of the target pdf.</span>
<span class="sd">            :type pdf_target_params: list</span>
<span class="sd">            :param algorithm:  Algorithm used to generate random samples.</span>
<span class="sd">                            Options:</span>
<span class="sd">                                &#39;MH&#39;: Metropolis Hastings Algorithm</span>
<span class="sd">                                &#39;MMH&#39;: Component-wise Modified Metropolis Hastings Algorithm</span>
<span class="sd">                                &#39;Stretch&#39;: Affine Invariant Ensemble MCMC with stretch moves</span>
<span class="sd">                            Default: &#39;MMH&#39;</span>
<span class="sd">            :type algorithm: str</span>
<span class="sd">            :param jump: Number of samples between accepted states of the Markov chain.</span>
<span class="sd">                                Default value: 1 (Accepts every state)</span>
<span class="sd">            :type: jump: int</span>
<span class="sd">            :param nsamples: Number of samples to generate</span>
<span class="sd">                                No Default Value: nsamples must be prescribed</span>
<span class="sd">            :type nsamples: int</span>
<span class="sd">            :param seed: Seed of the Markov chain(s)</span>
<span class="sd">                            For &#39;MH&#39; and &#39;MMH&#39;, this is a single point, defined as a numpy array of dimension</span>
<span class="sd">                             (1 x dimension).</span>
<span class="sd">                            For &#39;Stretch&#39;, this is a numpy array of dimension N x dimension, where N is the ensemble</span>
<span class="sd">                            size.</span>
<span class="sd">                            Default:</span>
<span class="sd">                                For &#39;MH&#39; and &#39;MMH&#39;: zeros(1 x dimension)</span>
<span class="sd">                                For &#39;Stretch&#39;: No default, this must be specified.</span>
<span class="sd">            :type seed: float or numpy array</span>
<span class="sd">            :param nburn: Length of burn-in. Number of samples at the beginning of the chain to discard.</span>
<span class="sd">                            This option is only used for the &#39;MMH&#39; and &#39;MH&#39; algorithms.</span>
<span class="sd">                            Default: nburn = 0</span>
<span class="sd">            :type nburn: int</span>
<span class="sd">        Output:</span>
<span class="sd">            :return: MCMC.samples: Set of MCMC samples following the target distribution</span>
<span class="sd">            :rtype: MCMC.samples: ndarray</span>

<span class="sd">            :return: MCMC.accept_ratio: Acceptance ratio of the MCMC samples</span>
<span class="sd">            :rtype: MCMC.accept_ratio: float</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Authors: Michael D. Shields, Mohit Chauhan, Dimitris G. Giovanis</span>
    <span class="c1"># Updated: 04/08/2019 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_proposal_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_proposal_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_copula</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pdf_target_copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target_type</span><span class="o">=</span><span class="s1">&#39;joint_pdf&#39;</span><span class="p">,</span>
                 <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;MH&#39;</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="n">pdf_proposal_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="n">pdf_proposal_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="o">=</span> <span class="n">pdf_target_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span> <span class="o">=</span> <span class="n">pdf_target_copula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="o">=</span> <span class="n">pdf_target_copula_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">=</span> <span class="n">nburn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">=</span> <span class="n">pdf_target_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_mcmc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">accept_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n_accepts</span><span class="p">,</span> <span class="n">accept_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1"># Defining an array to store the generated samples</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Classical Metropolis-Hastings Algorithm with symmetric proposal density</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MH&#39;</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>
            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

            <span class="c1"># Loop over the samples</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                    <span class="n">cholesky_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span>
                    <span class="n">z_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cholesky_cov</span><span class="p">,</span> <span class="n">z_normal</span><span class="p">)</span>
                    <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                    <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                        <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
                    <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                    <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                        <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                        <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Modified Metropolis-Hastings Algorithm with symmetric proposal density</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MMH&#39;</span><span class="p">:</span>

            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">:</span>
                <span class="n">list_log_p_current</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">list_log_p_current</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>

                        <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                                <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                                <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                          <span class="n">high</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                                <span class="n">list_log_p_current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                                <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">):</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Normal&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Uniform&#39;</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                             <span class="n">high</span><span class="o">=</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                             <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                        <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                        <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                        <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                            <span class="n">current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_p_candidate</span>
                            <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">candidate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Affine Invariant Ensemble Sampler with stretch moves</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>

            <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span>
            <span class="n">log_pdf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span>
            <span class="c1"># list_log_p_current = [log_pdf_(samples[i, :], self.pdf_target_params) for i in range(self.ensemble_size)]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">complementary_ensemble</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">s0</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">complementary_ensemble</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">s0</span><span class="p">)</span>

                <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">log_p_current</span> <span class="o">=</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># log_p_current = list_log_p_current[i - self.ensemble_size + 1]</span>
                <span class="n">log_p_accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">log_p_current</span>

                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_accept</span>

                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
                    <span class="c1"># list_log_p_current.append(log_p_candidate)</span>
                    <span class="n">n_accepts</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># list_log_p_current.append(list_log_p_current[i - self.ensemble_size + 1])</span>
            <span class="n">accept_ratio</span> <span class="o">=</span> <span class="n">n_accepts</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">)</span>

        <span class="c1">################################################################################################################</span>
        <span class="c1"># Return the samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MMH&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MH&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of the MCMC design&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">],</span> <span class="n">accept_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble_size</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">accept_ratio</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Check to ensure consistency of the user input and assign defaults</span>
    <span class="k">def</span> <span class="nf">init_mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Check dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Check nsamples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Exit code: Number of samples not defined.&#39;</span><span class="p">)</span>

        <span class="c1"># Check nburn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check jump</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Exit code: Value of jump must be greater than 0&quot;</span><span class="p">)</span>

        <span class="c1"># Check seed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;seed&#39;.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For Stretch algorithm, a seed must be given as a ndarray&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;seed&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Ensemble size must be &gt; 2.&quot;</span><span class="p">)</span>

        <span class="c1"># Check algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;MH&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;MH&#39;</span><span class="p">,</span> <span class="s1">&#39;MMH&#39;</span><span class="p">,</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Exit code: Unrecognized MCMC algorithm. Supported algorithms: &#39;</span>
                                      <span class="s1">&#39;Metropolis-Hastings (MH), &#39;</span>
                                      <span class="s1">&#39;Modified Metropolis-Hastings (MMH), &#39;</span>
                                      <span class="s1">&#39;Affine Invariant Ensemble with Stretch Moves (Stretch).&#39;</span><span class="p">)</span>

        <span class="c1"># Check pdf_proposal_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="s1">&#39;Normal&#39;</span>
        <span class="c1"># If pdf_proposal_type is entered as a string, make it a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;Normal&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: Unrecognized type for proposal distribution. Supported distributions: &#39;</span>
                                 <span class="s1">&#39;Uniform, &#39;</span>
                                 <span class="s1">&#39;Normal.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MH&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: MH algorithm can only take one proposal distribution.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_type</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;pdf_proposal_type&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Check pdf_proposal_scale</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;Stretch&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_proposal_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Incompatible dimensions in &#39;pdf_proposal_scale&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Check log_pdf_target and pdf_target</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: a target function must be provided, in log_pdf_target of pdf_target&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: inconsistent dimensions.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: inconsistent dimensions.&#39;</span><span class="p">)</span>

        <span class="c1"># Check pdf_target_type</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;joint_pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_type should be &quot;joint_pdf&quot;, &quot;marginal_pdf&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Check MMH</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="ow">is</span> <span class="s1">&#39;MMH&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy error: MMH with pdf_target_type=&quot;marginal&quot; cannot be used when the&#39;</span>
                                 <span class="s1">&#39;target pdf has a copula, use pdf_target_type=&quot;joint&quot; instead&#39;</span><span class="p">)</span>

        <span class="c1"># If pdf_target or log_pdf_target are given as lists, they should be of the right dimension</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a list should have length equal to dimension&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_params should be given as a list of length equal to log_pdf_target&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a list should have length equal to dimension&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target_params should be given as a list of length equal to pdf_target&#39;</span><span class="p">)</span>

        <span class="c1"># Define a helper function</span>
        <span class="k">def</span> <span class="nf">compute_log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf_func</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copula_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">kwargs_</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">if</span> <span class="n">copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs_</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copula_params</span>
            <span class="n">pdf_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pdf_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pdf_value</span><span class="p">)</span>

        <span class="c1"># Either pdf_target or log_pdf_target must be defined</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The target distribution must be defined, using inputs&#39;</span>
                             <span class="s1">&#39; log_pdf_target or pdf_target.&#39;</span><span class="p">)</span>
        <span class="c1"># For MMH with pdf_target_type == &#39;marginals&#39;, pdf_target or its log should be lists</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;MMH&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_type</span> <span class="o">==</span> <span class="s1">&#39;marginal_pdf&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[{}]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MMH algo with pdf_target_type=&quot;marginal_pdf&quot;, &#39;</span>
                                     <span class="s1">&#39;log_pdf_target should be a list&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">p_js</span> <span class="o">=</span> <span class="p">[</span><span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdf_target_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">p_j</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">p_j</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a list of strings must point to Distributions &#39;</span>
                                             <span class="s1">&#39;with an existing log_pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">pdf_target_j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pdf_target_j</span><span class="p">)</span>
                                           <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target must be a list of strings or a list of callables&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MMH algo with pdf_target_type=&quot;marginal_pdf&quot;, &#39;</span>
                                     <span class="s1">&#39;pdf_target should be a list&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">p_js</span> <span class="o">=</span> <span class="p">[</span><span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdf_target_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">[</span><span class="n">p_j</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">p_j</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                               <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">p_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_js</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a list of strings must point to Distributions &#39;</span>
                                             <span class="s1">&#39;with an existing pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="p">[</span><span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">pdf_target_j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                           <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pdf_target_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pdf_target must be a list of strings or a list of callables&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;copula_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula_params</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                                                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target given as a string must point to a Distribution &#39;</span>
                                             <span class="s1">&#39;with an existing log_pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MH and Stretch, log_pdf_target must be a callable function, &#39;</span>
                                     <span class="s1">&#39;a str or list of str&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                                                        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">dist_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">copula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target_copula</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">pdf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;pdf_target given as a string must point to a Distribution &#39;</span>
                                             <span class="s1">&#39;with an existing pdf method.&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compute_log_pdf</span><span class="p">,</span> <span class="n">pdf_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For MH and Stretch, pdf_target must be a callable function, &#39;</span>
                                     <span class="s1">&#39;a str or list of str&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="MCMC"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC">[docs]</a><span class="k">class</span> <span class="nc">MCMC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo</span>
<span class="sd">    ([1]_, [2]_).</span>

<span class="sd">    This is the parent class to all MCMC algorithms.</span>

<span class="sd">    **References:**</span>

<span class="sd">    .. [1] Gelman et al., &quot;Bayesian data analysis&quot;, Chapman and Hall/CRC, 2013</span>
<span class="sd">    .. [2] R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **dimension** (`int`):</span>
<span class="sd">        A scalar value defining the dimension of target density function. Either dimension or seed must be provided.</span>

<span class="sd">    * **pdf_target** ((`list` of) callables):</span>
<span class="sd">        Target density function from which to draw random samples. Either `pdf_target` or `log_pdf_target` must be</span>
<span class="sd">        provided (the latter should be preferred).</span>

<span class="sd">    * **log_pdf_target** ((`list` of) callables):</span>
<span class="sd">        Logarithm of the target density function from which to draw random samples. Either `pdf_target` or</span>
<span class="sd">        `log_pdf_target` must be provided (the latter should be preferred).</span>

<span class="sd">    * **args_target** (`tuple`):</span>
<span class="sd">        Positional arguments of the pdf / log-pdf target function.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to generate. If not None, the `run` method is called when the object is created.</span>

<span class="sd">    * **nsamples_per_chain** (`int`):</span>
<span class="sd">        Number of samples to generate per chain. If not None, the `run` method is called when the object is created.</span>

<span class="sd">    * **jump** (`int`):</span>
<span class="sd">        Thinning parameter - only one out of jump samples are stored, used to reduce correlation between samples.</span>
<span class="sd">        Default is 1 (no thinning).</span>

<span class="sd">    * **nburn** (`int`):</span>
<span class="sd">        Length of burn-in - i.e., number of samples at the beginning of the chain to discard (note: no thinning during</span>
<span class="sd">        burn-in). Default is 0, no burn-in.</span>

<span class="sd">    * **seed** (`ndarray`):</span>
<span class="sd">        Seed of the Markov chain(s), shape ``(nchains, dimension)``. Default: zeros(1 x dimension).</span>

<span class="sd">    * **save_log_pdf** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to save log-pdf values along with the samples. Default: False</span>

<span class="sd">    * **concat_chains** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to concatenate the chains after a run, i.e., samples are stored as an `ndarray`</span>
<span class="sd">        of shape (nsamples * nchains, dimension) if True, (nsamples, nchains, dimension) if False. Default: True</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`)</span>
<span class="sd">        Set of MCMC samples following the target distribution, `ndarray` of shape (nsamples * nchains, dimension) or</span>
<span class="sd">        (nsamples, nchains, dimension) (see input `concat_chains`).</span>

<span class="sd">    * **log_pdf_values** (`ndarray`)</span>
<span class="sd">        Values of the log pdf for the accepted samples, `ndarray` of shape (nchains * nsamples,) or (nsamples, nchains)</span>

<span class="sd">    * **nsamples** (`list`)</span>
<span class="sd">        Total number of samples; it is updated during iterations as new samples as saved.</span>

<span class="sd">    * **nsamples_per_chain** (`list`)</span>
<span class="sd">        Total number of samples per chain; it is updated during iterations as new samples as saved.</span>

<span class="sd">    * **niterations** (`list`)</span>
<span class="sd">        Total number of iterations, updated on-the-fly as the algorithm proceeds. It is related to number of samples as</span>
<span class="sd">        niterations=nburn+jump*nsamples_per_chain.</span>

<span class="sd">    * **acceptance_rate** (`list`)</span>
<span class="sd">        Acceptance ratio of the MCMC chains, computed separately for each chain.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/20 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nburn</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nburn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nburn should be an integer &gt;= 0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">jump</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jump</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: jump should be an integer &gt;= 1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>    <span class="c1"># check type and assign default [0.s]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check target pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span>
            <span class="n">pdf</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span> <span class="o">=</span> <span class="n">save_log_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span> <span class="o">=</span> <span class="n">concat_chains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="c1">##### ADDED MDS 1/21/20</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_target</span> <span class="o">=</span> <span class="n">args_target</span>

        <span class="c1"># Initialize a few more variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total nb of iterations, grows if you call run several times</span>

<div class="viewcode-block" id="MCMC.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the MCMC chain.</span>

<span class="sd">        This function samples from the MCMC chains and append samples to existing ones (if any). This method calls the</span>
<span class="sd">        run_iterations method that is specific to each algorithm.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to generate.</span>

<span class="sd">        * **nsamples_per_chain** (`int`)</span>
<span class="sd">            Number of samples to generate per chain.</span>

<span class="sd">        Either nsamples or nsamples_per_chain must be provided (not both). Not that if nsamples is not a multiple of</span>
<span class="sd">        nchains, nsamples is set to the next integer that is a multiple of nchains.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the runs: allocate space for the new samples and log pdf values</span>
        <span class="n">final_nsamples</span><span class="p">,</span> <span class="n">final_nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_samples</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running MCMC...&#39;</span><span class="p">)</span>

        <span class="c1"># Run nsims iterations of the MCMC algorithm, starting at current_state</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">&lt;</span> <span class="n">final_nsamples_per_chain</span><span class="p">:</span>
            <span class="c1"># update the total number of iterations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># run iteration</span>
            <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_one_iteration</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)</span>
            <span class="c1"># Update the chain, only if burn-in is over and the sample is not being jumped over</span>
            <span class="c1"># also increase the current number of samples and samples_per_chain</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: MCMC run successfully !&#39;</span><span class="p">)</span>

        <span class="c1"># Concatenate chains maybe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate_chains</span><span class="p">()</span></div>

<div class="viewcode-block" id="MCMC.run_one_iteration"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MCMC.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC algorithm, starting at current_state.</span>

<span class="sd">        This method is over-written for each different MCMC algorithm. It must return the new state and associated</span>
<span class="sd">        log-pdf, which will be passed as inputs to the `run_one_iteration` method at the next iteration.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **current_state** (`ndarray`):</span>
<span class="sd">            Current state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **current_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the current state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        **Outputs/Returns:**</span>

<span class="sd">        * **new_state** (`ndarray`):</span>
<span class="sd">            New state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **new_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the new state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Helper functions that can be used by all algorithms</span>
    <span class="c1"># Methods update_samples, update_accept_ratio and sample_candidate_from_proposal can be called in the run stage.</span>
    <span class="c1"># Methods preprocess_target, preprocess_proposal, check_seed and check_integers can be called in the init stage.</span>

    <span class="k">def</span> <span class="nf">_concatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples, nchains, dimension) to</span>
<span class="sd">        (nsamples * nchains, dimension), and log_pdf_values from (nsamples, nchains) to (nsamples * nchains, ).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_unconcatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of concatenate_chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples * nchains, dimension) to</span>
<span class="sd">        (nsamples, nchains, dimension), and log_pdf_values from (nsamples * nchains) to (nsamples, nchains).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize necessary attributes and variables before running the chain forward.</span>

<span class="sd">        Utility function that allocates space for samples and log likelihood values, initialize sample_index,</span>
<span class="sd">        acceptance ratio. If some samples already exist, allocate space to append new samples to the old ones. Computes</span>
<span class="sd">        the number of forward iterations nsims to be run (depending on burnin and jump parameters).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * nchains (int): number of chains run in parallel</span>
<span class="sd">        * nsamples (int): number of samples to be generated</span>
<span class="sd">        * nsamples_per_chain (int): number of samples to be generated per chain</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * nsims (int): Number of iterations to perform</span>
<span class="sd">        * current_state (ndarray of shape (nchains, dim)): Current state of the chain to start from.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either nsamples or nsamples_per_chain must be provided (not both)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples_per_chain must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># very first call of run, set current_state as the seed and initialize self.samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1"># if nburn is 0, save the seed, run one iteration less </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>
                <span class="c1">#nsims = self.jump * nsamples_per_chain - 1</span>
            <span class="c1">#else:</span>
                <span class="c1">#nsims = self.nburn + self.jump * nsamples_per_chain</span>

        <span class="k">else</span><span class="p">:</span>    <span class="c1"># fetch previous samples to start the new run, current state is last saved sample</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>   <span class="c1"># the chains were previously concatenated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenate_chains</span><span class="p">()</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#nsims = self.jump * nsamples_per_chain</span>
        <span class="k">return</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span>

    <span class="k">def</span> <span class="nf">_update_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_accept</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update acceptance rate of the chains.</span>

<span class="sd">        Utility function, uses an iterative function to update the acceptance rate of all the chains separately.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * new_accept (list (length nchains) of bool): indicates whether the current state was accepted (for each chain</span>
<span class="sd">          separately).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="n">na</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">*</span> <span class="n">a</span>
                                <span class="k">for</span> <span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_accept</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x. If the target is given as a list of callables (marginal pdfs), the list of</span>
<span class="sd">        log margianals is also returned.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided.</span>
<span class="sd">        * pdf ((list of) callables): Target density function from which to draw random samples. Either pdf_target or</span>
<span class="sd">          log_pdf_target must be provided.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>
<span class="sd">        * evaluate_log_pdf_marginals (list of callables): List of callables to compute the log pdf of the marginals</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">log_pdf</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When log_pdf_target is a list, args should be a list (of tuples) of same &#39;</span>
                                     <span class="s1">&#39;length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))))</span>
                <span class="c1">#evaluate_log_pdf_marginals = [partial(log_pdf_, *args_) for (log_pdf_, args_) in zip(log_pdf, args)]</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">log_pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pdf</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When pdf_target is given as a list, args should also be a list of same length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                              <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))),</span>
                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">))</span>
                        <span class="p">))</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">))]))</span>
                <span class="c1">#evaluate_log_pdf = None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span><span class="p">,</span> <span class="n">evaluate_log_pdf_marginals</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess input seed.</span>

<span class="sd">        Utility function (static method), that checks the dimension of seed, assign [0., 0., ..., 0.] if not provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: One of inputs seed or dimension must be provided.&#39;</span><span class="p">)</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input seed should be an array of shape (dimension, ) or (nchains, dimension).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Wrong dimensions between seed and dimension.&#39;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">,</span> <span class="n">dim</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_methods_proposal</span><span class="p">(</span><span class="n">proposal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if proposal has required methods.</span>

<span class="sd">        Utility function (static method), that checks that the given proposal distribution has 1) a rvs method and 2) a</span>
<span class="sd">        log pdf or pdf method. If a pdf method exists but no log_pdf, the log_pdf methods is added to the proposal</span>
<span class="sd">        object. Used in the MH and MMH initializations.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * proposal (Distribution object): proposal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal should be a Distribution object&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span></div>


<span class="c1">#################################################################################################################</span>


<div class="viewcode-block" id="MH"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MH">[docs]</a><span class="k">class</span> <span class="nc">MH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Metropolis-Hastings algorithm</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal distribution. Default: standard multivariate normal</span>

<span class="sd">    * **proposal_is_symmetric** (`bool`):</span>
<span class="sd">        indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Initialize algorithm specific inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either input proposal or dimension must be provided.&#39;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">JointInd</span><span class="p">,</span> <span class="n">Normal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">JointInd</span><span class="p">([</span><span class="n">Normal</span><span class="p">()]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compute acceptance ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">:</span>  <span class="c1"># proposal is symmetric</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
            <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidate</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">)</span> <span class="o">-</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">current_state</span> <span class="o">-</span> <span class="n">candidate</span><span class="p">)</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>  <span class="c1"># this vector will be used to compute accept_ratio of each chain</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">r_</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>


<span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="MMH"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.MMH">[docs]</a><span class="k">class</span> <span class="nc">MMH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Modified Metropolis-Hastings algorithm, [3]_</span>

<span class="sd">    In this algorithm, candidate samples are drawn separately in each dimension, thus the proposal consists in a list</span>
<span class="sd">    of 1d distributions. The target pdf can be given as a joint pdf or a list of marginal pdfs in all dimensions. This</span>
<span class="sd">    will trigger two different algorithms.</span>

<span class="sd">    **References:**</span>

<span class="sd">    .. [3] S.-K. Au and J. L. Beck,“Estimation of small failure probabilities in high dimensions by subset simulation,”</span>
<span class="sd">           Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263–277, Oct. 2001.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** ((`list` of) ``Distribution`` object(s)):</span>
<span class="sd">        Proposal distribution(s) in dimension 1. Default: standard normal</span>

<span class="sd">    * **proposal_is_symmetric** ((`list` of) `bool`):</span>
<span class="sd">        indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False, set to True if default proposal is used</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># If proposal is not provided: set it as a list of standard gaussians</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">Normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>

        <span class="c1"># set default proposal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="n">Normal</span><span class="p">(),</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="c1"># Proposal is provided, check it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only one Distribution is provided, check it and transform it to a list</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># a list of proposals is provided</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal given as a list should be of length dimension&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span>

        <span class="c1"># check the symmetry of proposal, assign False as default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal_is_symmetric should be a (list of) boolean(s)&#39;</span><span class="p">)</span>

        <span class="c1"># check with algo type is used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;marginals&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;joint&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MMH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The target pdf is provided via its marginals</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;marginals&#39;</span><span class="p">:</span>
            <span class="c1"># Evaluate the current log_pdf</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                                                  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)]</span>

            <span class="c1"># Sample candidate (independently in each dimension)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">candidate_j</span><span class="p">)</span>

                <span class="c1"># Compute acceptance ratio</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span> \
                                         <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">)</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate_j</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">)</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="c1"># The target pdf is provided as a joint pdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
                <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_j</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span> \
                                         <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">)</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="Stretch"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.Stretch">[docs]</a><span class="k">class</span> <span class="nc">Stretch</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Affine-invariant sampler with Stretch moves, [4]_, [5]_</span>

<span class="sd">    **References:**</span>

<span class="sd">    .. [4] J. Goodman and J. Weare, “Ensemble samplers with affine invariance,” Commun. Appl. Math. Comput. Sci.,vol.5,</span>
<span class="sd">           no. 1, pp. 65–80, 2010.</span>
<span class="sd">    .. [5] Daniel Foreman-Mackey, David W. Hogg, Dustin Lang, and Jonathan Goodman. &quot;emcee: The MCMC Hammer&quot;.</span>
<span class="sd">           Publications of the Astronomical Society of the Pacific, 125(925):306–312,2013.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        Scale parameter. Default: 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Check nchains = ensemble size for the Stretch algorithm</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the Stretch algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check Stretch algorithm inputs: proposal_type and proposal_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input scale must be of type float.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for Stretch algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start the loop over nsamples - this code uses the parallel version of the stretch algorithm</span>
        <span class="n">all_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">all_inds</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>
        <span class="c1"># Separate the full ensemble into two sets, use one as a complementary ensemble to the other and vice-versa</span>
        <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="n">inds</span> <span class="o">==</span> <span class="n">split</span><span class="p">)</span>

            <span class="c1"># Get current and complementary sets</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_state</span><span class="p">[</span><span class="n">inds</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">split</span><span class="p">],</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">split</span><span class="p">]</span>  <span class="c1"># current and complementary sets respectively</span>
            <span class="n">Ns</span><span class="p">,</span> <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># Sample new state for S1 based on S0 and vice versa</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>  <span class="c1"># sample Z</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>  <span class="c1"># compute log(Z ** (d - 1))</span>
            <span class="n">rint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">Nc</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">Ns</span><span class="p">,),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># sample X_{j} from complementary set</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">zz</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>  <span class="c1"># new candidates</span>

            <span class="c1"># Compute new likelihood, can be done in parallel :)</span>
            <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

            <span class="c1"># Compute acceptance rate</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_inds</span><span class="p">[</span><span class="n">S1</span><span class="p">],</span> <span class="n">factors</span><span class="p">,</span> <span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">):</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">f</span> <span class="o">+</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>


<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DRAM"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DRAM">[docs]</a><span class="k">class</span> <span class="nc">DRAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Delayed Rejection Adaptive Metropolis algorithm, [6]_, [7]_</span>

<span class="sd">    In this algorithm, the proposal density is Gaussian and its covariance C is being updated from samples as</span>
<span class="sd">    C = sp * C_sample where C_sample is the sample covariance. Also, the delayed rejection scheme is applied, i.e,</span>
<span class="sd">    if a candidate is not accepted another one is generated from proposal with covariance gamma_2 ** 2 * C.</span>

<span class="sd">    **References:**</span>

<span class="sd">    .. [6] Heikki Haario, Marko Laine, Antonietta Mira, and Eero Saksman. &quot;DRAM: Efficient adaptive MCMC&quot;. Statistics</span>
<span class="sd">           and Computing, 16(4):339–354, 2006</span>
<span class="sd">    .. [7] R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **initial_cov** (`ndarray`):</span>
<span class="sd">        initial covariance for the gaussian proposal distribution. Default: I(dim)</span>

<span class="sd">    * **k0** (`int`):</span>
<span class="sd">        rate at which covariance is being updated, i.e., every k0 iterations. Default: 100</span>

<span class="sd">    * **sp** (`float`):</span>
<span class="sd">        scale parameter for covariance updating. Default: 2.38 ** 2 / dim</span>

<span class="sd">    * **gamma_2** (`float`):</span>
<span class="sd">        scale parameter for delayed rejection. Default: 1 / 5</span>

<span class="sd">    * **save_cov** (`bool`):</span>
<span class="sd">        if True, updated covariance is saved in attribute adaptive_covariance. Default: False</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma_2</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">save_covariance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Check the initial covariance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">initial_covariance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                  <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input initial_covariance should be a 2D ndarray of shape (dimension, dimension)&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">=</span> <span class="n">gamma_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="o">=</span> <span class="n">save_covariance</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;k0&#39;</span><span class="p">,</span> <span class="s1">&#39;sp&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma_2&#39;</span><span class="p">,</span> <span class="s1">&#39;save_covariance&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># initialize the sample mean and sample covariance that you need</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DRAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">MVNormal</span>
        <span class="n">mvp</span> <span class="o">=</span> <span class="n">MVNormal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="n">current_cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">):</span>
            <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="n">current_cov</span><span class="p">)</span>
            <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">inds_DR</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># indices of chains that will undergo delayed rejection</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">log_p_cand</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>    <span class="c1"># enter delayed rejection</span>
                <span class="n">inds_DR</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>    <span class="c1"># these indices will enter the delayed rejection part</span>

        <span class="c1"># Delayed rejection</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># performed delayed rejection for some samples</span>
            <span class="n">current_states_DR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidates_DR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidate2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="c1"># Sample other candidates closer to the current one</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">):</span>
                <span class="n">current_states_DR</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">candidates_DR</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
                <span class="n">candidate2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_states_DR</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
            <span class="c1"># Evaluate their log_target</span>
            <span class="n">log_p_candidate2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_cand2</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_DR</span> <span class="o">-</span> <span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_curr</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_DR</span> <span class="o">-</span> <span class="n">current_states_DR</span><span class="p">)</span>
            <span class="c1"># Accept or reject</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">cand2</span><span class="p">,</span> <span class="n">log_p_cand2</span><span class="p">,</span> <span class="n">J1</span><span class="p">,</span> <span class="n">J2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds_DR</span><span class="p">,</span> <span class="n">candidate2</span><span class="p">,</span> <span class="n">log_p_candidate2</span><span class="p">,</span> <span class="n">log_prop_cand_cand2</span><span class="p">,</span>
                                                        <span class="n">log_prop_cand_curr</span><span class="p">):</span>
                <span class="n">alpha_cand_cand2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_p_cand2</span><span class="p">))</span>
                <span class="n">alpha_cand_curr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]))</span>
                <span class="n">log_alpha2</span> <span class="o">=</span> <span class="n">log_p_cand2</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="n">J1</span> <span class="o">-</span> <span class="n">J2</span> <span class="o">+</span> \
                             <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_cand2</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)))</span> \
                             <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_curr</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)))</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">log_alpha2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand2</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand2</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Adaptive part: update the covariance</span>
        <span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="c1"># update covariance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_update_mean_covariance</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span><span class="p">,</span> <span class="n">new_sample</span><span class="o">=</span><span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:],</span> <span class="n">previous_mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span>
                <span class="n">previous_covariance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="ow">and</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_update_mean_covariance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">new_sample</span><span class="p">,</span> <span class="n">previous_mean</span><span class="p">,</span> <span class="n">previous_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterative formula to compute a new sample mean and covariance based on previous ones and new sample.</span>

<span class="sd">        New covariance is computed only of previous_covariance is provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * n (int): Number of samples used to compute the new mean</span>
<span class="sd">        * new_sample (ndarray (dim, )): new sample</span>
<span class="sd">        * previous_mean (ndarray (dim, )): Previous sample mean, to be updated with new sample value</span>
<span class="sd">        * previous_covariance (ndarray (dim, dim)): Previous sample covariance, to be updated with new sample value</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * new_mean (ndarray (dim, )): Updated sample mean</span>
<span class="sd">        * new_covariance (ndarray (dim, dim)): Updated sample covariance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">previous_mean</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">new_sample</span>
        <span class="k">if</span> <span class="n">previous_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_mean</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">new_sample</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sample</span> <span class="o">-</span> <span class="n">previous_mean</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">previous_covariance</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">delta_n</span><span class="p">,</span> <span class="n">delta_n</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_mean</span><span class="p">,</span> <span class="n">new_covariance</span></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DREAM"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.DREAM">[docs]</a><span class="k">class</span> <span class="nc">DREAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    DiffeRential Evolution Adaptive Metropolis algorithm, [8]_, [9]_</span>

<span class="sd">    **References:**</span>

<span class="sd">    .. [8] J.A. Vrugt et al. &quot;Accelerating Markov chain Monte Carlo simulation by differential evolution with</span>
<span class="sd">           self-adaptive randomized subspace sampling&quot;. International Journal of Nonlinear Sciences and Numerical</span>
<span class="sd">           Simulation, 10(3):273–290, 2009.[68]</span>
<span class="sd">    .. [9] J.A. Vrugt. &quot;Markov chain Monte Carlo simulation using the DREAM software package: Theory, concepts, and</span>
<span class="sd">           MATLAB implementation&quot;. Environmental Modelling &amp; Software, 75:273–316, 2016.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **delta** (`int`):</span>
<span class="sd">        jump rate. Default: 3</span>

<span class="sd">    * **c** (`float`):</span>
<span class="sd">        differential evolution parameter. Default: 0.1</span>

<span class="sd">    * **c_star** (`float`):</span>
<span class="sd">        differential evolution parameter, should be small compared to width of target. Default: 1e-6</span>

<span class="sd">    * **n_CR** (`int`):</span>
<span class="sd">        number of crossover probabilities. Default: 3</span>

<span class="sd">    * **p_g** (`float`):</span>
<span class="sd">        prob(gamma=1). Default: 0.2</span>

<span class="sd">    * **adapt_CR** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs adapation of crossover probabilities (adapts every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no adaptation</span>

<span class="sd">    * **check_chains** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs discarding of outlier chains (discard every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no check on outlier chains</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">delta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">c_star</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">n_CR</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">p_g</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">adapt_CR</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">check_chains</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Check nb of chains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the DREAM algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check user-specific algorithms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">=</span> <span class="n">c_star</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">=</span> <span class="n">n_CR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_g</span> <span class="o">=</span> <span class="n">p_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span> <span class="o">=</span> <span class="n">adapt_CR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span> <span class="o">=</span> <span class="n">check_chains</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c_star&#39;</span><span class="p">,</span> <span class="s1">&#39;n_CR&#39;</span><span class="p">,</span> <span class="s1">&#39;p_g&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;adapt_CR&#39;</span><span class="p">,</span> <span class="s1">&#39;check_chains&#39;</span><span class="p">]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Inputs &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be a tuple of 2 integers.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize a few other variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DREAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)])</span>
        <span class="n">CR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span>

        <span class="c1"># Dynamic part: evolution of chains</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="n">lmda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>
        <span class="n">std_x_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">as_</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="n">bs_</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_CR</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pCR</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_j</span> <span class="o">&lt;</span> <span class="n">CR</span><span class="p">[</span><span class="n">id_j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">z_j</span><span class="p">,</span> <span class="n">id_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">id</span><span class="p">)]</span>  <span class="c1"># subset A of selected dimensions</span>
        <span class="n">d_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">A_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">A_j</span> <span class="ow">in</span> <span class="n">A</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
                <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gamma_d</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_star</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">gamma_d</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_g</span><span class="p">])</span>
             <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dX</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span> <span class="o">+</span> \
                           <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">lmda</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_state</span><span class="p">[</span><span class="n">as_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[</span><span class="n">bs_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="n">dX</span>

        <span class="c1"># Evaluate log likelihood of candidates</span>
        <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

        <span class="c1"># Accept or reject</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dX</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dX</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">std_x_tmp</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Save the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="c1"># update selection cross prob</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_CR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pCR</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pCR</span><span class="p">)</span>
        <span class="c1"># check outlier chains (only if you have saved at least 100 values already)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_outlier_chains</span><span class="p">(</span><span class="n">replace_with_best</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span>

    <span class="k">def</span> <span class="nf">check_outlier_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replace_with_best</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check outlier chains in DREAM algorithm.</span>

<span class="sd">        This function check for outlier chains as part of the DREAM algorithm, potentially replacing outlier chains</span>
<span class="sd">        (i.e. the samples and log_pdf_values) with &#39;good&#39; chains. The function does not have any returned output but it</span>
<span class="sd">        prints out the number of outlier chains.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **replace_with_best** (`bool`):</span>
<span class="sd">            indicates whether to replace outlier chains with the best (most probable) chain. Default: False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input save_log_pdf must be True in order to check outlier chains&#39;</span><span class="p">)</span>
        <span class="n">start_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">avgs_logpdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">best_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">avg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="n">ind3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind3</span><span class="p">]</span>
        <span class="n">qr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>

        <span class="n">outlier_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">avgs_logpdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">q1</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">qr</span><span class="p">:</span>
                <span class="n">outlier_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">replace_with_best</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Chain </span><span class="si">{}</span><span class="s1"> is an outlier chain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">outlier_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Detected </span><span class="si">{}</span><span class="s1"> outlier chains&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outlier_num</span><span class="p">))</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Importance Sampling</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="IS"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS">[docs]</a><span class="k">class</span> <span class="nc">IS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample from a user-defined target density using importance sampling.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal to sample from. This Distribution object must have an rvs method and a log_pdf (or pdf) methods</span>

<span class="sd">    * **log_pdf_target** (callable)</span>
<span class="sd">        Callable that evaluates the target log-pdf. One of log_pdf_target or pdf_target must be specified (the former</span>
<span class="sd">        is preferred).</span>

<span class="sd">    * **pdf_target** (callable):</span>
<span class="sd">        Callable that evaluates the target pdf</span>

<span class="sd">    * **args_target** (`tuple`):</span>
<span class="sd">        Positional arguments of the target log_pdf / pdf callable</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to generate</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        Set of samples, `ndarray` of shape (nsamples, dim)</span>

<span class="sd">    * **unnormalized_log_weights** (`ndarray`)</span>
<span class="sd">        unnormalized log weights, i.e., log_w(x) = log_target(x) - log_proposal(x), `ndarray` of shape (nsamples, )</span>

<span class="sd">    * **weights** (`ndarray`):</span>
<span class="sd">        importance weights samples, weighted so that they sum up to 1, `ndarray` of shape (nsamples, )</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/2020 by Audrey Olivier</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="c1"># Initialize proposal: it should have an rvs and log pdf or pdf method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The proposal should be of type Distribution.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                                                <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>

        <span class="c1"># Initialize target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>

        <span class="c1"># Initialize the samples and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Run IS if nsamples is provided</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="IS.run"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and weight samples.</span>

<span class="sd">        This function samples from the proposal and append samples to existing ones (if any). It then weights the </span>
<span class="sd">        samples as log_w_unnormalized) = log(target)-log(proposal). This function updates the output attributes </span>
<span class="sd">        samples, unnormalized_log_weights and weights. If nsamples is provided when creating the object, this method is </span>
<span class="sd">        directly called in init.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of weighted samples to generate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running Importance Sampling&#39;</span><span class="p">)</span>
        <span class="c1"># Sample from proposal</span>
        <span class="n">new_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="c1"># Compute un-scaled weights of new samples</span>
        <span class="n">new_log_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span>

        <span class="c1"># Save samples and weights (append to existing if necessary)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">new_samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">new_log_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_samples</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">,</span> <span class="n">new_log_weights</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Take the exponential and normalize the weights</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">))</span>
        <span class="c1"># note: scaling with max avoids having NaN of Inf when taking the exp</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">sum_w</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Importance Sampling performed successfully&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="IS.resample"><a class="viewcode-back" href="../../samplemethods.html#UQpy.SampleMethods.IS.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Resample to get a set of un-weighted samples that represent the target pdf.</span>
<span class="sd">        </span>
<span class="sd">        Utility function that create a set of un-weighted samples from a set of weighted samples. Can be useful for</span>
<span class="sd">        plotting for instance.</span>
<span class="sd">        </span>
<span class="sd">        **Inputs:**</span>

<span class="sd">        * **method** (`str`)</span>
<span class="sd">            Resampling method, as of V3 only multinomial resampling is supported. Default: &#39;multinomial&#39;.</span>
<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of un-weighted samples to generate. Default: None (same number of samples is generated as number of</span>
<span class="sd">            existing samples).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * (`ndarray`)</span>
<span class="sd">            Un-weighted samples that represent the target pdf, `ndarray` of shape (nsamples, dimension)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.Utilities</span> <span class="k">import</span> <span class="n">resample</span>
        <span class="k">return</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided</span>
<span class="sd">        * pdf ((list of) callables): Target density function from which to draw random samples.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel.html">RunModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dimension_reduction.html">Dimension reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, SURG, JHU.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>