
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>SampleMethods &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Transformations" href="transformations.html" />
    <link rel="prev" title="Distributions" href="distributions.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="samplemethods">
<span id="id1"></span><h1>SampleMethods<a class="headerlink" href="#samplemethods" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-UQpy.SampleMethods"></span><p>This module contains functionality for all the sampling methods supported in <code class="docutils literal notranslate"><span class="pre">UQpy</span></code>.</p>
<p>The module currently contains the following classes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MCS</span></code>: Class to perform Monte Carlo sampling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LHS</span></code>: Class to perform Latin hypercube sampling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MCMC</span></code>: Class to perform Markov Chain Monte Carlo sampling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IS</span></code>: Class to perform Importance sampling.</p></li>
</ul>
<div class="section" id="mcs">
<h2>MCS<a class="headerlink" href="#mcs" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class generates random samples from a specified probability distribution(s).  The <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class utilizes the <code class="docutils literal notranslate"><span class="pre">Distributions</span></code> class to define probability distributions.  The advantage of using the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class for <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> operations, as opposed to simply generating samples with the <code class="docutils literal notranslate"><span class="pre">scipy.stats</span></code> package, is that it allows building an object containing the samples and their distributions for integration with other <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> modules.</p>
<div class="section" id="class-descriptions">
<h3>Class Descriptions<a class="headerlink" href="#class-descriptions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.MCS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">MCS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Monte Carlo sampling (MCS) of random variables.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>Probability distribution of each random variable. Must be an object (or a list of objects) of the
<code class="docutils literal notranslate"><span class="pre">Distribution</span></code> class.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be drawn from each distribution.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically called if <cite>nsamples</cite> is provided. If <cite>nsamples</cite> is not provided, then the
<code class="docutils literal notranslate"><span class="pre">MCS</span></code> object is created but samples are not generated.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (Boolean):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><dl>
<dt><strong>samples</strong> (<cite>ndarray</cite> or <cite>list</cite>):</dt><dd><p>Generated samples.</p>
<p>If a list of <code class="docutils literal notranslate"><span class="pre">DistributionContinuous1D</span></code> objects is provided for <code class="docutils literal notranslate"><span class="pre">dist_object</span></code>, then <cite>samples</cite> is an
<cite>ndarray</cite> with <code class="docutils literal notranslate"><span class="pre">samples.shape=(nsamples,</span> <span class="pre">len(dist_object))</span></code>.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DistributionContinuous1D</span></code> object is provided for <code class="docutils literal notranslate"><span class="pre">dist_object</span></code> then <cite>samples</cite> is an array with
<cite>samples.shape=(nsamples, 1)`</cite>.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DistributionContinuousND</span></code> object is provided for <code class="docutils literal notranslate"><span class="pre">dist_object</span></code> then <cite>samples</cite> is an array with
<code class="docutils literal notranslate"><span class="pre">samples.shape=(nsamples,</span> <span class="pre">ND)</span></code>.</p>
<p>If a list of mixed <code class="docutils literal notranslate"><span class="pre">DistributionContinuous1D</span></code> and <code class="docutils literal notranslate"><span class="pre">DistributionContinuousND</span></code> objects is provided then
<cite>samples</cite> is a list with <code class="docutils literal notranslate"><span class="pre">len(samples)=nsamples</span></code> and <code class="docutils literal notranslate"><span class="pre">len(samples[i])</span> <span class="pre">=</span> <span class="pre">len(dist_object)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>samplesU01</strong> (<cite>ndarray</cite> (<cite>list</cite>)):</dt><dd><p>Generated samples transformed to the unit hypercube.</p>
<p>This attribute exists only if the <code class="docutils literal notranslate"><span class="pre">transform_u01</span></code> method is invoked by the user.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.MCS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the random sampling in the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is the function that performs random sampling in the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class. If <cite>nsamples</cite> is
provided, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically called when the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> object is defined. The user may also call
the <code class="docutils literal notranslate"><span class="pre">run</span></code> method directly to generate samples. The <code class="docutils literal notranslate"><span class="pre">run</span></code> method of the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class can be invoked many
times and each time the generated samples are appended to the existing samples.</p>
<p>** Input:**</p>
<ul>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be drawn from each distribution.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is invoked multiple times, the newly generated samples will be appended to the
existing samples.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no returns, although it creates and/or appends the <cite>samples</cite> attribute of the <code class="docutils literal notranslate"><span class="pre">MCS</span></code>
class.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.MCS.transform_u01">
<code class="sig-name descname">transform_u01</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCS.transform_u01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCS.transform_u01" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform random samples to uniform on the unit hypercube.</p>
<p><strong>Input:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">transform_u01</span></code> method is an instance method that perform the transformation on an existing <code class="docutils literal notranslate"><span class="pre">MCS</span></code>
object. It takes no input.</p>
<p><strong>Output/Returns:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">transform_u01</span></code> method has no returns, although it creates and/or appends the <cite>samplesU01</cite> attribute of
the <code class="docutils literal notranslate"><span class="pre">MCS</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="lhs">
<h2>LHS<a class="headerlink" href="#lhs" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class generates random samples from a specified probability distribution(s) using Latin hypercube sampling. LHS has the advantage that the samples generated are uniformly distributed over each marginal distribution. LHS is perfomed by dividing the range of each random variable into N bins with equal probability mass, where N is the required number of samples, generating one sample per bin, and then randomly pairing the samples.</p>
<div class="section" id="adding-new-latin-hypercube-design-criteria">
<h3>Adding New Latin Hypercube Design Criteria<a class="headerlink" href="#adding-new-latin-hypercube-design-criteria" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class offers a variety of methods for pairing the samples in a Latin hypercube design. These are specified by the <cite>criterion</cite> parameter (i.e. ‘random’, ‘centered’, ‘minmax’, ‘correlate’). However, adding a new method is straightforward. This is done by creating a new method that contains the algorithm for pairing the samples. This method takes as input the randomly generated samples in equal probability bins in each dimension and returns a set of samples that is paired according to the user’s desired criterion. The user may also pass criterion-specific parameters into the custom method. These parameters are input to the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class through the <cite>**kwargs</cite>. The output of this function should be a numpy array of at least two-dimensions with the first dimension being the number of samples and the second dimension being the number of variables . An example user-defined criterion is given below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">lhs_samples</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Class Descriptions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.LHS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">LHS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">nsamples</em>, <em class="sig-param">criterion=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Latin hypercube sampling (MCS) of random variables.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
<p>All distributions in <code class="docutils literal notranslate"><span class="pre">LHS</span></code> must be independent. <code class="docutils literal notranslate"><span class="pre">LHS</span></code> does not generate correlated random variables.
Therefore, for multi-variate designs the <cite>dist_object</cite> must be a list of <code class="docutils literal notranslate"><span class="pre">DistributionContinuous1D</span></code> objects
or an object of the <code class="docutils literal notranslate"><span class="pre">JointInd</span></code> class.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be drawn from each distribution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>criterion</strong> (<cite>str</cite> or <cite>callable</cite>):</dt><dd><dl class="simple">
<dt>The criterion for pairing the generating sample points</dt><dd><dl class="simple">
<dt>Options:</dt><dd><ol class="arabic simple">
<li><p>‘random’ - completely random.</p></li>
<li><p>‘centered’ - points only at the centre.</p></li>
<li><p>‘maximin’ - maximizing the minimum distance between points.</p></li>
<li><p>‘correlate’ - minimizing the correlation between the points.</p></li>
<li><p><cite>callable</cite> - User-defined method.</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>**kwargs</strong></dt><dd><p>Additional arguments to be passed to the method specified by <cite>criterion</cite></p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The generated LHS samples.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples_U01</strong> (<cite>ndarray</cite>):</dt><dd><p>The generated LHS samples on the unit hypercube.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.LHS.centered">
<em class="property">static </em><code class="sig-name descname">centered</code><span class="sig-paren">(</span><em class="sig-param">samples</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">a=None</em>, <em class="sig-param">b=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS.centered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS.centered" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for generating a Latin hypercube design with samples centered in the bins.</p>
<p><strong>Input:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>A set of samples drawn from within each LHS bin. In this method, the samples passed in are not used.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>random_state</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">numpy.RandomState</span></code> object that fixes the seed of the pseudo random number generation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>a</strong> (<cite>ndarray</cite>)</dt><dd><p>An array of the bin lower-bounds.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>b</strong> (<cite>ndarray</cite>)</dt><dd><p>An array of the bin upper-bounds</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>lhs_samples</strong> (<cite>ndarray</cite>)</dt><dd><p>The centered set of LHS samples.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.LHS.correlate">
<code class="sig-name descname">correlate</code><span class="sig-paren">(</span><em class="sig-param">samples</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">iterations=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS.correlate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS.correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for generating a Latin hypercube design that aims to minimize spurious correlations.</p>
<p><strong>Input:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>A set of samples drawn from within each LHS bin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>random_state</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">numpy.RandomState</span></code> object that fixes the seed of the pseudo random number generation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>iterations</strong> (<cite>int</cite>):</dt><dd><p>The number of iteration to run in the search for a maximin design.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>lhs_samples</strong> (<cite>ndarray</cite>)</dt><dd><p>The minimum correlation set of LHS samples.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.LHS.max_min">
<code class="sig-name descname">max_min</code><span class="sig-paren">(</span><em class="sig-param">samples</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">iterations=100</em>, <em class="sig-param">metric='euclidean'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS.max_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS.max_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for generating a Latin hypercube design that aims to maximize the minimum sample distance.</p>
<p><strong>Input:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>A set of samples drawn from within each LHS bin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>random_state</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">numpy.RandomState</span></code> object that fixes the seed of the pseudo random number generation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>iterations</strong> (<cite>int</cite>):</dt><dd><p>The number of iteration to run in the search for a maximin design.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>metric</strong> (<cite>str</cite> or <cite>callable</cite>):</dt><dd><dl class="simple">
<dt>The distance metric to use.</dt><dd><dl class="simple">
<dt>Options:</dt><dd><ol class="arabic simple">
<li><p><cite>str</cite> - Available options are those supported by <code class="docutils literal notranslate"><span class="pre">scipy.spatial.distance</span></code></p></li>
<li><p>User-defined function to compute the distance between samples. This function replaces the
<code class="docutils literal notranslate"><span class="pre">scipy.spatial.distance.pdist</span></code> method.</p></li>
</ol>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>lhs_samples</strong> (<cite>ndarray</cite>)</dt><dd><p>The maximin set of LHS samples.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.LHS.random">
<em class="property">static </em><code class="sig-name descname">random</code><span class="sig-paren">(</span><em class="sig-param">samples</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS.random"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for generating a Latin hypercube design by sampling randomly inside each bin.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">random</span></code> method takes a set of samples drawn randomly from within the Latin hypercube bins and performs a
random shuffling of them to pair the variables.</p>
<p><strong>Input:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>A set of samples drawn from within each bin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>random_state</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">numpy.RandomState</span></code> object that fixes the seed of the pseudo random number generation.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>lhs_samples</strong> (<cite>ndarray</cite>)</dt><dd><p>The randomly shuffled set of LHS samples.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.LHS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#LHS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.LHS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the random sampling in the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is the function that performs random sampling in the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class. If <cite>nsamples</cite> is
provided, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically called when the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> object is defined. The user may also call
the <code class="docutils literal notranslate"><span class="pre">run</span></code> method directly to generate samples. The <code class="docutils literal notranslate"><span class="pre">run</span></code> method of the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> class cannot be invoked
multiple times for sample size extension.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be drawn from each distribution.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is invoked multiple times, the newly generated samples will be overwrite the
existing samples.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no returns, although it creates and/or appends the <cite>samples</cite> and <cite>samples_U01</cite> attributes
of the <code class="docutils literal notranslate"><span class="pre">LHS</span></code> object.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="stratified-sampling">
<h2>Stratified Sampling<a class="headerlink" href="#stratified-sampling" title="Permalink to this headline">¶</a></h2>
<p>Stratified sampling is a variance reduction technique that divides the parameter space into a set of disjoint and space-filling strata. Samples are then drawn from these strata in order to improve the space-filling properties of the sample design. Stratified sampling allows for unequally weighted samples, such that a Monte Carlo estimator of the quantity <span class="math notranslate nohighlight">\(E[Y]\)</span> takes the following form:</p>
<div class="math notranslate nohighlight">
\[E[Y] \approx \sum_{i=1}^N w_i Y_i\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> are the sample weights and <span class="math notranslate nohighlight">\(Y_i\)</span> are the model evaluations. The individual sample weights are computed as:</p>
<div class="math notranslate nohighlight">
\[w_i = \dfrac{V_{i}}{N_{i}}\]</div>
<p>where <span class="math notranslate nohighlight">\(V_{i}\le 1\)</span> is the volume of stratum <span class="math notranslate nohighlight">\(i\)</span> in the unit hypercube (i.e. the probability that a random sample will fall in stratum <span class="math notranslate nohighlight">\(i\)</span>) and <span class="math notranslate nohighlight">\(N_{i}\)</span> is the number of samples drawn from stratum <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">UQpy</span></code> supports several stratified sampling variations that vary from conventional stratified sampling designs to advanced gradient informed methods for adaptive stratified sampling. Stratified sampling capabilities are built in <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> from three sets of classes. These class structures facilitate a highly flexible and varied range of stratified sampling designs that can be extended in a straightforward way. Specifically, the existing classes allow stratification of n-dimensional parameter spaces based on three common spatial discretizations: a rectilinear decomposition into hyper-rectangles (orthotopes), a Voronoi decomposition, and a Delaunay decomposition. The three parent classes are:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class defines the geometric structure of the stratification of the parameter space and it has three existing subclasses - <code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code>, <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code>, and <code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code> that correspond to geometric decompositions of the parameter space based on rectilinear strata of orthotopes, strata composed of Voronoi cells, and strata composed of Delaunay simplexes respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">STS</span></code> class defines a set of subclasses used to draw samples from strata defined by a <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class object.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class defines a set of subclasses for refinement of <code class="docutils literal notranslate"><span class="pre">STS</span></code> stratified sampling designs.</p></li>
</ol>
<div class="section" id="new-stratified-sampling-methods">
<h3>New Stratified Sampling Methods<a class="headerlink" href="#new-stratified-sampling-methods" title="Permalink to this headline">¶</a></h3>
<p>Extension of the stratified sampling capabilities in <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> can be performed through subclassing from the three main classes. First, the user can define a new geometric decomposition of the parameter space by creating a new subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class. To draw samples from this  new stratification, the user can define a new subclass of the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class. Finally, to enable refinement of the strata based on any user-specified criteria the user can define a new subclass of the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class.</p>
<p>In summary:</p>
<p>To implement a new stratified sampling method based on a new stratification, the user must write two new classes:</p>
<ol class="arabic simple">
<li><p>A new subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class defining the new decomposition.</p></li>
<li><p>A new subclass of the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class to perform the sampling from the newly design <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p></li>
</ol>
<p>To implement a new refined stratified sampling method based on a new stratified, the user must write three new classes:</p>
<ol class="arabic simple">
<li><p>A new subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class defining the new decomposition.</p></li>
<li><p>A new subclass of the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class to perform the sampling from the newly design <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p></li>
<li><p>A new subclass of the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class to perform the stratum refinement and subsequent sampling.</p></li>
</ol>
<p>The details of these subclasses and their requirements are outlined in the sections below discussing the respective classes.</p>
</div>
<div class="section" id="strata-class">
<h3>Strata Class<a class="headerlink" href="#strata-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class is the parent class that defines the geometric decomposition of the parameter space. All geometric decompositions in the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class are performed on the <cite>n</cite>-dimensional unit <span class="math notranslate nohighlight">\([0, 1]^n\)</span> hypercube. Specific stratifications are performed by subclassing the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class. There are currently three stratifications available in the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class, defined through the subclasses <code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code>, <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code>, and <code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code>.</p>
</div>
<div class="section" id="id3">
<h3>Class Descriptions<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.Strata">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">Strata</code><span class="sig-paren">(</span><em class="sig-param">seeds=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Strata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Strata" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling strata.</p>
<p>This is the parent class for all spatial stratifications. This parent class only provides the framework for
stratification and cannot be used directly for the stratification. Stratification is done by calling the child
class for the desired stratification.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>seeds</strong> (<cite>ndarray</cite>)</dt><dd><p>Define the seed points for the strata. See specific subclass for definition of the seed points.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>seeds</strong> (<cite>ndarray</cite>)</dt><dd><p>Seed points for the strata. See specific subclass for definition of the seed points.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.Strata.stratify">
<code class="sig-name descname">stratify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Strata.stratify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Strata.stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the stratification of the unit hypercube. It is overwritten by the subclass. This method must exist in
any subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p>
<p><strong>Outputs/Returns:</strong></p>
<p>The method has no returns, but it modifies the relevant attributes of the subclass.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.RectangularStrata">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">RectangularStrata</code><span class="sig-paren">(</span><em class="sig-param">nstrata=None</em>, <em class="sig-param">input_file=None</em>, <em class="sig-param">seeds=None</em>, <em class="sig-param">widths=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularStrata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularStrata" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling
rectangular strata.</p>
<p><code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code> is a child class of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl>
<dt><strong>nstrata</strong> (<cite>list</cite> of <cite>int</cite>):</dt><dd><p>A list of length <cite>n</cite> defining the number of strata in each of the <cite>n</cite> dimensions. Creates an equal
stratification with strata widths equal to 1/<cite>n_strata</cite>. The total number of strata, <cite>N</cite>, is the product
of the terms of <cite>n_strata</cite>.</p>
<p>Example: <cite>n_strata</cite> = [2, 3, 2] creates a 3-dimensional stratification with:</p>
<blockquote>
<div><p>2 strata in dimension 0 with stratum widths 1/2</p>
<p>3 strata in dimension 1 with stratum widths 1/3</p>
<p>2 strata in dimension 2 with stratum widths 1/2</p>
</div></blockquote>
<p>The user must pass one of <cite>nstrata</cite> OR <cite>input_file</cite> OR <cite>seeds</cite> and <cite>widths</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>input_file</strong> (<cite>str</cite>):</dt><dd><p>File path to an input file specifying stratum seeds and stratum widths.</p>
<p>This is typically used to define irregular stratified designs.</p>
<p>The user must pass one of <cite>n_strata</cite> OR <cite>input_file</cite> OR <cite>seeds</cite> and <cite>widths</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the seeds of all strata. The seeds of the strata are the
coordinates of the stratum orthotope nearest the global origin.</p>
<p>Example: A 2-dimensional stratification with 2 equal strata in each dimension:</p>
<blockquote>
<div><p><cite>origins</cite> = [[0, 0], [0, 0.5], [0.5, 0], [0.5, 0.5]]</p>
</div></blockquote>
<p>The user must pass one of <cite>n_strata</cite> OR <cite>input_file</cite> OR <cite>seeds</cite> and <cite>widths</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>widths</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the widths of all strata in each dimension</p>
<p>Example: A 2-dimensional stratification with 2 strata in each dimension</p>
<blockquote>
<div><p><cite>widths</cite> = [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]]</p>
</div></blockquote>
<p>The user must pass one of <cite>n_strata</cite> OR <cite>input_file</cite> OR <cite>seeds</cite> and <cite>widths</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>nstrata</strong> (<cite>list</cite> of <cite>int</cite>):</dt><dd><p>A list of length <cite>n</cite> defining the number of strata in each of the <cite>n</cite> dimensions. Creates an equal
stratification with strata widths equal to 1/<cite>n_strata</cite>. The total number of strata, <cite>N</cite>, is the product
of the terms of <cite>n_strata</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the seeds of all strata. The seeds of the strata are the
coordinates of the stratum orthotope nearest the global origin.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>widths</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the widths of all strata in each dimension</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>volume</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>(nstrata, )</cite> containing the volume of each stratum. Stratum volumes are equal to the
product of the strata widths.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.RectangularStrata.fullfact">
<em class="property">static </em><code class="sig-name descname">fullfact</code><span class="sig-paren">(</span><em class="sig-param">levels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularStrata.fullfact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularStrata.fullfact" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a full-factorial design</p>
<p>Note: This function has been modified from pyDOE, released under BSD License (3-Clause)</p>
<p>Copyright (C) 2012 - 2013 - Michael Baudin</p>
<p>Copyright (C) 2012 - Maria Christopoulou</p>
<p>Copyright (C) 2010 - 2011 - INRIA - Michael Baudin</p>
<p>Copyright (C) 2009 - Yann Collette</p>
<p>Copyright (C) 2009 - CEA - Jean-Marc Martinez</p>
<p>Original source code can be found at:</p>
<p><a class="reference external" href="https://pythonhosted.org/pyDOE">https://pythonhosted.org/pyDOE</a>/#</p>
<p>or</p>
<p><a class="reference external" href="https://pypi.org/project/pyDOE/">https://pypi.org/project/pyDOE/</a></p>
<p>or</p>
<p><a class="reference external" href="https://github.com/tisimst/pyDOE/">https://github.com/tisimst/pyDOE/</a></p>
<p><strong>Input:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>levels</strong> (<cite>list</cite>):</dt><dd><p>A list of integers that indicate the number of levels of each input design factor.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>ff</strong> (<cite>ndarray</cite>):</dt><dd><p>Full-factorial design matrix.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.RectangularStrata.stratify">
<code class="sig-name descname">stratify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularStrata.stratify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularStrata.stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the rectangular stratification.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.VoronoiStrata">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">VoronoiStrata</code><span class="sig-paren">(</span><em class="sig-param">seeds=None</em>, <em class="sig-param">nseeds=None</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">niters=1</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiStrata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiStrata" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling
Voronoi strata.</p>
<p><code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code> is a child class of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl>
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the seeds of all strata. The seeds of the strata are the
coordinates of the point inside each stratum that defines the stratum.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nseeds</strong> (<cite>int</cite>):</dt><dd><p>The number of seeds to randomly generate. Seeds are generated by random sampling on the unit hypercube.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>dimension</strong> (<cite>ndarray</cite>):</dt><dd><p>The dimension of the unit hypercube in which to generate random seeds. Used only if <cite>nseeds</cite> is provided.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>niters</strong> (<cite>int</cite>)</dt><dd><p>Number of iterations to perform to create a Centroidal Voronoi decomposition.</p>
<p>If <cite>niters = 0</cite>, the Voronoi decomposition is based on the provided or generated seeds.</p>
<p>If <span class="math notranslate nohighlight">\(niters \ge 1\)</span>, the seed points are moved to the centroids of the Voronoi cells in each iteration and
the a new Voronoi decomposition is performed. This process is repeated <cite>niters</cite> times to create a Centroidal
Voronoi decomposition.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul>
<li><dl>
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> containing the seeds of all strata. The seeds of the strata are the
coordinates of the point inside each stratum that defines the stratum.</p>
<p>If <span class="math notranslate nohighlight">\(niters &gt; 1\)</span> the <cite>seeds</cite> attribute will differ from the <cite>seeds</cite> input due to the iterations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>vertices</strong> (<cite>list</cite>)</dt><dd><p>A list of the vertices for each Voronoi stratum on the unit hypercube.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>voronoi</strong> (<cite>object</cite> of <code class="docutils literal notranslate"><span class="pre">scipy.spatial.Voronoi</span></code>)</dt><dd><p>Defines a Voronoi decomposition of the set of reflected points. When creating the Voronoi decomposition on
the unit hypercube, the code reflects the points on the unit hypercube across all faces of the unit hypercube.
This causes the Voronoi decomposition to create edges along the faces of the hypercube.</p>
<p>This object is not the Voronoi decomposition of the unit hypercube. It is the Voronoi decomposition of all
points and their reflections from which the unit hypercube is extracted.</p>
<p>To access the vertices in the unit hypercube, see the attribute <cite>vertices</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>volume</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>(nstrata, )</cite> containing the volume of each Voronoi stratum in the unit hypercube.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiStrata.compute_voronoi_centroid_volume">
<em class="property">static </em><code class="sig-name descname">compute_voronoi_centroid_volume</code><span class="sig-paren">(</span><em class="sig-param">vertices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiStrata.compute_voronoi_centroid_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiStrata.compute_voronoi_centroid_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the centroid and volume of a Voronoi cell from its vertices.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>vertices</strong> (<cite>ndarray</cite>):</dt><dd><p>Coordinates of the vertices that define the Voronoi cell.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>centroid</strong> (<cite>ndarray</cite>):</dt><dd><p>Centroid of the Voronoi cell.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>volume</strong> (<cite>ndarray</cite>):</dt><dd><p>Volume of the Voronoi cell.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiStrata.stratify">
<code class="sig-name descname">stratify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiStrata.stratify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiStrata.stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Voronoi stratification.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiStrata.voronoi_unit_hypercube">
<em class="property">static </em><code class="sig-name descname">voronoi_unit_hypercube</code><span class="sig-paren">(</span><em class="sig-param">seeds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiStrata.voronoi_unit_hypercube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiStrata.voronoi_unit_hypercube" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reflects the seeds across all faces of the unit hypercube and creates a Voronoi decomposition of
using all the points and their reflections. This allows a Voronoi decomposition that is bounded on the unit
hypercube to be extracted.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>Coordinates of points in the unit hypercube from which to define the Voronoi decomposition.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>vor</strong> (<code class="docutils literal notranslate"><span class="pre">scipy.spatial.Voronoi</span></code> object):</dt><dd><p>Voronoi decomposition of the complete set of points and their reflections.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>bounded_regions</strong> (see <cite>regions</cite> attribute of <code class="docutils literal notranslate"><span class="pre">scipy.spatial.Voronoi</span></code>)</dt><dd><p>Indices of the Voronoi vertices forming each Voronoi region for those regions lying inside the unit
hypercube.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.DelaunayStrata">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">DelaunayStrata</code><span class="sig-paren">(</span><em class="sig-param">seeds=None</em>, <em class="sig-param">nseeds=None</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DelaunayStrata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DelaunayStrata" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling
Delaunay strata of n-dimensional simplexes.</p>
<p><code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code> is a child class of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl>
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> specifying the seeds of all strata. The seeds of the strata are the
coordinates of the vertices of the Delaunay cells.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
<p>Note that, if <cite>seeds</cite> does not include all corners of the unit hypercube, they are added.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nseeds</strong> (<cite>int</cite>):</dt><dd><p>The number of seeds to randomly generate. Seeds are generated by random sampling on the unit hypercube. In
addition, the class also adds seed points at all corners of the unit hypercube.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>dimension</strong> (<cite>ndarray</cite>):</dt><dd><p>The dimension of the unit hypercube in which to generate random seeds. Used only if <cite>nseeds</cite> is provided.</p>
<p>The user must provide <cite>seeds</cite> or <cite>nseeds</cite> and <cite>dimension</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>seeds</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>N x n</cite> containing the seeds of all strata. The seeds of the strata are the
coordinates of the vertices of the Delaunay cells.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>centroids</strong> (<cite>ndarray</cite>)</dt><dd><p>A list of the vertices for each Voronoi stratum on the unit hypercube.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>delaunay</strong> (<cite>object</cite> of <code class="docutils literal notranslate"><span class="pre">scipy.spatial.Delaunay</span></code>)</dt><dd><p>Defines a Delaunay decomposition of the set of seed points and all corner points.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>volume</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of dimension <cite>(nstrata, )</cite> containing the volume of each Delaunay stratum in the unit hypercube.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.DelaunayStrata.compute_delaunay_centroid_volume">
<em class="property">static </em><code class="sig-name descname">compute_delaunay_centroid_volume</code><span class="sig-paren">(</span><em class="sig-param">vertices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DelaunayStrata.compute_delaunay_centroid_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DelaunayStrata.compute_delaunay_centroid_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the centroid and volume of a Delaunay simplex from its vertices.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>vertices</strong> (<cite>ndarray</cite>):</dt><dd><p>Coordinates of the vertices of the simplex.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>centroid</strong> (<cite>numpy.ndarray</cite>):</dt><dd><p>Centroid of the Delaunay simplex.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>volume</strong> (<cite>numpy.ndarray</cite>):</dt><dd><p>Volume of the Delaunay simplex.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.DelaunayStrata.stratify">
<code class="sig-name descname">stratify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DelaunayStrata.stratify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DelaunayStrata.stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the stratification of the unit hypercube. It is overwritten by the subclass. This method must exist in
any subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class.</p>
<p><strong>Outputs/Returns:</strong></p>
<p>The method has no returns, but it modifies the relevant attributes of the subclass.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="adding-a-new-strata-class">
<h3>Adding a new <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class<a class="headerlink" href="#adding-a-new-strata-class" title="Permalink to this headline">¶</a></h3>
<p>Adding a new type of stratification requires creating a new subclass of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class that defines the desired geometric decomposition. This subclass must have a <code class="docutils literal notranslate"><span class="pre">stratify</span></code> method that overwrites the corresponding method in the parent class and performs the stratification.</p>
</div>
<div class="section" id="sts-class">
<h3>STS Class<a class="headerlink" href="#sts-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">STS</span></code> class is the parent class for stratified sampling. The various <code class="docutils literal notranslate"><span class="pre">STS</span></code> classes generate random samples from a specified probability distribution(s) using stratified sampling with strata specified by an object of one of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> classes. The <code class="docutils literal notranslate"><span class="pre">STS</span></code> class currently has three child classes - <code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code>, <code class="docutils literal notranslate"><span class="pre">VoronoiSTS</span></code>, and <code class="docutils literal notranslate"><span class="pre">DelaunaySTS</span></code> - corresponding to stratified sampling methods based rectangular, Voronoi, and Delaunay strata respectively. The following details these classes.</p>
</div>
<div class="section" id="id4">
<h3>Class Descriptions<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.STS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">STS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">strata_object</em>, <em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#STS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.STS" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class for Stratified Sampling (<a class="footnote-reference brackets" href="#id40" id="id5">9</a>).</p>
<p>This is the parent class for all stratified sampling methods. This parent class only provides the framework for
stratified sampling and cannot be used directly for the sampling. Sampling is done by calling the child
class for the desired stratification.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>strata_object</strong> (<code class="docutils literal notranslate"><span class="pre">Strata</span></code> object)</dt><dd><p>Defines the stratification of the unit hypercube. This must be provided and must be an object of a <code class="docutils literal notranslate"><span class="pre">Strata</span></code>
child class: <code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code>, <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code>, or <code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples_per_stratum</strong> (<cite>int</cite> or <cite>list</cite>):</dt><dd><p>Specifies the number of samples in each stratum. This must be either an integer, in which case an equal number
of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the list must be
equal to the number of strata.</p>
<p>If <cite>nsamples_per_stratum</cite> is provided when the class is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be executed
automatically.  If neither <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> are provided when the class is defined, the user
must call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method to perform stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Specify the total number of samples. If <cite>nsamples</cite> is specified, the samples will be drawn in proportion to
the volume of the strata. Thus, each stratum will contain <span class="math notranslate nohighlight">\(round(V_i*nsamples)\)</span> samples.</p>
<p>If <cite>nsamples</cite> is provided when the class is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be executed
automatically.  If neither <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> are provided when the class is defined, the user
must call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method to perform stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
<p>Default value: False</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The generated samples following the prescribed distribution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samplesU01</strong> (<cite>ndarray</cite>)</dt><dd><p>The generated samples on the unit hypercube.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>weights</strong> (<cite>ndarray</cite>)</dt><dd><p>Individual sample weights.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.STS.create_samplesu01">
<code class="sig-name descname">create_samplesu01</code><span class="sig-paren">(</span><em class="sig-param">nsamples_per_stratum</em>, <em class="sig-param">nsamples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#STS.create_samplesu01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.STS.create_samplesu01" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the specific stratified sampling algorithm. This method is overwritten by each child class of <code class="docutils literal notranslate"><span class="pre">STS</span></code>.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>nsamples_per_stratum</strong> (<cite>int</cite> or <cite>list</cite>):</dt><dd><p>Specifies the number of samples in each stratum. This must be either an integer, in which case an equal
number of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the
list must be equal to the number of strata.</p>
<p>Either <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> must be provided.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Specify the total number of samples. If <cite>nsamples</cite> is specified, the samples will be drawn in proportion to
the volume of the strata. Thus, each stratum will contain <span class="math notranslate nohighlight">\(round(V_i*nsamples)\)</span> samples where
<span class="math notranslate nohighlight">\(V_i \le 1\)</span> is the volume of stratum <cite>i</cite> in the unit hypercube.</p>
<p>Either <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> must be provided.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Outputs:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method has no output, although it modifies the <cite>samplesu01</cite> and <cite>weights</cite> attributes.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.STS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#STS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.STS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes stratified sampling.</p>
<p>This method performs the sampling for each of the child classes by running two methods:
<code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code>, and <code class="docutils literal notranslate"><span class="pre">transform_samples</span></code>. The <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method is
unique to each child class and therefore must be overwritten when a new child class is defined. The
<code class="docutils literal notranslate"><span class="pre">transform_samples</span></code> method is common to all stratified sampling classes and is therefore defined by the parent
class. It does not need to be modified.</p>
<p>If <cite>nsamples</cite> or <cite>nsamples_per_stratum</cite> is provided when the class is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be
executed automatically.  If neither <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> are provided when the class is defined,
the user must call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method to perform stratified sampling.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>nsamples_per_stratum</strong> (<cite>int</cite> or <cite>list</cite>):</dt><dd><p>Specifies the number of samples in each stratum. This must be either an integer, in which case an equal
number of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the
list must be equal to the number of strata.</p>
<p>If <cite>nsamples_per_stratum</cite> is provided when the class is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be executed
automatically.  If neither <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> are provided when the class is defined, the
user must call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method to perform stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Specify the total number of samples. If <cite>nsamples</cite> is specified, the samples will be drawn in proportion to
the volume of the strata. Thus, each stratum will contain <span class="math notranslate nohighlight">\(round(V_i*nsamples)\)</span> samples where
<span class="math notranslate nohighlight">\(V_i \le 1\)</span> is the volume of stratum <cite>i</cite> in the unit hypercube.</p>
<p>If <cite>nsamples</cite> is provided when the class is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be executed
automatically.  If neither <cite>nsamples_per_stratum</cite> or <cite>nsamples</cite> are provided when the class is defined, the
user must call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method to perform stratified sampling.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Outputs:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no output, although it modifies the <cite>samples</cite>, <cite>samplesu01</cite>, and <cite>weights</cite> attributes.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.STS.transform_samples">
<code class="sig-name descname">transform_samples</code><span class="sig-paren">(</span><em class="sig-param">samples01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#STS.transform_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.STS.transform_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform samples in the unit hypercube <span class="math notranslate nohighlight">\([0, 1]^n\)</span> to the prescribed distribution using the inverse CDF.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samplesU01</strong> (<cite>ndarray</cite>):</dt><dd><p><cite>ndarray</cite> containing the generated samples on [0, 1]^dimension.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p><cite>ndarray</cite> containing the generated samples following the prescribed distribution.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.RectangularSTS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">RectangularSTS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">strata_object</em>, <em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">sts_criterion='random'</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularSTS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularSTS" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes Stratified Sampling using Rectangular Stratification.</p>
<p><code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code> is a child class of <code class="docutils literal notranslate"><span class="pre">STS</span></code>. <code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code> takes in all parameters defined in the parent
<code class="docutils literal notranslate"><span class="pre">STS</span></code> class with differences note below. Only those inputs and attributes that differ from the parent class are
listed below. See documentation for <code class="docutils literal notranslate"><span class="pre">STS</span></code> for additional details.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>strata_object</strong> (<code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code> object):</dt><dd><p>The <cite>strata_object</cite> for <code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code> must be an object of tyhe <code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code> class.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>sts_criterion</strong> (<cite>str</cite>):</dt><dd><p>Random or Centered samples inside the rectangular strata.
Options:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>‘random’ - Samples are drawn randomly within the strata.</p></li>
<li><p>‘centered’ - Samples are drawn at the center of the strata.</p></li>
</ol>
</div></blockquote>
<p>Default: ‘random’</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.RectangularSTS.create_samplesu01">
<code class="sig-name descname">create_samplesu01</code><span class="sig-paren">(</span><em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularSTS.create_samplesu01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularSTS.create_samplesu01" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class to generate samples in rectangular strata on the
unit hypercube. It has the same inputs and outputs as the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class. See
the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class for additional details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.VoronoiSTS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">VoronoiSTS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">strata_object</em>, <em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiSTS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiSTS" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes Stratified Sampling using Voronoi Stratification.</p>
<p><code class="docutils literal notranslate"><span class="pre">VoronoiSTS</span></code> is a child class of <code class="docutils literal notranslate"><span class="pre">STS</span></code>. <code class="docutils literal notranslate"><span class="pre">VoronoiSTS</span></code> takes in all parameters defined in the parent
<code class="docutils literal notranslate"><span class="pre">STS</span></code> class with differences note below. Only those inputs and attributes that differ from the parent class are
listed below. See documentation for <code class="docutils literal notranslate"><span class="pre">STS</span></code> for additional details.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>strata_object</strong> (<code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code> object):</dt><dd><p>The <cite>strata_object</cite> for <code class="docutils literal notranslate"><span class="pre">VoronoiSTS</span></code> must be an object of the <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code> class.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiSTS.create_samplesu01">
<code class="sig-name descname">create_samplesu01</code><span class="sig-paren">(</span><em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiSTS.create_samplesu01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiSTS.create_samplesu01" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class to generate samples in Voronoi strata on the
unit hypercube. It has the same inputs and outputs as the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class. See
the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class for additional details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.DelaunaySTS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">DelaunaySTS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">strata_object</em>, <em class="sig-param">nsamples_per_stratum=1</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DelaunaySTS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DelaunaySTS" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes Stratified Sampling using Delaunay Stratification.</p>
<p><code class="docutils literal notranslate"><span class="pre">DelaunaySTS</span></code> is a child class of <code class="docutils literal notranslate"><span class="pre">STS</span></code>. <code class="docutils literal notranslate"><span class="pre">DelaunaySTS</span></code> takes in all parameters defined in the parent
<code class="docutils literal notranslate"><span class="pre">STS</span></code> class with differences note below. Only those inputs and attributes that differ from the parent class are
listed below. See documentation for <code class="docutils literal notranslate"><span class="pre">STS</span></code> for additional details.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>strata_object</strong> (<code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code> object):</dt><dd><p>The <cite>strata_object</cite> for <code class="docutils literal notranslate"><span class="pre">DelaunaySTS</span></code> must be an object of the <code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code> class.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.DelaunaySTS.create_samplesu01">
<code class="sig-name descname">create_samplesu01</code><span class="sig-paren">(</span><em class="sig-param">nsamples_per_stratum=None</em>, <em class="sig-param">nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DelaunaySTS.create_samplesu01"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DelaunaySTS.create_samplesu01" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class to generate samples in Delaunay strata on the
unit hypercube. It has the same inputs and outputs as the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method in the parent class. See
the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class for additional details.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="adding-a-new-sts-class">
<h3>Adding a new <code class="docutils literal notranslate"><span class="pre">STS</span></code> class<a class="headerlink" href="#adding-a-new-sts-class" title="Permalink to this headline">¶</a></h3>
<p>Adding a new stratified sampling method first requires that an appropriate <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class exists. If the new method is based on rectangular, Voronoi, or Delaunay stratification one of the existing <code class="docutils literal notranslate"><span class="pre">Strata</span></code> classes can be used. If it relies on a different type of stratification, then a new <code class="docutils literal notranslate"><span class="pre">Strata</span></code> class must be written first. Next, the new stratified sampling method must be written as a new subclass of the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class containing a <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method that performs the stratified sampling on the unit hypercube. This method must take input that are consistent with the <code class="docutils literal notranslate"><span class="pre">create_samplesu01</span></code> method described in the <code class="docutils literal notranslate"><span class="pre">STS</span></code> class above.</p>
</div>
</div>
<div class="section" id="refined-stratified-sampling">
<h2>Refined Stratified Sampling<a class="headerlink" href="#refined-stratified-sampling" title="Permalink to this headline">¶</a></h2>
<p>Refined Stratified Sampling (RSS) is a sequential sampling procedure that adaptively refines the stratification of the parameter space to add samples. There are four variations of RSS currently available in <code class="docutils literal notranslate"><span class="pre">UQpy</span></code>. First, the procedure works with either rectangular stratification (i.e. using <code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code>) or Voronoi stratification (i.e. using <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code>). For each of these, two refinement procedures are available. The first is a randomized algorithm where strata are selected at random according to their probability weight. This algorithm is described in <a class="footnote-reference brackets" href="#id42" id="id6">11</a>. The second is a gradient-enhanced version (so-called GE-RSS) that draws samples in stata that possess both large probability weight and have high variance. This algorithm is described in <a class="footnote-reference brackets" href="#id43" id="id7">12</a>.</p>
<div class="section" id="rss-class">
<h3>RSS Class<a class="headerlink" href="#rss-class" title="Permalink to this headline">¶</a></h3>
<p>All variations of Refined Stratifed Sampling are implemented in the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class. <code class="docutils literal notranslate"><span class="pre">RSS</span></code> is the parent class that includes all Refined Stratified Sampling algorithms, which are implemented as child class, specifically <code class="docutils literal notranslate"><span class="pre">RectangularRSS</span></code> and <code class="docutils literal notranslate"><span class="pre">VoronoiRSS</span></code>. The details of these classes are provided below.</p>
<p>Extension of the RSS class for new algorithms can be accomplished by adding new a new child class with the appropriate algorithm. Depending on the type of stratification, this may require the additional development of new <code class="docutils literal notranslate"><span class="pre">Strata</span></code> and <code class="docutils literal notranslate"><span class="pre">STS</span></code> classes to accommodate the RSS. This is discussed in more details below.</p>
</div>
<div class="section" id="id8">
<h3>Class Descriptions<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.RSS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">RSS</code><span class="sig-paren">(</span><em class="sig-param">sample_object=None</em>, <em class="sig-param">runmodel_object=None</em>, <em class="sig-param">krig_object=None</em>, <em class="sig-param">local=False</em>, <em class="sig-param">max_train_size=None</em>, <em class="sig-param">step_size=0.005</em>, <em class="sig-param">qoi_name=None</em>, <em class="sig-param">n_add=1</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RSS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RSS" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class for Refined Stratified Sampling <a class="footnote-reference brackets" href="#id42" id="id9">11</a>, <a class="footnote-reference brackets" href="#id43" id="id10">12</a>.</p>
<p>This is the parent class for all refined stratified sampling methods. This parent class only provides the
framework for refined stratified sampling and cannot be used directly for the sampling. Sampling is done by
calling the child class for the desired algorithm.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>sample_object</strong> (<code class="docutils literal notranslate"><span class="pre">SampleMethods</span></code> object(s)):</dt><dd><p>Generally, this must be an object of a <code class="docutils literal notranslate"><span class="pre">UQpy.SampleMethods</span></code> class. Each child class of <code class="docutils literal notranslate"><span class="pre">RSS</span></code> has it’s
own constraints on which specific types of <code class="docutils literal notranslate"><span class="pre">SampleMethods</span></code> it can accept. These are described in the child
class documentation below.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>runmodel_object</strong> (<code class="docutils literal notranslate"><span class="pre">RunModel</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">RunModel</span></code> object, which is used to evaluate the model.</p>
<p><cite>runmodel_object</cite> is optional. If it is provided, the specific <code class="docutils literal notranslate"><span class="pre">RSS</span></code> subclass with use it to compute the
gradient of the model in each stratum for gradient-enhanced refined stratified sampling. If it is not
provided, the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> subclass will default to random stratum refinement.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>krig_object</strong> (<cite>class</cite> object):</dt><dd><p>A object defining a Kriging surrogate model, this object must have <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code> methods.</p>
<p>May be an object of the <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> <code class="docutils literal notranslate"><span class="pre">Kriging</span></code> class or an object of the <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>
<code class="docutils literal notranslate"><span class="pre">GaussianProcessRegressor</span></code></p>
<p><cite>krig_object</cite> is only used to compute the gradient in gradient-enhanced refined stratified sampling. It must
be provided if a <cite>runmodel_object</cite> is provided.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>local</strong> (<cite>Boolean</cite>):</dt><dd><p>In gradient enhanced refined stratified sampling, the gradient is updated after each new sample is added.
This parameter is used to determine whether the gradient is updated for every stratum or only locally in the
strata nearest the refined stratum.</p>
<p>If <cite>local = True</cite>, gradients are only updated in localized regions around the refined stratum.</p>
<p>Used only in gradient-enhanced refined stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>max_train_size</strong> (<cite>int</cite>):</dt><dd><p>In gradient enhanced refined stratified sampling, if <cite>local=True</cite> <cite>max_train_size</cite> specifies the number of
nearest points at which to update the gradient.</p>
<p>Used only in gradient-enhanced refined stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>step_size</strong> (<cite>float</cite>)</dt><dd><p>Defines the size of the step to use for gradient estimation using central difference method.</p>
<p>Used only in gradient-enhanced refined stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>qoi_name</strong> (<cite>dict</cite>):</dt><dd><p>Name of the quantity of interest from the <cite>runmodel_object</cite>. If the quantity of interest is a dictionary,
this is used to convert it to a list</p>
<p>Used only in gradient-enhanced refined stratified sampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Total number of samples to be drawn (including the initial samples).</p>
<p>If <cite>nsamples</cite> is provided when instantiating the class, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will automatically be called. If
<cite>nsamples</cite> is not provided, an <code class="docutils literal notranslate"><span class="pre">RSS</span></code> subclass can be executed by invoking the <code class="docutils literal notranslate"><span class="pre">run</span></code> method and passing
<cite>nsamples</cite>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
<p>Default value: False</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<p>Each of the above inputs are saved as attributes, in addition to the following created attributes.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The generated stratified samples following the prescribed distribution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samplesU01</strong> (<cite>ndarray</cite>)</dt><dd><p>The generated samples on the unit hypercube.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>weights</strong> (<cite>ndarray</cite>)</dt><dd><p>Individual sample weights.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>strata_object</strong> (Object of <code class="docutils literal notranslate"><span class="pre">Strata</span></code> subclass)</dt><dd><p>Defines the stratification of the unit hypercube. This is an object of the <code class="docutils literal notranslate"><span class="pre">Strata</span></code> subclass
corresponding to the appropriate strata type.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
</div></blockquote>
<dl class="method">
<dt id="UQpy.SampleMethods.RSS.estimate_gradient">
<code class="sig-name descname">estimate_gradient</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em>, <em class="sig-param">xt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RSS.estimate_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RSS.estimate_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimating gradients with a Kriging metamodel (surrogate).</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>x</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples in the training data.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>y</strong> (<cite>ndarray</cite>):</dt><dd><p>Function values evaluated at the samples in the training data.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>xt</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples where gradients need to be evaluated.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>gr</strong> (<cite>ndarray</cite>):</dt><dd><p>First-order gradient evaluated at the points ‘xt’ using central difference.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.RSS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RSS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RSS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the random sampling in the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is the function that performs random sampling in any <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class. If <cite>nsamples</cite> is
provided, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically called when the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> object is defined. The user may also call
the <code class="docutils literal notranslate"><span class="pre">run</span></code> method directly to generate samples. The <code class="docutils literal notranslate"><span class="pre">run</span></code> method of the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class can be invoked many
times and each time the generated samples are appended to the existing samples.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is inherited from the parent class and should not be modified by the subclass. It operates by
calling a <code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method that is uniquely defined for each subclass. All <code class="docutils literal notranslate"><span class="pre">RSS</span></code> subclasses must posses a
<code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method as defined below.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Total number of samples to be drawn.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is invoked multiple times, the newly generated samples will be appended to the
existing samples.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Return:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no returns, although it creates and/or appends the <cite>samples</cite>, <cite>samplesU01, `weights</cite>, and
<cite>strata_object</cite> attributes of the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.RSS.run_rss">
<code class="sig-name descname">run_rss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RSS.run_rss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RSS.run_rss" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is overwritten by each subclass in order to perform the refined stratified sampling.</p>
<p>This must be an instance method of the class and, although it has no returns it should appropriately modify the
following attributes of the class: <cite>samples</cite>, <cite>samplesU01</cite>, <cite>weights</cite>, <cite>strata_object</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.RectangularRSS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">RectangularRSS</code><span class="sig-paren">(</span><em class="sig-param">sample_object=None</em>, <em class="sig-param">runmodel_object=None</em>, <em class="sig-param">krig_object=None</em>, <em class="sig-param">local=False</em>, <em class="sig-param">max_train_size=None</em>, <em class="sig-param">step_size=0.005</em>, <em class="sig-param">qoi_name=None</em>, <em class="sig-param">n_add=1</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularRSS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularRSS" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes Refined Stratified Sampling using Rectangular Stratification.</p>
<p><code class="docutils literal notranslate"><span class="pre">RectangularRSS</span></code> is a child class of <code class="docutils literal notranslate"><span class="pre">RSS</span></code>. <code class="docutils literal notranslate"><span class="pre">RectangularRSS</span></code> takes in all parameters defined in the parent
<code class="docutils literal notranslate"><span class="pre">RSS</span></code> class with differences note below. Only those inputs and attributes that differ from the parent class
are listed below. See documentation for <code class="docutils literal notranslate"><span class="pre">RSS</span></code> for additional details.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>sample_object</strong> (<code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code> object):</dt><dd><p>The <cite>sample_object</cite> for <code class="docutils literal notranslate"><span class="pre">RectangularRSS</span></code> must be an object of the <code class="docutils literal notranslate"><span class="pre">RectangularSTS</span></code> class.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.RectangularRSS.gerss">
<code class="sig-name descname">gerss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularRSS.gerss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularRSS.gerss" title="Permalink to this definition">¶</a></dt>
<dd><p>This method generates samples using Gradient Enhanced Refined Stratified Sampling.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.RectangularRSS.rss">
<code class="sig-name descname">rss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularRSS.rss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularRSS.rss" title="Permalink to this definition">¶</a></dt>
<dd><p>This method generates samples using Refined Stratified Sampling.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.RectangularRSS.run_rss">
<code class="sig-name descname">run_rss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#RectangularRSS.run_rss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.RectangularRSS.run_rss" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the <code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method in the parent class to perform refined stratified sampling with rectangular
strata. It is an instance method that does not take any additional input arguments. See
the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class for additional details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="UQpy.SampleMethods.VoronoiRSS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">VoronoiRSS</code><span class="sig-paren">(</span><em class="sig-param">sample_object=None</em>, <em class="sig-param">runmodel_object=None</em>, <em class="sig-param">krig_object=None</em>, <em class="sig-param">local=False</em>, <em class="sig-param">max_train_size=None</em>, <em class="sig-param">step_size=0.005</em>, <em class="sig-param">qoi_name=None</em>, <em class="sig-param">n_add=1</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiRSS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiRSS" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes Refined Stratified Sampling using Voronoi Stratification.</p>
<p><code class="docutils literal notranslate"><span class="pre">VoronoiRSS</span></code> is a child class of <code class="docutils literal notranslate"><span class="pre">RSS</span></code>. <code class="docutils literal notranslate"><span class="pre">VoronoiRSS</span></code> takes in all parameters defined in the parent
<code class="docutils literal notranslate"><span class="pre">RSS</span></code> class with differences note below. Only those inputs and attributes that differ from the parent class
are listed below. See documentation for <code class="docutils literal notranslate"><span class="pre">RSS</span></code> for additional details.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl>
<dt><strong>sample_object</strong> (<code class="docutils literal notranslate"><span class="pre">SampleMethods</span></code> object):</dt><dd><p>The <cite>sample_object</cite> for <code class="docutils literal notranslate"><span class="pre">VoronoiRSS</span></code> can be an object of any <code class="docutils literal notranslate"><span class="pre">SampleMethods</span></code> class that possesses the
following attributes: <cite>samples</cite> and <cite>samplesU01</cite></p>
<p>This can be any <code class="docutils literal notranslate"><span class="pre">SampleMethods</span></code> object because <code class="docutils literal notranslate"><span class="pre">VoronoiRSS</span></code> creates its own <cite>strata_object</cite>. It does not use
a <cite>strata_object</cite> inherited from an <code class="docutils literal notranslate"><span class="pre">STS</span></code> object.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiRSS.gerss">
<code class="sig-name descname">gerss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiRSS.gerss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiRSS.gerss" title="Permalink to this definition">¶</a></dt>
<dd><p>This method generates samples using Gradient Enhanced Refined Stratified Sampling.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiRSS.rss">
<code class="sig-name descname">rss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiRSS.rss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiRSS.rss" title="Permalink to this definition">¶</a></dt>
<dd><p>This method generates samples using Refined Stratified Sampling.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.VoronoiRSS.run_rss">
<code class="sig-name descname">run_rss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#VoronoiRSS.run_rss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.VoronoiRSS.run_rss" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrites the <code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method in the parent class to perform refined stratified sampling with Voronoi
strata. It is an instance method that does not take any additional input arguments. See
the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class for additional details.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="adding-a-new-rss-class">
<h3>Adding a new <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class<a class="headerlink" href="#adding-a-new-rss-class" title="Permalink to this headline">¶</a></h3>
<p>New refined stratified sampling methods can be implemented by subclassing the <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class. The subclass should inherit inputs from the parent class and may also take additional inputs as necessary. Any <code class="docutils literal notranslate"><span class="pre">RSS</span></code> subclass must have a <code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method that is invoked by the <code class="docutils literal notranslate"><span class="pre">RSS.run</span></code> method. The <code class="docutils literal notranslate"><span class="pre">run_rss</span></code> method is an instance method that should not take any additional arguments and executes the refined stratifed sampling algorithm.</p>
<p>It is noted that any new <code class="docutils literal notranslate"><span class="pre">RSS</span></code> class must have a corresponding <code class="docutils literal notranslate"><span class="pre">Strata</span></code> object that defines the type of stratification and may also require a corresponding <code class="docutils literal notranslate"><span class="pre">STS</span></code> class. New <code class="docutils literal notranslate"><span class="pre">RSS</span></code> algorithms that do not utilize the existing <code class="docutils literal notranslate"><span class="pre">Strata</span></code> classes (<code class="docutils literal notranslate"><span class="pre">RectangularStrata</span></code>, <code class="docutils literal notranslate"><span class="pre">VoronoiStrata</span></code>, or <code class="docutils literal notranslate"><span class="pre">DelaunayStrata</span></code>) will require that a new <a href="#id11"><span class="problematic" id="id12">``</span></a>Strata``subclass be written.</p>
</div>
</div>
<div class="section" id="simplex">
<h2>Simplex<a class="headerlink" href="#simplex" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Simplex</span></code> class generates uniformly distributed samples inside a simplex of dimension <span class="math notranslate nohighlight">\(n_d\)</span>, whose coordinates are expressed by <span class="math notranslate nohighlight">\(\zeta_k\)</span>. First, this class generates <span class="math notranslate nohighlight">\(n_d\)</span> independent uniform random variables on [0, 1], denoted <span class="math notranslate nohighlight">\(r_q\)</span>, then maps them to the simplex as follows:</p>
<div class="math notranslate nohighlight">
\[\mathbf{M_{n_d}} = \zeta_0 + \sum_{i=1}^{n_d} \Big{[}\prod_{j=1}^{i} r_{n_d-j+1}^{\frac{1}{n_d-j+1}}\Big{]}(\zeta_i - \zeta_{i-1})\]</div>
<p>where <span class="math notranslate nohighlight">\(M_{n_d}\)</span> is an <span class="math notranslate nohighlight">\(n_d\)</span> dimensional array defining the coordinates of new sample. This mapping is illustrated below for a two-dimensional simplex.</p>
<a class="reference internal image-reference" href="_images/SampleMethods_Simplex.png"><img alt="Randomly generated point inside a 2-D simplex" class="align-center" src="_images/SampleMethods_Simplex.png" style="width: 339.0px; height: 261.0px;" /></a>
<p>Additional details can be found in <a class="footnote-reference brackets" href="#id39" id="id13">8</a>.</p>
<div class="section" id="id14">
<h3>Class Descriptions<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.Simplex">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">Simplex</code><span class="sig-paren">(</span><em class="sig-param">nodes=None</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Simplex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Simplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate uniform random samples inside an n-dimensional simplex.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>nodes</strong> (<cite>ndarray</cite> or <cite>list</cite>):</dt><dd><p>The vertices of the simplex.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>The number of samples to be generated inside the simplex.</p>
<p>If <cite>nsamples</cite> is provided when the object is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will be called automatically. If
<cite>nsamples</cite> is not provided when the object is defined, the user must invoke the <code class="docutils literal notranslate"><span class="pre">run</span></code> method and specify
<cite>nsamples</cite>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>New random samples distributed uniformly inside the simplex.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.Simplex.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Simplex.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Simplex.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the random sampling in the <code class="docutils literal notranslate"><span class="pre">Simplex</span></code> class.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is the function that performs random sampling in the <code class="docutils literal notranslate"><span class="pre">Simplex</span></code> class. If <cite>nsamples</cite> is
provided called when the <code class="docutils literal notranslate"><span class="pre">Simplex</span></code> object is defined, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically. The user may also
call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method directly to generate samples. The <code class="docutils literal notranslate"><span class="pre">run</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Simplex</span></code> class can be invoked
many times and each time the generated samples are appended to the existing samples.</p>
<p><strong>Input:</strong></p>
<ul>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be generated inside the simplex.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is invoked multiple times, the newly generated samples will be appended to the
existing samples.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Return:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no returns, although it creates and/or appends the <cite>samples</cite> attribute of the <code class="docutils literal notranslate"><span class="pre">Simplex</span></code>
class.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="akmcs">
<h2>AKMCS<a class="headerlink" href="#akmcs" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class generates samples adaptively using a specified Kriging-based learning function in a general Adaptive Kriging-Monte Carlo Sampling (AKMCS) framework. Based on the specified learning function, different objectives can be achieved. In particular, the <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class has learning functions for reliabliity analysis (probability of failure estimation), global optimization, best global fit surrogate models, and can also accept user-defined learning functions for these and other objectives.  Note that the term AKMCS is adopted from <a class="footnote-reference brackets" href="#id34" id="id15">3</a> although the procedure is referred to by different names depending on the specific learning function employed. For example, when applied for optimization the algorithm leverages the expected improvement function and is known under the name Efficient Global Optimization (EGO) <a class="footnote-reference brackets" href="#id35" id="id16">4</a>.</p>
<div class="section" id="learning-functions">
<h3>Learning Functions<a class="headerlink" href="#learning-functions" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> provides a number of built-in learning functions as well as allowing the user to proviee a custom learning function. These learning functions are described below.</p>
<div class="section" id="u-function">
<h4>U-Function<a class="headerlink" href="#u-function" title="Permalink to this headline">¶</a></h4>
<p>The U-function is a learning function adopted for Kriging-based reliability analysis adopted from <a class="footnote-reference brackets" href="#id34" id="id17">3</a>. Given a Kriging model <span class="math notranslate nohighlight">\(\hat{y}(\mathbf{x})\)</span>, point estimator of its standard devaition <span class="math notranslate nohighlight">\(\sigma_{\hat{y}}(\mathbf{x})\)</span>, and a set of learning points <span class="math notranslate nohighlight">\(S\)</span>, the U-function seeks out the point <span class="math notranslate nohighlight">\(\mathbf{x}\in S\)</span> that minimizes the function:</p>
<div class="math notranslate nohighlight">
\[U(\mathbf{x}) = \dfrac{|\hat{y}(\mathbf{x})|}{\sigma_{\hat{y}}(\mathbf{x})}\]</div>
<p>This point can be interpreted as the point in <span class="math notranslate nohighlight">\(S\)</span> where the Kriging model has the highest probabability of incorrectly identifying the sign of the performance function (i.e. incorrectly predicting the safe/fail state of the system).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> then adds the corresponding point to the training set, re-fits the Kriging model and repeats the procedure until the following stopping criterion in met:</p>
<div class="math notranslate nohighlight">
\[\min(U(\mathbf{x})) &gt; \epsilon_u\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_u\)</span> is a user-defined error threshold (typically set to 2).</p>
</div>
<div class="section" id="weighted-u-function">
<h4>Weighted U-Function<a class="headerlink" href="#weighted-u-function" title="Permalink to this headline">¶</a></h4>
<p>The probability weighted U-function is a learning function for reliability analysis adapted from the U-function in <a class="footnote-reference brackets" href="#id36" id="id18">5</a>. It modifies the U-function as follows:</p>
<div class="math notranslate nohighlight">
\[W(\mathbf{x}) = \dfrac{\max_x[p(\mathbf{x})] - p(\mathbf{x})}{\max_x[p(\mathbf{x})]} U(\mathbf{x})\]</div>
<p>where <span class="math notranslate nohighlight">\(p(\mathbf{x})\)</span> is the probability density function of <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. This has the effect of decreasing the learning function for points that have higher probability of occurrence. Thus, given two points with identical values of <span class="math notranslate nohighlight">\(U(x)\)</span>, the weighted learning function will select the point with higher probability of occurrence.</p>
<p>As with the standard U-function, <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> with the weighted U-function iterates until <span class="math notranslate nohighlight">\(\min(U(\mathbf{x})) &gt; \epsilon_u\)</span> (the same stopping criterion as the U-function).</p>
</div>
<div class="section" id="expected-feasibility-function">
<h4>Expected Feasibility Function<a class="headerlink" href="#expected-feasibility-function" title="Permalink to this headline">¶</a></h4>
<p>The Expected Feasibility Function (EFF) is a learning function for reliability analysis introduced as part of the Efficient Global Reliability Analysis (EGRA) method <a class="footnote-reference brackets" href="#id37" id="id19">6</a>. The EFF provides assesses how well the true value of the peformance function, <span class="math notranslate nohighlight">\(y(\mathbf{x})\)</span>, is expected to satisfy the constraint <span class="math notranslate nohighlight">\(y(\mathbf{x}) = a\)</span> over a region <span class="math notranslate nohighlight">\(a-\epsilon \le y(\mathbf{x}) \le a+\epsilon\)</span>. It is given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align} EFF(\mathbf{x}) &amp;= (\hat{y}(\mathbf{x})-a)\bigg[2\Phi\bigg(\dfrac{a-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) - \Phi\bigg(\dfrac{(a-\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) - \Phi\bigg(\dfrac{(a+\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) \bigg] \\ &amp;-\sigma_{\hat{y}}(\mathbf{x})\bigg[2\phi\bigg(\dfrac{a-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) - \phi\bigg(\dfrac{(a-\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) - \phi\bigg(\dfrac{(a+\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) \bigg] \\ &amp;+ \bigg[ \Phi\bigg(\dfrac{(a+\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) - \Phi\bigg(\dfrac{(a-\epsilon)-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) \bigg] \end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi(\cdot)\)</span> and <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span> are the standard normal cdf and pdf, respectively. For reliabilty, <span class="math notranslate nohighlight">\(a=0\)</span>, and it is suggest to use <span class="math notranslate nohighlight">\(\epsilon=2\sigma_{\hat{y}}^2\)</span>.</p>
<p>At each iteration, the new point that is selected is the point that maximizes the EFF and iterations continue until</p>
<div class="math notranslate nohighlight">
\[\max_x(EFF(\mathbf{x})) &lt; \epsilon_{eff}\]</div>
</div>
<div class="section" id="expected-improvement-function">
<h4>Expected Improvement Function<a class="headerlink" href="#expected-improvement-function" title="Permalink to this headline">¶</a></h4>
<p>The Expected Improvement Function (EIF) is a Kriging-based learning function for global optimization introduced as part of the Efficient Global Optimization (EGO) method in <a class="footnote-reference brackets" href="#id35" id="id20">4</a>. The EIF seeks to find the global minimum of a function. It searches the space by placing samples at locations that maximize the expected improvement, where the improvement is defined as <span class="math notranslate nohighlight">\(I(\mathbf{x})=\max(y_{min}-y(\mathbf{x}), 0)\)</span>, where the model response <span class="math notranslate nohighlight">\(y(\mathbf{x})\)</span> is assumed to be a Gaussian random variable and <span class="math notranslate nohighlight">\(y_{min}\)</span> is the current minimum model response. The EIF is then expressed as:</p>
<div class="math notranslate nohighlight">
\[EIF(\mathbf{x}) = E[I(\mathbf{x})] = (y_{min}-\hat{y}(\mathbf{x})) \Phi \bigg(\dfrac{y_{min}-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg) + \sigma_{\hat{y}}(\mathbf{x})\phi \bigg(\dfrac{y_{min}-\hat{y}(\mathbf{x})}{\sigma_{\hat{y}}(\mathbf{x})} \bigg)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi(\cdot)\)</span> and <span class="math notranslate nohighlight">\(\phi(\cdot)\)</span> are the standard normal cdf and pdf, respectively.</p>
<p>At each iteration, the EGO algorithm selects the point in the learning set that maximizes the EIF. The algorithm continues until the maximum number of iterations or until:</p>
<div class="math notranslate nohighlight">
\[\dfrac{EIF(\mathbf{x})}{|y_{min}|} &lt; \epsilon_{eif}.\]</div>
<p>Typically a value of 0.01 is used for <span class="math notranslate nohighlight">\(\epsilon_{eif}\)</span>.</p>
</div>
<div class="section" id="expected-improvement-for-global-fit">
<h4>Expected Improvement for Global Fit<a class="headerlink" href="#expected-improvement-for-global-fit" title="Permalink to this headline">¶</a></h4>
<p>The Expected Improvement for Global Fit (EIGF) learning function aims to build the surrogate model that is the best global representation of model. It was introduced in <a class="footnote-reference brackets" href="#id38" id="id21">7</a>. It aims to balance between even space-filling design and sampling in regions of high variation and is given by:</p>
<div class="math notranslate nohighlight">
\[EIGF(\mathbf{x}) = (\hat{y}(\mathbf{x}) - y(\mathbf{x}_*))^2 + \sigma_{\hat{y}}(\mathbf{x})^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{x}_*\)</span> is the point in the training set closest in distance to the point <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> and <span class="math notranslate nohighlight">\(y(\mathbf{x}_*)\)</span> is the model response at that point.</p>
<p>No stopping criterion is suggested by the authors of <a class="footnote-reference brackets" href="#id38" id="id22">7</a>, thus its implementation in <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> uses a fixed number of iterations.</p>
</div>
<div class="section" id="user-defined-learning-functions">
<h4>User-Defined Learning Functions<a class="headerlink" href="#user-defined-learning-functions" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class also allows new, user-defined learning functions to be specified in a straightforward way. This is done by creating a new method that contains the algorithm for selecting a new samples. This method takes as input the surrogate model, the randomly generated learning points, the number of points to be added in each iteration, any requisite parameters including a stopping criterion, existing samples, model evaluate at samples and distribution object. It returns a set of samples that are selected according to the user’s desired learning function and the corresponding learning function values. The outputs of this function should be (1) a numpy array of samples to be added; (2) the learning function values at the new sample points, and (3) a boolean stopping criterion indicating whether the iterations should continue (<cite>False</cite>) or stop (<cite>True</cite>). The numpy array of samples should be a two-dimensional array with the first dimension being the number of samples and the second dimension being the number of variables. An example user-defined learning function is given below:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">u_function</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="n">n_add</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">u_lf</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">u_lf</span><span class="p">,</span> <span class="n">indicator</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id23">
<h3>Class Descriptions<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.AKMCS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">AKMCS</code><span class="sig-paren">(</span><em class="sig-param">dist_object</em>, <em class="sig-param">runmodel_object</em>, <em class="sig-param">krig_object</em>, <em class="sig-param">samples=None</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nlearn=10000</em>, <em class="sig-param">nstart=None</em>, <em class="sig-param">qoi_name=None</em>, <em class="sig-param">learning_function='U'</em>, <em class="sig-param">n_add=1</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptively sample for construction of a Kriging surrogate for different objectives including reliability,
optimization, and global fit.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>runmodel_object</strong> (<code class="docutils literal notranslate"><span class="pre">RunModel</span></code> object):</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">RunModel</span></code> object, which is used to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
<p>Either <cite>samples</cite> or <cite>nstart</cite> must be provided.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>krig_object</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code> methods.</p>
<p>May be an object of the <code class="docutils literal notranslate"><span class="pre">UQpy</span></code> <code class="docutils literal notranslate"><span class="pre">Kriging</span></code> class or an object of the <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>
<code class="docutils literal notranslate"><span class="pre">GaussianProcessRegressor</span></code></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Total number of samples to be drawn (including the initial samples).</p>
<p>If <cite>nsamples</cite> is provided when instantiating the class, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method will automatically be called. If
<cite>nsamples</cite> is not provided, <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> can be executed by invoking the <code class="docutils literal notranslate"><span class="pre">run</span></code> method and passing <cite>nsamples</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nlearn</strong> (<cite>int</cite>):</dt><dd><p>Number of samples generated for evaluation of the learning function. Samples for the learning set are drawn
using <code class="docutils literal notranslate"><span class="pre">LHS</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>nstart</strong> (<cite>int</cite>):</dt><dd><p>Number of initial samples, randomly generated using <code class="docutils literal notranslate"><span class="pre">LHS</span></code>.</p>
<p>Either <cite>samples</cite> or <cite>nstart</cite> must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi_name</strong> (<cite>dict</cite>):</dt><dd><p>Name of the quantity of interest. If the quantity of interest is a dictionary, this is used to convert it to
a list</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>learning_function</strong> (<cite>str</cite> or <cite>function</cite>):</dt><dd><p>Learning function used as the selection criteria to identify new samples.</p>
<dl class="simple">
<dt>Built-in options:</dt><dd><ol class="arabic simple">
<li><p>‘U’ - U-function</p></li>
<li><p>‘EFF’ - Expected Feasibility Function</p></li>
<li><p>‘Weighted-U’ - Weighted-U function</p></li>
<li><p>‘EIF’ - Expected Improvement Function</p></li>
<li><p>‘EGIF’ - Expected Global Improvement Fit</p></li>
</ol>
</dd>
</dl>
<p><cite>learning_function</cite> may also be passed as a user-defined callable function. This function must accept a Kriging
surrogate model object with <code class="docutils literal notranslate"><span class="pre">fit</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code> methods, the set of learning points at which to evaluate the
learning function, and it may also take an arbitrary number of additional parameters that are passed to
<code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> as <cite>**kwargs</cite>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>verbose</strong> (<cite>Boolean</cite>):</dt><dd><p>A boolean declaring whether to write text to the terminal.</p>
<p>Default value: False.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>kwargs</strong></dt><dd><p>Used to pass parameters to <cite>learning_function</cite>.</p>
<p>For built-in <cite>learning_functions</cite>, see the requisite inputs in the method list below.</p>
<p>For user-defined <cite>learning_functions</cite>, these will be defined by the requisite inputs to the user-defined method.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p><cite>ndarray</cite> containing the samples at which the model is evaluated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>lf_values</strong> (<cite>list</cite>)</dt><dd><p>The learning function evaluated at new sample points.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.eff">
<em class="property">static </em><code class="sig-name descname">eff</code><span class="sig-paren">(</span><em class="sig-param">surr</em>, <em class="sig-param">pop</em>, <em class="sig-param">n_add</em>, <em class="sig-param">parameters</em>, <em class="sig-param">samples</em>, <em class="sig-param">qoi</em>, <em class="sig-param">dist_object</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.eff" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected Feasibility Function (EFF) for reliability analysis, see <a class="footnote-reference brackets" href="#id37" id="id24">6</a> for a detailed explanation.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>surr</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have a <code class="docutils literal notranslate"><span class="pre">predict</span></code> method as defined in <cite>krig_object</cite> parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pop</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of samples defining the learning set at which points the EFF is evaluated</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>parameters</strong> (<cite>dictionary</cite>)</dt><dd><p>Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here
these include <cite>a</cite>, <cite>epsilon</cite>, and <cite>eff_stop</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi</strong> (<cite>list</cite>):</dt><dd><p>A list, which contaains the model evaluations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>new_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples selected for model evaluation.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>indicator</strong> (<cite>boolean</cite>):</dt><dd><p>Indicator for stopping criteria.</p>
<p><cite>indicator = True</cite> specifies that the stopping criterion has been met and the AKMCS.run method stops.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>eff_lf</strong> (<cite>ndarray</cite>)</dt><dd><p>EFF learning function evaluated at the new sample points.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.eif">
<em class="property">static </em><code class="sig-name descname">eif</code><span class="sig-paren">(</span><em class="sig-param">surr</em>, <em class="sig-param">pop</em>, <em class="sig-param">n_add</em>, <em class="sig-param">parameters</em>, <em class="sig-param">samples</em>, <em class="sig-param">qoi</em>, <em class="sig-param">dist_object</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.eif"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.eif" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected Improvement Function (EIF) for Efficient Global Optimization (EFO). See <a class="footnote-reference brackets" href="#id35" id="id25">4</a> for a detailed
explanation.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>surr</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have a <code class="docutils literal notranslate"><span class="pre">predict</span></code> method as defined in <cite>krig_object</cite> parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pop</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of samples defining the learning set at which points the EIF is evaluated</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>parameters</strong> (<cite>dictionary</cite>)</dt><dd><p>Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here
this includes the parameter <cite>eif_stop</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi</strong> (<cite>list</cite>):</dt><dd><p>A list, which contaains the model evaluations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>new_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples selected for model evaluation.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>indicator</strong> (<cite>boolean</cite>):</dt><dd><p>Indicator for stopping criteria.</p>
<p><cite>indicator = True</cite> specifies that the stopping criterion has been met and the AKMCS.run method stops.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>eif_lf</strong> (<cite>ndarray</cite>)</dt><dd><p>EIF learning function evaluated at the new sample points.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.eigf">
<em class="property">static </em><code class="sig-name descname">eigf</code><span class="sig-paren">(</span><em class="sig-param">surr</em>, <em class="sig-param">pop</em>, <em class="sig-param">n_add</em>, <em class="sig-param">parameters</em>, <em class="sig-param">samples</em>, <em class="sig-param">qoi</em>, <em class="sig-param">dist_object</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.eigf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.eigf" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected Improvement for Global Fit (EIGF) learning function. See <a class="footnote-reference brackets" href="#id38" id="id26">7</a> for a detailed explanation.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>surr</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have a <code class="docutils literal notranslate"><span class="pre">predict</span></code> method as defined in <cite>krig_object</cite> parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pop</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of samples defining the learning set at which points the EIGF is evaluated</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>parameters</strong> (<cite>dictionary</cite>)</dt><dd><p>Dictionary containing all necessary parameters and the stopping criterion for the learning function. For
<code class="docutils literal notranslate"><span class="pre">EIGF</span></code>, this dictionary is empty as no stopping criterion is specified.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi</strong> (<cite>list</cite>):</dt><dd><p>A list, which contaains the model evaluations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>new_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples selected for model evaluation.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>indicator</strong> (<cite>boolean</cite>):</dt><dd><p>Indicator for stopping criteria.</p>
<p><cite>indicator = True</cite> specifies that the stopping criterion has been met and the AKMCS.run method stops.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>eigf_lf</strong> (<cite>ndarray</cite>)</dt><dd><p>EIGF learning function evaluated at the new sample points.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em>, <em class="sig-param">samples=None</em>, <em class="sig-param">append_samples=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> learning iterations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method is the function that performs iterations in the <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class. If <cite>nsamples</cite> is
provided when defining the <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> object, the <code class="docutils literal notranslate"><span class="pre">run</span></code> method is automatically called. The user may also
call the <code class="docutils literal notranslate"><span class="pre">run</span></code> method directly to generate samples. The <code class="docutils literal notranslate"><span class="pre">run</span></code> method of the <code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class can be invoked
many times.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Total number of samples to be drawn (including the initial samples).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>append_samples</strong> (<cite>boolean</cite>)</dt><dd><p>Append new samples and model evaluations to the existing samples and model evaluations.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">append_samples</span> <span class="pre">=</span> <span class="pre">False</span></code>, all previous samples and the corresponding quantities of interest from their
model evaluations are deleted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">append_samples</span> <span class="pre">=</span> <span class="pre">True</span></code>, samples and their resulting quantities of interest are appended to the
existing ones.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">run</span></code> method has no returns, although it creates and/or appends the <cite>samples</cite> attribute of the
<code class="docutils literal notranslate"><span class="pre">AKMCS</span></code> class.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.u">
<em class="property">static </em><code class="sig-name descname">u</code><span class="sig-paren">(</span><em class="sig-param">surr</em>, <em class="sig-param">pop</em>, <em class="sig-param">n_add</em>, <em class="sig-param">parameters</em>, <em class="sig-param">samples</em>, <em class="sig-param">qoi</em>, <em class="sig-param">dist_object</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.u" title="Permalink to this definition">¶</a></dt>
<dd><p>U-function for reliability analysis. See [3] for a detailed explanation.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>surr</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have a <code class="docutils literal notranslate"><span class="pre">predict</span></code> method as defined in <cite>krig_object</cite> parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pop</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of samples defining the learning set at which points the U-function is evaluated</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>parameters</strong> (<cite>dictionary</cite>)</dt><dd><p>Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here
this includes the parameter <cite>u_stop</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi</strong> (<cite>list</cite>):</dt><dd><p>A list, which contaains the model evaluations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>new_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples selected for model evaluation.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>indicator</strong> (<cite>boolean</cite>):</dt><dd><p>Indicator for stopping criteria.</p>
<p><cite>indicator = True</cite> specifies that the stopping criterion has been met and the AKMCS.run method stops.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>u_lf</strong> (<cite>ndarray</cite>)</dt><dd><p>U learning function evaluated at the new sample points.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.AKMCS.weighted_u">
<em class="property">static </em><code class="sig-name descname">weighted_u</code><span class="sig-paren">(</span><em class="sig-param">surr</em>, <em class="sig-param">pop</em>, <em class="sig-param">n_add</em>, <em class="sig-param">parameters</em>, <em class="sig-param">samples</em>, <em class="sig-param">qoi</em>, <em class="sig-param">dist_object</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#AKMCS.weighted_u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.AKMCS.weighted_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability Weighted U-function for reliability analysis. See <a class="footnote-reference brackets" href="#id36" id="id27">5</a> for a detailed explanation.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>surr</strong> (<cite>class</cite> object):</dt><dd><p>A Kriging surrogate model, this object must have a <code class="docutils literal notranslate"><span class="pre">predict</span></code> method as defined in <cite>krig_object</cite> parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pop</strong> (<cite>ndarray</cite>):</dt><dd><p>An array of samples defining the learning set at which points the weighted U-function is evaluated</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>n_add</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to be added per iteration.</p>
<p>Default: 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>parameters</strong> (<cite>dictionary</cite>)</dt><dd><p>Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here
this includes the parameter <cite>u_stop</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>The initial samples at which to evaluate the model.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>qoi</strong> (<cite>list</cite>):</dt><dd><p>A list, which contaains the model evaluations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>dist_object</strong> ((list of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>List of <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> objects corresponding to each random variable.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>new_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Samples selected for model evaluation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>w_lf</strong> (<cite>ndarray</cite>)</dt><dd><p>Weighted U learning function evaluated at the new sample points.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>indicator</strong> (<cite>boolean</cite>):</dt><dd><p>Indicator for stopping criteria.</p>
<p><cite>indicator = True</cite> specifies that the stopping criterion has been met and the AKMCS.run method stops.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="mcmc">
<h2>MCMC<a class="headerlink" href="#mcmc" title="Permalink to this headline">¶</a></h2>
<p>The goal of Markov Chain Monte Carlo is to draw samples from some probability distribution <span class="math notranslate nohighlight">\(p(x)=\frac{\tilde{p}(x)}{Z}\)</span>, where <span class="math notranslate nohighlight">\(\tilde{p}(x)\)</span> is known but <span class="math notranslate nohighlight">\(Z\)</span> is hard to compute (this will often be the case when using Bayes’ theorem for instance). In order to do this, the theory of a Markov chain, a stochastic model that describes a sequence of states in which the probability of a state depends only on the previous state, is combined with a Monte Carlo simulation method, see e.g. (<a class="footnote-reference brackets" href="#id32" id="id28">1</a>, <a class="footnote-reference brackets" href="#id33" id="id29">2</a>). More specifically, a Markov Chain is built and sampled from whose stationary distribution is the target distribution <span class="math notranslate nohighlight">\(p(x)\)</span>.  For instance, the Metropolis-Hastings (MH) algorithm goes as follows:</p>
<ul class="simple">
<li><p>initialize with a seed sample <span class="math notranslate nohighlight">\(x_{0}\)</span></p></li>
<li><dl class="simple">
<dt>walk the chain: for <span class="math notranslate nohighlight">\(k=0,...\)</span> do:</dt><dd><ul>
<li><p>sample candidate <span class="math notranslate nohighlight">\(x^{\star} \sim Q(\cdot \vert x_{k})\)</span> for a given Markov transition probability <span class="math notranslate nohighlight">\(Q\)</span></p></li>
<li><p>accept candidate (set <span class="math notranslate nohighlight">\(x_{k+1}=x^{\star}\)</span>) with probability <span class="math notranslate nohighlight">\(\alpha(x^{\star} \vert x_{k})\)</span>, otherwise propagate last sample <span class="math notranslate nohighlight">\(x_{k+1}=x_{k}\)</span>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\alpha(x^{\star} \vert x_{k}):= \min \left\{ \frac{\tilde{p}(x^{\star})}{\tilde{p}(x)}\cdot \frac{Q(x \vert x^{\star})}{Q(x^{\star} \vert x)}, 1 \right\}\]</div>
<p>The transition probability <span class="math notranslate nohighlight">\(Q\)</span> is chosen by the user (see input <cite>proposal</cite> of the MH algorithm, and careful attention must be given to that choice as it plays a major role in the accuracy and efficiency of the algorithm. The following figure shows samples accepted (blue) and rejected (red) when trying to sample from a 2d Gaussian distribution using MH, for different scale parameters of the proposal distribution. If the scale is too small, the space is not well explored; if the scale is too large, many candidate samples will be rejected, yielding a very inefficient algorithm. As a rule of thumb, an acceptance rate of 10%-50% could be targeted (see <cite>Diagnostics</cite> in the <cite>Utilities</cite> module).</p>
<a class="reference internal image-reference" href="_images/SampleMethods_MCMC_samples.png"><img alt="IS weighted samples" class="align-center" src="_images/SampleMethods_MCMC_samples.png" style="width: 740.8000000000001px; height: 256.0px;" /></a>
<p>Finally, samples from the target distribution will be generated only when the chain has converged to its stationary distribution, after a so-called burn-in period. Thus the user would often reject the first few samples (see input <cite>nburn</cite>). Also, the chain yields correlated samples; thus to obtain i.i.d. samples from the target distribution, the user should keep only one out of n samples (see input <cite>jump</cite>). This means that the code will perform in total nburn + jump * N evaluations of the target pdf to yield N i.i.d. samples from the target distribution (for the MH algorithm with a single chain).</p>
<p>The parent class for all MCMC algorithms is the <code class="docutils literal notranslate"><span class="pre">MCMC</span> <span class="pre">class</span></code>, which defines the inputs that are common to all MCMC algorithms, along with the <code class="docutils literal notranslate"><span class="pre">run</span></code> method that is being called to run the chain. Any given MCMC algorithm is a child class of MCMC that overwrites the main <code class="docutils literal notranslate"><span class="pre">run_one_iteration</span></code> method.</p>
<div class="section" id="adding-new-mcmc-algorithms">
<h3>Adding New MCMC Algorithms<a class="headerlink" href="#adding-new-mcmc-algorithms" title="Permalink to this headline">¶</a></h3>
<p>In order to add a new MCMC algorithm, a user must create a child class of <code class="docutils literal notranslate"><span class="pre">MCMC</span></code>, and overwrite the <code class="docutils literal notranslate"><span class="pre">run_one_iteration</span></code> method that propagates all the chains forward one iteration. Such a new class may use any number of additional inputs compared to the <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> base class. The reader is encouraged to have a look at the <code class="docutils literal notranslate"><span class="pre">MH</span></code> class and its code to better understand how a particular algorithm should fit the general framework.</p>
<p>A useful note is that the user has access to a number of useful attributes / utility methods as the algorithm proceeds, such as:</p>
<ul class="simple">
<li><p>the attribute <code class="docutils literal notranslate"><span class="pre">evaluate_log_target</span></code> (and possibly <code class="docutils literal notranslate"><span class="pre">evaluate_log_target_marginals</span></code> if marginals were provided) is created at initialization. It is a callable that simply evaluates the log-pdf of the target distribution at a given point <cite>x</cite>. It can be called within the code of a new sampler as <code class="docutils literal notranslate"><span class="pre">log_pdf_value</span> <span class="pre">=</span> <span class="pre">self.evaluate_log_target(x)</span></code>.</p></li>
<li><p>the <cite>nsamples</cite> and <cite>nsamples_per_chain</cite> attributes indicate the number of samples that have been stored up to the current iteration (i.e., they are updated dynamically as the algorithm proceeds),</p></li>
<li><p>the <cite>samples</cite> attribute contains all previously stored samples. Cautionary note: <cite>self.samples</cite> also contains trailing zeros, for samples yet to be stored, thus to access all previously stored samples at a given iteration the user must call <code class="docutils literal notranslate"><span class="pre">self.samples[:self.nsamples_per_chain]</span></code>, which will return an <cite>ndarray</cite> of size (self.nsamples_per_chain, self.nchains, self.dimension) ,</p></li>
<li><p>the <cite>log_pdf_values</cite> attribute contains all previously stored log target values. Same cautionary note as above,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">_update_acceptance_rate</span></code> method updates the <cite>acceptance_rate</cite> attribute of the sampler, given a (list of) boolean(s) indicating if the candidate state(s) were accepted at a given iteration,</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">_check_methods_proposal</span></code> method checks whether a given proposal is adequate (i.e., has <code class="docutils literal notranslate"><span class="pre">rvs</span></code> and <code class="docutils literal notranslate"><span class="pre">log_pdf</span></code>/<code class="docutils literal notranslate"><span class="pre">pdf</span></code> methods).</p></li>
</ul>
</div>
<div class="section" id="id30">
<h3>Class Descriptions<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.MCMC">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">MCMC</code><span class="sig-paren">(</span><em class="sig-param">dimension=None</em>, <em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">nchains=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo.</p>
<p>This is the parent class for all MCMC algorithms. This parent class only provides the framework for MCMC and cannot
be used directly for sampling. Sampling is done by calling the child class for the specific MCMC algorithm.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>dimension</strong> (<cite>int</cite>):</dt><dd><p>A scalar value defining the dimension of target density function. Either <cite>dimension</cite> and <cite>nchains</cite> or <cite>seed</cite>
must be provided.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>pdf_target</strong> ((<cite>list</cite> of) callables):</dt><dd><p>Target density function from which to draw random samples. Either <cite>pdf_target</cite> or <cite>log_pdf_target</cite> must be
provided (the latter should be preferred for better numerical stability).</p>
<p>If <cite>pdf_target</cite> is a callable, it refers to the joint pdf to sample from, it must take at least one input <cite>x</cite>,
which are the point(s) at which to evaluate the pdf. Within MCMC the <cite>pdf_target</cite> is evaluated as:
<code class="docutils literal notranslate"><span class="pre">p(x)</span> <span class="pre">=</span> <span class="pre">pdf_target(x,</span> <span class="pre">*args_target)</span></code></p>
<p>where <cite>x</cite> is a ndarray of shape (nsamples, dimension) and <cite>args_target</cite> are additional positional arguments that
are provided to MCMC via its <cite>args_target</cite> input.</p>
<p>If <cite>pdf_target</cite> is a list of callables, it refers to independent marginals to sample from. The marginal in
dimension <cite>j</cite> is evaluated as: <code class="docutils literal notranslate"><span class="pre">p_j(xj)</span> <span class="pre">=</span> <span class="pre">pdf_target[j](xj,</span> <span class="pre">*args_target[j])</span></code> where <cite>x</cite> is a ndarray of shape
(nsamples, dimension)</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>log_pdf_target</strong> ((<cite>list</cite> of) callables):</dt><dd><p>Logarithm of the target density function from which to draw random samples. Either <cite>pdf_target</cite> or
<cite>log_pdf_target</cite> must be provided (the latter should be preferred for better numerical stability).</p>
<p>Same comments as for input <cite>pdf_target</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>args_target</strong> ((<cite>list</cite> of) <cite>tuple</cite>):</dt><dd><p>Positional arguments of the pdf / log-pdf target function. See <cite>pdf_target</cite></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>seed</strong> (<cite>ndarray</cite>):</dt><dd><p>Seed of the Markov chain(s), shape <code class="docutils literal notranslate"><span class="pre">(nchains,</span> <span class="pre">dimension)</span></code>. Default: zeros(<cite>nchains</cite> x <cite>dimension</cite>).</p>
<p>If <cite>seed</cite> is not provided, both <cite>nchains</cite> and <cite>dimension</cite> must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nburn</strong> (<cite>int</cite>):</dt><dd><p>Length of burn-in - i.e., number of samples at the beginning of the chain to discard (note: no thinning during
burn-in). Default is 0, no burn-in.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>jump</strong> (<cite>int</cite>):</dt><dd><p>Thinning parameter, used to reduce correlation between samples. Setting <cite>jump=n</cite> corresponds to skipping <cite>n-1</cite>
states between accepted states of the chain. Default is 1 (no thinning).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nchains</strong> (<cite>int</cite>):</dt><dd><p>The number of Markov chains to generate. Either <cite>dimension</cite> and <cite>nchains</cite> or <cite>seed</cite> must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>save_log_pdf</strong> (<cite>bool</cite>):</dt><dd><p>Boolean that indicates whether to save log-pdf values along with the samples. Default: False</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>boolean</cite>)</dt><dd><p>Set <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">=</span> <span class="pre">True</span></code> to print status messages to the terminal during execution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>concat_chains</strong> (<cite>bool</cite>):</dt><dd><p>Boolean that indicates whether to concatenate the chains after a run, i.e., samples are stored as an <cite>ndarray</cite>
of shape (nsamples * nchains, dimension) if True, (nsamples, nchains, dimension) if False. Default: True</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>)</dt><dd><p>Set of MCMC samples following the target distribution, <cite>ndarray</cite> of shape (<cite>nsamples</cite> * <cite>nchains</cite>, <cite>dimension</cite>)
or (nsamples, nchains, dimension) (see input <cite>concat_chains</cite>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>log_pdf_values</strong> (<cite>ndarray</cite>)</dt><dd><p>Values of the log pdf for the accepted samples, <cite>ndarray</cite> of shape (nchains * nsamples,) or (nsamples, nchains)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>list</cite>)</dt><dd><p>Total number of samples; The <cite>nsamples</cite> attribute tallies the total number of generated samples. After each
iteration, it is updated by 1. At the end of the simulation, the <cite>nsamples</cite> attribute equals the user-specified
value for input <cite>nsamples</cite> given to the child class.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsamples_per_chain</strong> (<cite>list</cite>)</dt><dd><p>Total number of samples per chain; Similar to the attribute <cite>nsamples</cite>, it is updated during iterations as new
samples are saved.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>niterations</strong> (<cite>list</cite>)</dt><dd><p>Total number of iterations, updated on-the-fly as the algorithm proceeds. It is related to number of samples as
niterations=nburn+jump*nsamples_per_chain.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>acceptance_rate</strong> (<cite>list</cite>)</dt><dd><p>Acceptance ratio of the MCMC chains, computed separately for each chain.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.MCMC.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCMC.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCMC.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the MCMC algorithm.</p>
<p>This function samples from the MCMC chains and appends samples to existing ones (if any). This method leverages
the <code class="docutils literal notranslate"><span class="pre">run_iterations</span></code> method that is specific to each algorithm.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to generate.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsamples_per_chain</strong> (<cite>int</cite>)</dt><dd><p>Number of samples to generate per chain.</p>
</dd>
</dl>
</li>
</ul>
<p>Either <cite>nsamples</cite> or <cite>nsamples_per_chain</cite> must be provided (not both). Not that if <cite>nsamples</cite> is not a multiple
of <cite>nchains</cite>, <cite>nsamples</cite> is set to the next largest integer that is a multiple of <cite>nchains</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.MCMC.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MCMC.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MCMC.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC algorithm, starting at <cite>current_state</cite>.</p>
<p>This method is over-written for each different MCMC algorithm. It must return the new state and associated
log-pdf, which will be passed as inputs to the <code class="docutils literal notranslate"><span class="pre">run_one_iteration</span></code> method at the next iteration.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>current_state</strong> (<cite>ndarray</cite>):</dt><dd><p>Current state of the chain(s), <cite>ndarray</cite> of shape <code class="docutils literal notranslate"><span class="pre">(nchains,</span> <span class="pre">dimension)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>current_log_pdf</strong> (<cite>ndarray</cite>):</dt><dd><p>Log-pdf of the current state of the chain(s), <cite>ndarray</cite> of shape <code class="docutils literal notranslate"><span class="pre">(nchains,</span> <span class="pre">)</span></code>.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Outputs/Returns:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>new_state</strong> (<cite>ndarray</cite>):</dt><dd><p>New state of the chain(s), <cite>ndarray</cite> of shape <code class="docutils literal notranslate"><span class="pre">(nchains,</span> <span class="pre">dimension)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>new_log_pdf</strong> (<cite>ndarray</cite>):</dt><dd><p>Log-pdf of the new state of the chain(s), <cite>ndarray</cite> of shape <code class="docutils literal notranslate"><span class="pre">(nchains,</span> <span class="pre">)</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

<div class="section" id="mh">
<h4>MH<a class="headerlink" href="#mh" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="UQpy.SampleMethods.MH">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">MH</code><span class="sig-paren">(</span><em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em>, <em class="sig-param">nchains=None</em>, <em class="sig-param">proposal=None</em>, <em class="sig-param">proposal_is_symmetric=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MH" title="Permalink to this definition">¶</a></dt>
<dd><p>Metropolis-Hastings algorithm</p>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><p>Gelman et al., “Bayesian data analysis”, Chapman and Hall/CRC, 2013</p></li>
<li><p>R.C. Smith, “Uncertainty Quantification - Theory, Implementation and Applications”, CS&amp;E, 2014</p></li>
</ol>
<p><strong>Algorithm-specific inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>proposal</strong> (<code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object):</dt><dd><p>Proposal distribution, must have a log_pdf/pdf and rvs method. Default: standard multivariate normal</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>proposal_is_symmetric</strong> (<cite>bool</cite>):</dt><dd><p>Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha
Default: False, set to True if default proposal is used</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.MH.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MH.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MH.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC chain for MH algorithm, starting at current state - see <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mmh">
<h4>MMH<a class="headerlink" href="#mmh" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="UQpy.SampleMethods.MMH">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">MMH</code><span class="sig-paren">(</span><em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em>, <em class="sig-param">proposal=None</em>, <em class="sig-param">proposal_is_symmetric=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">nchains=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MMH"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MMH" title="Permalink to this definition">¶</a></dt>
<dd><p>Component-wise Modified Metropolis-Hastings algorithm.</p>
<p>In this algorithm, candidate samples are drawn separately in each dimension, thus the proposal consists of a list
of 1d distributions. The target pdf can be given as a joint pdf or a list of marginal pdfs in all dimensions. This
will trigger two different algorithms.</p>
<p><strong>References:</strong></p>
<ol class="arabic simple">
<li><p>S.-K. Au and J. L. Beck,“Estimation of small failure probabilities in high dimensions by subset simulation,”
Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263–277, Oct. 2001.</p></li>
</ol>
<p><strong>Algorithm-specific inputs:</strong></p>
<ul>
<li><dl>
<dt><strong>proposal</strong> ((<cite>list</cite> of) <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object(s)):</dt><dd><p>Proposal distribution(s) in one dimension, must have a log_pdf/pdf and rvs method.</p>
<p>The proposal object may be a list of <code class="docutils literal notranslate"><span class="pre">DistributionContinuous1D</span></code> objects or a <code class="docutils literal notranslate"><span class="pre">JointInd</span></code> object.
Default: standard normal</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>proposal_is_symmetric</strong> ((<cite>list</cite> of) <cite>bool</cite>):</dt><dd><p>Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha
Default: False, set to True if default proposal is used</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.MMH.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#MMH.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.MMH.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC chain for MMH algorithm, starting at current state - see <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="stretch">
<h4>Stretch<a class="headerlink" href="#stretch" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="UQpy.SampleMethods.Stretch">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">Stretch</code><span class="sig-paren">(</span><em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em>, <em class="sig-param">scale=2.0</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">nchains=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Stretch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Stretch" title="Permalink to this definition">¶</a></dt>
<dd><p>Affine-invariant sampler with Stretch moves, parallel implementation.</p>
<p><strong>References:</strong></p>
<ol class="arabic simple">
<li><p>J. Goodman and J. Weare, “Ensemble samplers with affine invariance,” Commun. Appl. Math. Comput. Sci.,vol.5,
no. 1, pp. 65–80, 2010.</p></li>
<li><p>Daniel Foreman-Mackey, David W. Hogg, Dustin Lang, and Jonathan Goodman. “emcee: The MCMC Hammer”.
Publications of the Astronomical Society of the Pacific, 125(925):306–312,2013.</p></li>
</ol>
<p><strong>Algorithm-specific inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>scale</strong> (<cite>float</cite>):</dt><dd><p>Scale parameter. Default: 2.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.Stretch.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#Stretch.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.Stretch.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC chain for Stretch algorithm, starting at current state - see <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dram">
<h4>DRAM<a class="headerlink" href="#dram" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="UQpy.SampleMethods.DRAM">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">DRAM</code><span class="sig-paren">(</span><em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em>, <em class="sig-param">initial_covariance=None</em>, <em class="sig-param">k0=100</em>, <em class="sig-param">sp=None</em>, <em class="sig-param">gamma_2=0.2</em>, <em class="sig-param">save_covariance=False</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">nchains=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DRAM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DRAM" title="Permalink to this definition">¶</a></dt>
<dd><p>Delayed Rejection Adaptive Metropolis algorithm</p>
<p>In this algorithm, the proposal density is Gaussian and its covariance C is being updated from samples as
C = sp * C_sample where C_sample is the sample covariance. Also, the delayed rejection scheme is applied, i.e,
if a candidate is not accepted another one is generated from the proposal with covariance gamma_2 ** 2 * C.</p>
<p><strong>References:</strong></p>
<ol class="arabic simple">
<li><p>Heikki Haario, Marko Laine, Antonietta Mira, and Eero Saksman. “DRAM: Efficient adaptive MCMC”. Statistics
and Computing, 16(4):339–354, 2006</p></li>
<li><p>R.C. Smith, “Uncertainty Quantification - Theory, Implementation and Applications”, CS&amp;E, 2014</p></li>
</ol>
<p><strong>Algorithm-specific inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>initial_cov</strong> (<cite>ndarray</cite>):</dt><dd><p>Initial covariance for the gaussian proposal distribution. Default: I(dim)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>k0</strong> (<cite>int</cite>):</dt><dd><p>Rate at which covariance is being updated, i.e., every k0 iterations. Default: 100</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>sp</strong> (<cite>float</cite>):</dt><dd><p>Scale parameter for covariance updating. Default: 2.38 ** 2 / dim</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>gamma_2</strong> (<cite>float</cite>):</dt><dd><p>Scale parameter for delayed rejection. Default: 1 / 5</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>save_cov</strong> (<cite>bool</cite>):</dt><dd><p>If True, updated covariance is saved in attribute <cite>adaptive_covariance</cite>. Default: False</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.DRAM.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DRAM.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DRAM.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC chain for DRAM algorithm, starting at current state - see <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dream">
<h4>DREAM<a class="headerlink" href="#dream" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="UQpy.SampleMethods.DREAM">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">DREAM</code><span class="sig-paren">(</span><em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">nburn=0</em>, <em class="sig-param">jump=1</em>, <em class="sig-param">dimension=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">save_log_pdf=False</em>, <em class="sig-param">concat_chains=True</em>, <em class="sig-param">nsamples=None</em>, <em class="sig-param">nsamples_per_chain=None</em>, <em class="sig-param">delta=3</em>, <em class="sig-param">c=0.1</em>, <em class="sig-param">c_star=1e-06</em>, <em class="sig-param">n_cr=3</em>, <em class="sig-param">p_g=0.2</em>, <em class="sig-param">adapt_cr=(-1</em>, <em class="sig-param">1)</em>, <em class="sig-param">check_chains=(-1</em>, <em class="sig-param">1)</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">nchains=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DREAM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DREAM" title="Permalink to this definition">¶</a></dt>
<dd><p>DiffeRential Evolution Adaptive Metropolis algorithm</p>
<p><strong>References:</strong></p>
<ol class="arabic simple">
<li><p>J.A. Vrugt et al. “Accelerating Markov chain Monte Carlo simulation by differential evolution with
self-adaptive randomized subspace sampling”. International Journal of Nonlinear Sciences and Numerical
Simulation, 10(3):273–290, 2009.[68]</p></li>
<li><p>J.A. Vrugt. “Markov chain Monte Carlo simulation using the DREAM software package: Theory, concepts, and
MATLAB implementation”. Environmental Modelling &amp; Software, 75:273–316, 2016.</p></li>
</ol>
<p><strong>Algorithm-specific inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>delta</strong> (<cite>int</cite>):</dt><dd><p>Jump rate. Default: 3</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>c</strong> (<cite>float</cite>):</dt><dd><p>Differential evolution parameter. Default: 0.1</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>c_star</strong> (<cite>float</cite>):</dt><dd><p>Differential evolution parameter, should be small compared to width of target. Default: 1e-6</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>n_cr</strong> (<cite>int</cite>):</dt><dd><p>Number of crossover probabilities. Default: 3</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>p_g</strong> (<cite>float</cite>):</dt><dd><p>Prob(gamma=1). Default: 0.2</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>adapt_cr</strong> (<cite>tuple</cite>):</dt><dd><p>(iter_max, rate) governs adaptation of crossover probabilities (adapts every rate iterations if iter&lt;iter_max).
Default: (-1, 1), i.e., no adaptation</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>check_chains</strong> (<cite>tuple</cite>):</dt><dd><p>(iter_max, rate) governs discarding of outlier chains (discard every rate iterations if iter&lt;iter_max).
Default: (-1, 1), i.e., no check on outlier chains</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.DREAM.check_outlier_chains">
<code class="sig-name descname">check_outlier_chains</code><span class="sig-paren">(</span><em class="sig-param">replace_with_best=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DREAM.check_outlier_chains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DREAM.check_outlier_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check outlier chains in DREAM algorithm.</p>
<p>This function checks for outlier chains as part of the DREAM algorithm, potentially replacing outlier chains
(i.e. the samples and log_pdf_values) with ‘good’ chains. The function does not have any returned output but it
prints out the number of outlier chains.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>replace_with_best</strong> (<cite>bool</cite>):</dt><dd><p>Indicates whether to replace outlier chains with the best (most probable) chain. Default: False</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.DREAM.run_one_iteration">
<code class="sig-name descname">run_one_iteration</code><span class="sig-paren">(</span><em class="sig-param">current_state</em>, <em class="sig-param">current_log_pdf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#DREAM.run_one_iteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.DREAM.run_one_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of the MCMC chain for DREAM algorithm, starting at current state - see <code class="docutils literal notranslate"><span class="pre">MCMC</span></code> class.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="is">
<h2>IS<a class="headerlink" href="#is" title="Permalink to this headline">¶</a></h2>
<p>Importance sampling (IS) is based on the idea of sampling from an alternate distribution and reweighting the samples to be representative of the target distribution (perhaps concentrating sampling in certain regions of the input space that are of greater importance). This often enables efficient evaluations of expectations <span class="math notranslate nohighlight">\(E_{ \textbf{x} \sim p} [ f(\textbf{x}) ]\)</span> where <span class="math notranslate nohighlight">\(f( \textbf{x})\)</span> is small outside of a small region of the input space. To this end, a sample <span class="math notranslate nohighlight">\(\textbf{x}\)</span> is drawn from a proposal distribution <span class="math notranslate nohighlight">\(q(\textbf{x})\)</span> and re-weighted to correct for the discrepancy between the sampling distribution <span class="math notranslate nohighlight">\(q\)</span> and the true distribution <span class="math notranslate nohighlight">\(p\)</span>. The weight of the sample is computed as</p>
<div class="math notranslate nohighlight">
\[w(\textbf{x}) = \frac{p(\textbf{x})}{q(\textbf{x})}\]</div>
<p>If <span class="math notranslate nohighlight">\(p\)</span> is only known up to a constant, i.e., one can only evaluate <span class="math notranslate nohighlight">\(\tilde{p}(\textbf{x})\)</span>, where <span class="math notranslate nohighlight">\(p(\textbf{x})=\frac{\tilde{p}(\textbf{x})}{Z}\)</span>, IS can be used by further normalizing the weights (self-normalized IS). The following figure shows the weighted samples obtained when using IS to estimate a 2d Gaussian target distribution <span class="math notranslate nohighlight">\(p\)</span>, sampling from a uniform proposal distribution <span class="math notranslate nohighlight">\(q\)</span>.</p>
<a class="reference internal image-reference" href="_images/SampleMethods_IS_samples.png"><img alt="IS weighted samples" class="align-center" src="_images/SampleMethods_IS_samples.png" style="width: 220.8px; height: 226.4px;" /></a>
<div class="section" id="id31">
<h3>Class Descriptions<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="UQpy.SampleMethods.IS">
<em class="property">class </em><code class="sig-prename descclassname">UQpy.SampleMethods.</code><code class="sig-name descname">IS</code><span class="sig-paren">(</span><em class="sig-param">nsamples=None</em>, <em class="sig-param">pdf_target=None</em>, <em class="sig-param">log_pdf_target=None</em>, <em class="sig-param">args_target=None</em>, <em class="sig-param">proposal=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#IS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.IS" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from a user-defined target density using importance sampling.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>):</dt><dd><p>Number of samples to generate - see <code class="docutils literal notranslate"><span class="pre">run</span></code> method. If not <cite>None</cite>, the <cite>run</cite> method is called when the object is
created. Default is None.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>pdf_target</strong> (callable):</dt><dd><p>Callable that evaluates the pdf of the target distribution. Either log_pdf_target or pdf_target must be
specified (the former is preferred).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>log_pdf_target</strong> (callable)</dt><dd><p>Callable that evaluates the log-pdf of the target distribution. Either log_pdf_target or pdf_target must be
specified (the former is preferred).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>args_target</strong> (<cite>tuple</cite>):</dt><dd><p>Positional arguments of the target log_pdf / pdf callable.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>proposal</strong> (<code class="docutils literal notranslate"><span class="pre">Distribution</span></code> object):</dt><dd><p>Proposal to sample from. This <code class="docutils literal notranslate"><span class="pre">UQpy.Distributions</span></code> object must have an rvs method and a log_pdf (or pdf)
method.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>verbose</strong> (<cite>boolean</cite>)</dt><dd><p>Set <code class="docutils literal notranslate"><span class="pre">verbose</span> <span class="pre">=</span> <span class="pre">True</span></code> to print status messages to the terminal during execution.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>random_state</strong> (None or <cite>int</cite> or <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code> object):</dt><dd><p>Random seed used to initialize the pseudo-random number generator. Default is None.</p>
<p>If an integer is provided, this sets the seed for an object of <code class="docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code>. Otherwise, the
object itself can be passed directly.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Attributes:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Set of samples, <cite>ndarray</cite> of shape (nsamples, dim)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>unnormalized_log_weights</strong> (<cite>ndarray</cite>)</dt><dd><p>Unnormalized log weights, i.e., log_w(x) = log_target(x) - log_proposal(x), <cite>ndarray</cite> of shape (nsamples, )</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>weights</strong> (<cite>ndarray</cite>):</dt><dd><p>Importance weights, weighted so that they sum up to 1, <cite>ndarray</cite> of shape (nsamples, )</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>unweighted_samples</strong> (<cite>ndarray</cite>):</dt><dd><p>Set of un-weighted samples (useful for instance for plotting), computed by calling the <cite>resample</cite> method</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Methods:</strong></p>
<dl class="method">
<dt id="UQpy.SampleMethods.IS.resample">
<code class="sig-name descname">resample</code><span class="sig-paren">(</span><em class="sig-param">method='multinomial'</em>, <em class="sig-param">nsamples=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#IS.resample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.IS.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample to get a set of un-weighted samples that represent the target pdf.</p>
<p>Utility function that creates a set of un-weighted samples from a set of weighted samples. Can be useful for
plotting for instance.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">resample</span></code> method is not called automatically when instantiating the <code class="docutils literal notranslate"><span class="pre">IS</span></code> class or when invoking its
<code class="docutils literal notranslate"><span class="pre">run</span></code> method.</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>method</strong> (<cite>str</cite>)</dt><dd><p>Resampling method, as of V3 only multinomial resampling is supported. Default: ‘multinomial’.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>)</dt><dd><p>Number of un-weighted samples to generate. Default: None (sets <cite>nsamples</cite> equal to the number of
existing weighted samples).</p>
</dd>
</dl>
</li>
</ul>
<p><strong>Output/Returns:</strong></p>
<p>The method has no returns, but it computes the following attribute of the <code class="docutils literal notranslate"><span class="pre">IS</span></code> object.</p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>unweighted_samples</strong> (<cite>ndarray</cite>)</dt><dd><p>Un-weighted samples that represent the target pdf, <cite>ndarray</cite> of shape (nsamples, dimension)</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="UQpy.SampleMethods.IS.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">nsamples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/UQpy/SampleMethods.html#IS.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#UQpy.SampleMethods.IS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate and weight samples.</p>
<p>This function samples from the proposal and appends samples to existing ones (if any). It then weights the
samples as log_w_unnormalized) = log(target)-log(proposal).</p>
<p><strong>Inputs:</strong></p>
<ul class="simple">
<li><dl class="simple">
<dt><strong>nsamples</strong> (<cite>int</cite>)</dt><dd><p>Number of weighted samples to generate.</p>
</dd>
</dl>
</li>
<li><p><strong>Output/Returns:</strong></p></li>
</ul>
<p>This function has no returns, but it updates the output attributes <cite>samples</cite>, <cite>unnormalized_log_weights</cite> and
<cite>weights</cite> of the <code class="docutils literal notranslate"><span class="pre">IS</span></code> object.</p>
</dd></dl>

</dd></dl>

<dl class="footnote brackets">
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id28">1</a></span></dt>
<dd><p>Gelman et al., “Bayesian data analysis”, Chapman and Hall/CRC, 2013</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id29">2</a></span></dt>
<dd><p>R.C. Smith, “Uncertainty Quantification - Theory, Implementation and Applications”, CS&amp;E, 2014</p>
</dd>
<dt class="label" id="id34"><span class="brackets">3</span><span class="fn-backref">(<a href="#id15">1</a>,<a href="#id17">2</a>)</span></dt>
<dd><ol class="upperalpha simple" start="2">
<li><p>Echard, N. Gayton and M. Lemaire, “AK-MCS: An active learning reliability method combining Kriging and Monte Carlo Simulation”, Structural Safety, Pages 145-154, 2011.</p></li>
</ol>
</dd>
<dt class="label" id="id35"><span class="brackets">4</span><span class="fn-backref">(<a href="#id16">1</a>,<a href="#id20">2</a>,<a href="#id25">3</a>)</span></dt>
<dd><p>Jones, D. R., Schonlau, M., &amp; Welch, W. J. “Efficient global optimization of expensive black-box functions.” Journal of Global optimization, 13(4), 455-492, 1998.</p>
</dd>
<dt class="label" id="id36"><span class="brackets">5</span><span class="fn-backref">(<a href="#id18">1</a>,<a href="#id27">2</a>)</span></dt>
<dd><p>V.S. Sundar and Shields, M.D. “Reliablity analysis using adaptive Kriging surrogates and multimodel inference.” ASCE-ASME Journal of Risk and Uncertainty in Engineering Systems. Part A: Civil Engineering. 5(2): 04019004, 2019.</p>
</dd>
<dt class="label" id="id37"><span class="brackets">6</span><span class="fn-backref">(<a href="#id19">1</a>,<a href="#id24">2</a>)</span></dt>
<dd><p>B.J. Bichon, M.S. Eldred, L.P. Swiler, S. Mahadevan, and J.M. McFarland. “Efficient global reliablity analysis for nonlinear implicit performance functions.” AIAA Journal. 46(10) 2459-2468, (2008).</p>
</dd>
<dt class="label" id="id38"><span class="brackets">7</span><span class="fn-backref">(<a href="#id21">1</a>,<a href="#id22">2</a>,<a href="#id26">3</a>)</span></dt>
<dd><p>C.Q. Lam. “Sequential adaptive designs in computer experiments for response surface model fit.” PhD diss., The Ohio State University, 2008.</p>
</dd>
<dt class="label" id="id39"><span class="brackets"><a class="fn-backref" href="#id13">8</a></span></dt>
<dd><ol class="upperalpha simple" start="23">
<li><ol class="upperalpha simple" start="14">
<li><p>Edeling, R. P. Dwight, P. Cinnella, “Simplex-stochastic collocation method with improved scalability”, Journal of Computational Physics, 310:301–328, 2016.</p></li>
</ol>
</li>
</ol>
</dd>
<dt class="label" id="id40"><span class="brackets"><a class="fn-backref" href="#id5">9</a></span></dt>
<dd><ol class="upperalpha simple" start="11">
<li><p>Tocher. “The art of simulation.” The English Universities Press, London, UK; 1963.</p></li>
</ol>
</dd>
<dt class="label" id="id41"><span class="brackets">10</span></dt>
<dd><p>M.D. Shields, K. Teferra, A. Hapij, and R.P. Daddazio, “Refined Stratified Sampling for efficient Monte Carlo based uncertainty quantification,” Reliability Engineering and System Safety,vol.142, pp.310-325,2015.</p>
</dd>
<dt class="label" id="id42"><span class="brackets">11</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>M.D. Shields, K. Teferra, A. Hapij, and R.P. Daddazio, “Refined stratified sampling for efficient Monte Carlo based uncertainty quantification.” Reliability Engineering &amp; System Safety 142 (2015): 310-325.</p>
</dd>
<dt class="label" id="id43"><span class="brackets">12</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>M.D. Shields, “Adaptive Monte Carlo analysis for strongly nonlinear stochastic systems.” Reliability Engineering &amp; System Safety 175 (2018): 207-224.</p>
</dd>
</dl>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="runmodel.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">Distributions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SampleMethods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mcs">MCS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lhs">LHS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stratified-sampling">Stratified Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#refined-stratified-sampling">Refined Stratified Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simplex">Simplex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#akmcs">AKMCS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mcmc">MCMC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#is">IS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="transformations.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="stochastic_process.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="surrogates.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="reliability.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="inference.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimension_reduction.html">DimensionReduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="distributions.html" title="previous chapter">Distributions</a></li>
      <li>Next: <a href="transformations.html" title="next chapter">Transformations</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, SURG, JHU.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/samplemethods.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>