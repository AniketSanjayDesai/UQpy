
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.DimensionReduction &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.DimensionReduction</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``DimensionReduction`` is the module for ``UQpy`` to perform the dimensionality reduction of high-dimensional data.</span>

<span class="sd">This module contains the classes and methods to perform pointwise and multi point data-based dimensionality reduction</span>
<span class="sd">via projection onto Grassmann manifolds and Diffusion Maps, respectively. Further, interpolation in the tangent space</span>
<span class="sd">centered at a given point on the Grassmann manifold can be performed, as well as the computation of kernels defined on</span>
<span class="sd">the Grassmann manifold to be employed in techniques using subspaces.</span>

<span class="sd">The module currently contains the following classes:</span>

<span class="sd">* ``Grassmann``: Class for for analysis of samples on the Grassmann manifold.</span>

<span class="sd">* ``DiffusionMaps``: Class for multi point data-based dimensionality reduction.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">spsl</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span> <span class="k">as</span> <span class="nn">sd</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">LinearNDInterpolator</span>

<span class="kn">from</span> <span class="nn">UQpy.Surrogates</span> <span class="k">import</span> <span class="n">Kriging</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="n">_nn_coord</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                            Grassmann Manifold                                                        #</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="Grassmann"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann">[docs]</a><span class="k">class</span> <span class="nc">Grassmann</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mathematical analysis on the Grassmann manifold.</span>

<span class="sd">    The ``Grassmann`` class contains methods of data analysis on the Grassmann manifold, which is a special case of flag</span>
<span class="sd">    manifold. The projection of matrices onto the Grassmann manifold is performed via singular value decomposition(SVD),</span>
<span class="sd">    where their dimensionality are reduced. Further, the mapping from the Grassmann manifold to a tangent space</span>
<span class="sd">    constructed at a given reference point (logarithmic mapping), as well as the mapping from the tangent space to the</span>
<span class="sd">    manifold (exponential mapping) are implemented as methods. Moreover, an interpolation can be performed on the</span>
<span class="sd">    tangent space taking advantage of the implemented logarithmic and exponential maps. Additional quantities such</span>
<span class="sd">    as the Karcher mean, distance, and kernel, all defined on the Grassmann manifold, can be obtained using</span>
<span class="sd">    implemented methods. When the class ``Grassmann`` is instantiated some attributes are set using the method</span>
<span class="sd">    ``manifold``, where the dimension of the manifold as well as the samples are input arguments.</span>
<span class="sd">    </span>
<span class="sd">    **Input:**</span>

<span class="sd">    * **distance_method** (`callable`)</span>
<span class="sd">        Defines the distance metric on the manifold. The user can pass a callable object defining the distance metric</span>
<span class="sd">        using two different ways. First, the user can pass one of the methods implemented in the class ``Grassmann``, they are:</span>

<span class="sd">        - `grassmann_distance`;</span>
<span class="sd">        - `chordal_distance`;</span>
<span class="sd">        - `procrustes_distance`;</span>
<span class="sd">        - `projection_distance`</span>
<span class="sd">        - `binet_cauchy_distance`.</span>

<span class="sd">        In this regard,</span>
<span class="sd">        the class ``Grassmann`` is instantiated and the attributes are set using the method ``manifold``. Thus,</span>
<span class="sd">        an object containing the attribute `distance_method` is passed as `Grassmann.distance_method`. Second, the user</span>
<span class="sd">        can pass either a method of a class or a function. For example, if the user wish to</span>
<span class="sd">        use `grassmann_distance` to compute the distance, one can use the following command:</span>

<span class="sd">        On the other hand, if the user implemented a function</span>
<span class="sd">        (e.g., `user_distance`) to compute the distance, `distance_method` must assume the following value</span>
<span class="sd">        `distance_method = user_distance`, which must be pre-loaded using import. In this regard, the</span>
<span class="sd">        function input must contain the first (x0) and second (x1) matrices as arguments (e.g, user_distance(x0,x1))</span>

<span class="sd">    * **kernel_method** (`callable`)</span>
<span class="sd">        Object of the kernel function defined on the Grassmann manifold. The user can pass a object using two different</span>
<span class="sd">        ways. First, the user can pass one of the methods implemented in the class ``Grassmann``, they are:</span>

<span class="sd">        - `projection_kernel`;</span>
<span class="sd">        - `binet_cauchy_kernel`.</span>

<span class="sd">        In this regard, the object is passed as `Grassmann.kernel_method`.</span>
<span class="sd">        Second, the user can pass callable objects either as a method of a class or as a function. </span>
<span class="sd">        For example, if the user wish to use `projection_kernel` to estimate the kernel matrix, one can use the</span>
<span class="sd">        following command:</span>

<span class="sd">        On the other hand, if the user implemented</span>
<span class="sd">        a function (e.g., `user_kernel`) to compute the kernel matrix, `kernel_method` must assume the following value</span>
<span class="sd">        `kernel_object = user_kernel`, which must be pre-loaded using import. In this regard, the function</span>
<span class="sd">        input must contain the first (x0) and second (x1) matrices as arguments (e.g, user_kernel(x0,x1))</span>
<span class="sd">    </span>
<span class="sd">    * **interp_object** (`object`)</span>
<span class="sd">        Interpolator to be used in the Tangent space. The user can pass an object defining the interpolator</span>
<span class="sd">        via four different ways.</span>

<span class="sd">        - Using the ``Grassmann`` method ``linear_interp`` as Grassmann(interp_object=Grassmann.linear_interp).</span>
<span class="sd">        - Using an object of ``UQpy.Kriging`` as Grassmann(interp_object=Kriging_Object)</span>
<span class="sd">        - Using an object of ``sklearn.gaussian_process`` as Grassmann(interp_object=Sklearn_Object)</span>
<span class="sd">        - Using an user defined object (e.g., user_interp). In this case, the function must contain the following</span>
<span class="sd">          arguments: `coordinates`, `samples`, and `point`.</span>
<span class="sd">    </span>
<span class="sd">    * **karcher_method** (`callable`)</span>
<span class="sd">        Optimization method used in the estimation of the Karcher mean. The user can pass a callable object via</span>
<span class="sd">        two different ways. First, the user can pass one of the methods implemented in the class ``Grassmann``,</span>
<span class="sd">        they are:</span>

<span class="sd">        - ``gradient_descent``;</span>
<span class="sd">        - ``stochastic_gradient_descent``.</span>

<span class="sd">        Second, the user can pass callable objects either as a method of a class or as a function. It is worth</span>
<span class="sd">        mentioning that the method ``gradient_descent`` also allows the accelerated descent method due to Nesterov.</span>
<span class="sd">    </span>
<span class="sd">    **Attributes:**</span>

<span class="sd">    * **p** (`int` or `str`)</span>
<span class="sd">        Dimension of the p-planes defining the Grassmann manifold G(n,p).</span>
<span class="sd">        </span>
<span class="sd">    * **ranks** (`list`)</span>
<span class="sd">        Dimension of the embedding dimension for the manifolds G(n,p) of each sample.</span>
<span class="sd">        </span>
<span class="sd">    * **samples** (`list` of `list` or `ndarray`)</span>
<span class="sd">        Input samples defined as a `list` of matrices.</span>
<span class="sd">        </span>
<span class="sd">    * **nargs** (`int`)</span>
<span class="sd">        Number of matrices in `samples`.</span>
<span class="sd">        </span>
<span class="sd">    * **max_rank** (`int`)</span>
<span class="sd">        Maximum value of `ranks`.</span>
<span class="sd">        </span>
<span class="sd">    * **psi** (`list`)</span>
<span class="sd">        Left singular eigenvectors from the singular value decomposition of each sample in `samples`</span>
<span class="sd">        representing a point on the Grassmann manifold.</span>
<span class="sd">    </span>
<span class="sd">    * **sigma** (`list`)</span>
<span class="sd">        Singular values from the singular value decomposition of each sample in `samples`.</span>
<span class="sd">    </span>
<span class="sd">    * **phi** (`list`)</span>
<span class="sd">        Right singular eigenvector from the singular value decomposition of each sample in `samples`</span>
<span class="sd">        representing a point on the Grassmann manifold.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">karcher_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Distance.</span>
        <span class="k">if</span> <span class="n">distance_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">distance_method</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_object</span> <span class="o">=</span> <span class="n">distance_method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A callable distance object must be provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Kernels.</span>
        <span class="k">if</span> <span class="n">kernel_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">kernel_method</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="o">=</span> <span class="n">kernel_method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A callable kernel object must be provided.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Interpolation.</span>
        <span class="n">skl_str</span> <span class="o">=</span> <span class="s2">&quot;&lt;class &#39;sklearn.gaussian_process.gpr.GaussianProcessRegressor&#39;&gt;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skl</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">interp_object</span><span class="p">))</span><span class="o">==</span><span class="n">skl_str</span>
        <span class="k">if</span> <span class="n">interp_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">interp_object</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interp_object</span><span class="p">,</span> <span class="n">Kriging</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">skl</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span> <span class="o">=</span> <span class="n">interp_object</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A callable interpolation object must be provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Karcher mean.</span>
        <span class="k">if</span> <span class="n">karcher_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distance_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: A callable distance object must be provided too.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">karcher_method</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">karcher_object</span> <span class="o">=</span> <span class="n">karcher_method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A callable Karcher mean object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_psi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rank</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Grassmann.manifold"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.manifold">[docs]</a>    <span class="k">def</span> <span class="nf">manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the grassmann manifold and project the samples on it via singular value decomposition.</span>

<span class="sd">        This method project samples onto the Grassmann manifold via singular value decomposition. The input arguments</span>
<span class="sd">        are passed through the argument `samples` containing a list of lists or a list of ndarrays. Moreover, this</span>
<span class="sd">        method serves to set the manifold and to verify the consistency of the input data. This method can be called</span>
<span class="sd">        using the following command:</span>

<span class="sd">        In this case, append_samples is a boolean variable used to define if new sample will replace the previous ones</span>
<span class="sd">        or will just get appended (`append_samples=True`).</span>

<span class="sd">        **Input:**</span>
<span class="sd">        </span>
<span class="sd">        * **p** (`int` or `str` or `NoneType`)</span>
<span class="sd">            Dimension of the p-planes defining the Grassmann manifold G(n,p). This parameter can assume an integer value </span>
<span class="sd">            larger than 0 or the strings `max`, when `p` assumes the maximum rank of the input matrices, or `min` when</span>
<span class="sd">            it assumes the minimum one. If `p` is not provided `ranks` will store the ranks of each input</span>
<span class="sd">            matrix and each sample will lie on a distinct manifold.</span>
<span class="sd">            </span>
<span class="sd">        * **samples** (`list`)</span>
<span class="sd">            Input samples defined as a `list` of matrices. In this regard, `samples` is a </span>
<span class="sd">            collection of matrices stored as a `list`. Moreover, The shape of the input matrices stored </span>
<span class="sd">            in samples are verified and compared for consistency with `p`.</span>
<span class="sd">            </span>
<span class="sd">        * **append_samples** (`bool`)</span>
<span class="sd">            The attributes are replaced when manifold is called if `append_samples` is False, otherwise the lists are </span>
<span class="sd">            appended.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If manifold called for the first time </span>
        <span class="c1"># force append_samples to be False.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">:</span>
            <span class="n">append_samples</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># samples must be a list.</span>
        <span class="c1"># Test samples for type consistency.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `samples` must be either a list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># If append_samples is true, store the new samples</span>
        <span class="c1"># in a new list.</span>
        <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
            <span class="n">samples_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="n">nargs_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples_new</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_new</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>

        <span class="c1"># samples must be converted into a ndarray due to the necessary computation over slices.</span>
        <span class="c1"># Check the number of matrices stored in samples.</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># At least one argument must be provided, otherwise show an error message.</span>
        <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: At least one input matrix must be provided.&#39;</span><span class="p">)</span>

        <span class="n">n_left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">n_left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
            <span class="n">n_right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>

        <span class="n">bool_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_left</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n_left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_left</span><span class="p">))</span>
        <span class="n">bool_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_right</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n_right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_right</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">bool_left</span> <span class="ow">and</span> <span class="n">bool_right</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The shape of the input matrices must be the same.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_psi</span> <span class="o">=</span> <span class="n">n_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_phi</span> <span class="o">=</span> <span class="n">n_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="c1"># If append_sample just compute the rank of the new samples.</span>
            <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span>
                <span class="n">ranks_new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">):</span>
                    <span class="n">rnk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">samples_new</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>
                    <span class="n">ranks_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                    <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                <span class="c1"># Get the maximum rank of the input matrices</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ranks</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">p</span> <span class="ow">is</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="c1"># Get the minimum rank of the input matrices</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ranks</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The only allowable input strings are `min` and `max`.&#39;</span><span class="p">)</span>

            <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                <span class="n">ranks_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
                <span class="n">ranks_new</span> <span class="o">=</span> <span class="n">ranks_new</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                    <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span>
                    <span class="n">ranks_new</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">):</span>
                        <span class="n">rnk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">samples_new</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>
                        <span class="n">ranks_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ranks</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                        <span class="n">ranks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `p` must be integer.&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: `p` must be an integer larger than or equal to one.&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The dimension of the input data is not consistent with `p` of G(n,p).&#39;</span><span class="p">)</span>

                <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                    <span class="n">ranks_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
                    <span class="n">ranks_new</span> <span class="o">=</span> <span class="n">ranks_new</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">ranks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">ranks</span><span class="p">))</span>

        <span class="c1"># For each point perform svd.</span>
        <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs_new</span><span class="p">):</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">samples_new</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">ranks_new</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize the left singular eigenvectors as a list.</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize the singular values as a list.</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize the right singular eigenvectors as a list.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">ranks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">psi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="n">phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">phi</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_psi</span> <span class="o">=</span> <span class="n">n_psi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_phi</span> <span class="o">=</span> <span class="n">n_phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span> <span class="o">=</span> <span class="n">ranks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="n">nargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ranks</span><span class="p">))</span></div>

<div class="viewcode-block" id="Grassmann.distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_grassmann</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the distance between points on the Grassmann manifold.</span>

<span class="sd">        This method computes the pairwise distance of points projected on the Grassmann manifold. The input arguments</span>
<span class="sd">        are passed through a `list` of `list` or a `list` of `ndarray`. When the user call this method a list containing</span>
<span class="sd">        the pairwise distances is returned as an output argument where the distances are stored as </span>
<span class="sd">        [{0,1},{0,2},...,{1,0},{1,1},{1,2},...], where {a,b} corresponds to the distance between the points &#39;a&#39; and </span>
<span class="sd">        &#39;b&#39;. Further, users are asked to provide the distance definition when the class `Grassmann` is instatiated. </span>
<span class="sd">        The current built-in options are the `grassmann_distance`, `chordal_distance`, `procrustes_distance`, </span>
<span class="sd">        `projection_distance`, and `binet_cauchy_distance`, but the users have also the option to implement their own </span>
<span class="sd">        distance definition. In this case, the user must be aware that the matrices in `points_grassmann` must represent </span>
<span class="sd">        points on the Grassmann manifold. For example, given the points on the Grassmann manifold one can compute the </span>
<span class="sd">        pairwise distances in the following way:</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points_grassmann** (`list` or `NoneType`) </span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold. If `points_grassmann` is not</span>
<span class="sd">            provided it means that the samples in `manifold` are employed, and the pairwise distances of the points on</span>
<span class="sd">            the manifold defined by the left and right singular eigenvectors are computed.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **points_distance** (`list`)</span>
<span class="sd">            Pairwise distances if `points_grassmann` is provided.</span>
<span class="sd">                </span>
<span class="sd">        * **points_distance_psi** (`list`)</span>
<span class="sd">            Pairwise distance of points on the manifold defined by the left singular eigenvectors if `points_grassmann` </span>
<span class="sd">            is not provided.</span>
<span class="sd">            </span>
<span class="sd">        * **points_distance_phi** (`list`)</span>
<span class="sd">            Pairwise distance of points on the manifold defined by the right singular eigenvectors if `points_grassmann` </span>
<span class="sd">            is not provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Show an error message if no distance_object is identified.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `distance_object` cannot be NoneType&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_object</span>

        <span class="c1"># If points_grassmann is not provided compute the distances on the manifold defined</span>
        <span class="c1"># by the left (psi) and right (phi) singular eigenvectors. In this case, use the information</span>
        <span class="c1"># set by the method manifold.</span>
        <span class="k">if</span> <span class="n">points_grassmann</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Compute the pairwise distances.</span>
            <span class="n">points_distance_psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">)</span>
            <span class="n">points_distance_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">)</span>

            <span class="c1"># Return the parwise distances for the left and right singular eigenvectors.</span>
            <span class="k">return</span> <span class="n">points_distance_psi</span><span class="p">,</span> <span class="n">points_distance_phi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">points_grassmann</span> <span class="o">=</span> <span class="n">points_grassmann</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="n">n_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">n_size</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The shape of the input matrices must be the same.&#39;</span><span class="p">)</span>

            <span class="c1"># if points_grasssmann is provided, use the shape of the input matrices to define </span>
            <span class="c1"># the dimension of the p-planes defining the manifold of each individual input matrix.</span>
            <span class="n">p_dim</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
                <span class="n">p_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>

            <span class="c1"># Compute the pairwise distances.</span>
            <span class="n">points_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_distance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">p_dim</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">)</span>

            <span class="c1"># Return the pairwise distances.</span>
            <span class="k">return</span> <span class="n">points_distance</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__estimate_distance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">p_dim</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method: Estimate the distance between points on the Grassmann manifold.</span>

<span class="sd">        This is an auxiliary method to compute the pairwise distance of points on the Grassmann manifold. </span>
<span class="sd">        The input arguments are passed through a list . Further, the user has the option to pass the dimension </span>
<span class="sd">        of the embedding space.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points** (`list` or `ndarray`)</span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold.</span>
<span class="sd">        </span>
<span class="sd">        * **p_dim** (`list`)</span>
<span class="sd">            Embedding dimension.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance_list** (`list`)</span>
<span class="sd">            Pairwise distance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check points for type and shape consistency.</span>
        <span class="c1"># -----------------------------------------------------------</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The input matrices must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>

        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: At least two matrices must be provided.&#39;</span><span class="p">)</span>

        <span class="c1"># ------------------------------------------------------------</span>

        <span class="c1"># Define the pairs of points to compute the Grassmann distance.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Compute the pairwise distances.</span>
        <span class="n">distance_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_pair</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pairs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Point i</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Point j</span>

            <span class="n">p0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p_dim</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p_dim</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">ii</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">p0</span><span class="p">]</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">jj</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">p1</span><span class="p">]</span>

            <span class="c1"># Call the functions where the distance metric is implemented.</span>
            <span class="n">distance_value</span> <span class="o">=</span> <span class="n">distance_fun</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>

            <span class="n">distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">distance_list</span>

    <span class="c1"># ==================================================================================================================</span>
    <span class="c1"># Built-in metrics are implemented in this section. Any new built-in metric must be implemented</span>
    <span class="c1"># here with the decorator @staticmethod.  </span>

<div class="viewcode-block" id="Grassmann.grassmann_distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.grassmann_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">grassmann_distance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the Grassmann distance.</span>

<span class="sd">        One of the distances defined on the Grassmann manifold is the Grassmann distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Grassmann distance between x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">si</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="Grassmann.chordal_distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.chordal_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">chordal_distance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the chordal distance.</span>

<span class="sd">        One of the distances defined on the Grassmann manifold is the chordal distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`) </span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Chordal distance between x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">r_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">r_star</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">si</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">sin_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sin_sq</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="Grassmann.procrustes_distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.procrustes_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">procrustes_distance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the Procrustes distance.</span>

<span class="sd">        One of the distances defined on the Grassmann manifold is the Procrustes distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Procrustes distance between x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">si</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">sin_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sin_t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="Grassmann.projection_distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.projection_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">projection_distance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the projection distance.</span>

<span class="sd">        One of the distances defined on the Grassmann manifold is the projection distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`) </span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Projection distance between x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">si</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">sin_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sin_t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">distance</span></div>
    
<div class="viewcode-block" id="Grassmann.binet_cauchy_distance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.binet_cauchy_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">binet_cauchy_distance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the Binet-Cauchy distance.</span>

<span class="sd">        One of the distances defined on the Grassmann manifold is the projection distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`) </span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Projection distance between x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">si</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">si</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">si</span><span class="p">))</span>
        <span class="n">sin_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sin_t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">distance</span></div>

    <span class="c1"># ==================================================================================================================</span>
<div class="viewcode-block" id="Grassmann.kernel"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.kernel">[docs]</a>    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_grassmann</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a kernel matrix on the Grassmann manifold.</span>

<span class="sd">        This method computes the kernel matrix of points on the Grassmann manifold. The input arguments are passed </span>
<span class="sd">        through a list. When the user call this method a ndarray containing the kernel matrix is returned as an</span>
<span class="sd">        output argument. Further, users are asked to provide the kernel method when the class Grassmann is instatiated.</span>
<span class="sd">        The current built-in options are the `projection_kernel` and the `binet_cauchy_kernel`, but the users have</span>
<span class="sd">        the option to implement their own kernel definition. However, the user must be aware that the points used</span>
<span class="sd">        to compute the kernel must be the points on the same manifold; therefore, it is important to ensure that the </span>
<span class="sd">        dimension of all the input matrices are the same. Therefore, the following commands can be used:</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points_grassmann** (`list` or `NoneType`) </span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold. If `points_grassmann` is not</span>
<span class="sd">            provided it means that the samples set by `manifold` is employed and kernel matrices are computed for the </span>
<span class="sd">            points on the manifold defined by the left and right singular eigenvectors are computed.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **kernel_matrix** (`list`)</span>
<span class="sd">            Kernel matrix if `points_grassmann` is provided.</span>
<span class="sd">                </span>
<span class="sd">        * **kernel_matrix_psi** (`list`)</span>
<span class="sd">            Kernel matrix on the manifold defined by the left singular eigenvectors if `points_grassmann` </span>
<span class="sd">            is not provided.</span>
<span class="sd">            </span>
<span class="sd">        * **kernel_matrix_phi** (`list`)</span>
<span class="sd">            Kernel matrix on the manifold defined by the right singular eigenvectors if `points_grassmann` </span>
<span class="sd">            is not provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If points_grassmann is None get the information set using the method manifold.</span>
        <span class="k">if</span> <span class="n">points_grassmann</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranks</span>

            <span class="c1"># Check if all the input points belong to the same manifold.</span>
            <span class="k">if</span> <span class="n">ranks</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ranks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranks</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: the input points do not belog to the same manifold.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_dim</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Compute the kernel matrix    </span>
            <span class="n">kernel_psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">,</span> <span class="n">p_dim</span><span class="o">=</span><span class="n">p_dim</span><span class="p">)</span>
            <span class="n">kernel_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">p_dim</span><span class="o">=</span><span class="n">p_dim</span><span class="p">)</span>

            <span class="c1"># Return both kernel matrices.</span>
            <span class="k">return</span> <span class="n">kernel_psi</span><span class="p">,</span> <span class="n">kernel_phi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">points_grassmann</span> <span class="o">=</span> <span class="n">points_grassmann</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="n">n_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">n_size</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The shape of the input matrices must be the same.&#39;</span><span class="p">)</span>

            <span class="c1"># Check the embedding dimension and its consistency.</span>
            <span class="n">p_dim</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
                <span class="n">p_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>

            <span class="k">if</span> <span class="n">p_dim</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">p_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_dim</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The input points do not belog to the same manifold.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">p0</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The input points do not belog to the manifold G(n,p).&#39;</span><span class="p">)</span>

                    <span class="c1"># Compute the kernel matrix.</span>
            <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__estimate_kernel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">),</span> <span class="n">p0</span><span class="p">)</span>

            <span class="c1"># Return the kernel matrix.</span>
            <span class="k">return</span> <span class="n">kernel_matrix</span></div>

    <span class="k">def</span> <span class="nf">__estimate_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">p_dim</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method: Compute a kernel matrix on the Grassmann manifold.</span>

<span class="sd">        This an auxiliary and private method to compute the kernel matrix of points on the Grassmann manifold.</span>
<span class="sd">        When using this method a ndarray containing the kernel matrix is returned as an output argument.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points** (`list` or `ndarray`)</span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold.</span>
<span class="sd">        </span>
<span class="sd">        * **p_dim** (`int`)</span>
<span class="sd">            Embedding dimension.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **kernel_matrix** (`list`)</span>
<span class="sd">            Kernel matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check points for type and shape consistency.</span>
        <span class="c1"># -----------------------------------------------------------</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `points` must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>

        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: At least two matrices must be provided.&#39;</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------------------</span>

        <span class="c1"># Define the pairs of points to compute the entries of the kernel matrix.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Show an error message if no kernel_object is found.    </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `kernel_object` cannot be NoneType&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span>

        <span class="c1"># Estimate off-diagonal entries of the kernel matrix.</span>
        <span class="n">kernel_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_pair</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pairs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Point i</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Point j</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">ii</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">p_dim</span><span class="p">]</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">jj</span><span class="p">])[:,</span> <span class="p">:</span><span class="n">p_dim</span><span class="p">]</span>

            <span class="n">ker</span> <span class="o">=</span> <span class="n">kernel_fun</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">kernel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ker</span><span class="p">)</span>

        <span class="c1"># Diagonal entries of the kernel matrix.</span>
        <span class="n">kernel_diag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_elem</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">xd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">id_elem</span><span class="p">])</span>
            <span class="n">xd</span> <span class="o">=</span> <span class="n">xd</span><span class="p">[:,</span> <span class="p">:</span><span class="n">p_dim</span><span class="p">]</span>

            <span class="n">kerd</span> <span class="o">=</span> <span class="n">kernel_fun</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">xd</span><span class="p">)</span>
            <span class="n">kernel_diag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kerd</span><span class="p">)</span>

        <span class="c1"># Add the diagonals and off-diagonal entries of the Kernel matrix.</span>
        <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel_list</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">kernel_diag</span><span class="p">)</span>

        <span class="c1"># Return the kernel matrix.</span>
        <span class="k">return</span> <span class="n">kernel_matrix</span>

    <span class="c1"># ==================================================================================================================</span>
<div class="viewcode-block" id="Grassmann.projection_kernel"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.projection_kernel">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">projection_kernel</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the value of the projection kernel between x0 and x1.</span>

<span class="sd">        One of the kernels defined on a manifold is the projection kernel.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Kernel value for x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
        <span class="n">ker</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">ker</span></div>

<div class="viewcode-block" id="Grassmann.binet_cauchy_kernel"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.binet_cauchy_kernel">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">binet_cauchy_kernel</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the value of the Binet-Cauchy kernel between x0 and x1.</span>

<span class="sd">        One of the kernels defined on a manifold is the Binet-Cauchy kernel.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **x0** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        * **x1** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **distance** (`float`)</span>
<span class="sd">            Kernel value for x0 and x1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x0 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: x1 must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">ker</span> <span class="o">=</span> <span class="n">det</span> <span class="o">*</span> <span class="n">det</span>
        <span class="k">return</span> <span class="n">ker</span></div>

    <span class="c1"># ==================================================================================================================</span>
<div class="viewcode-block" id="Grassmann.log_map"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.log_map">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapping points from the Grassmann manifold on the tangent space.</span>

<span class="sd">        It maps the points on the Grassmann manifold, passed to the method using the input argument `points_grassmann`,</span>
<span class="sd">        onto the tangent space constructed on ref (a reference point on the Grassmann manifold).</span>
<span class="sd">        It is mandatory that the user pass a reference point to the method. Further, the reference point and the points</span>
<span class="sd">        in `points_grassmann` must belong to the same manifold.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points_grassmann** (`list`)</span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold.</span>

<span class="sd">        * **ref** (`list` or `ndarray`)</span>
<span class="sd">            A point on the Grassmann manifold used as reference to construct the tangent space.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **points_tan**: (`list`)</span>
<span class="sd">            Point on the tangent space.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Show an error message if points_grassmann is not provided.</span>
        <span class="k">if</span> <span class="n">points_grassmann</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: No input data is provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Show an error message if ref is not provided.</span>
        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: No reference point is provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Check points_grassmann for type consistency.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `points_grassmann` must be either a list or numpy.ndarray.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the number of matrices in the set.</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)</span>

        <span class="n">shape_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">p_dim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">p_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The input points are in different manifold.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_ref</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The ref and points_grassmann are in different manifolds.&#39;</span><span class="p">)</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">p_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check reference for type consistency.</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ref_list</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_list</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="c1"># Multiply ref by its transpose.</span>
        <span class="n">refT</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">T</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">refT</span><span class="p">)</span>

        <span class="c1"># Loop over all the input matrices.</span>
        <span class="n">points_tan</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">utrunc</span> <span class="o">=</span> <span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">p0</span><span class="p">]</span>

            <span class="c1"># If the reference point is one of the given points</span>
            <span class="c1"># set the entries to zero.</span>
            <span class="k">if</span> <span class="n">utrunc</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">ref_list</span><span class="p">:</span>
                <span class="n">points_tan</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ref</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># compute: M = ((I - psi0*psi0&#39;)*psi1)*inv(psi0&#39;*psi1)</span>
                <span class="n">minv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">refT</span><span class="p">,</span> <span class="n">utrunc</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">utrunc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">utrunc</span><span class="p">),</span> <span class="n">minv</span><span class="p">)</span>
                <span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># svd(m, max_rank)</span>
                <span class="n">points_tan</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">si</span><span class="p">))),</span> <span class="n">vi</span><span class="p">))</span>

        <span class="c1"># Return the points on the tangent space</span>
        <span class="k">return</span> <span class="n">points_tan</span></div>

<div class="viewcode-block" id="Grassmann.exp_map"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.exp_map">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">exp_map</span><span class="p">(</span><span class="n">points_tangent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map points on the tangent space onto the Grassmann manifold.</span>

<span class="sd">        It maps the points on the tangent space, passed to the method using points_tangent, onto the Grassmann manifold. </span>
<span class="sd">        It is mandatory that the user pass a reference point where the tangent space was created.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points_tangent** (`list`)</span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold.</span>

<span class="sd">        * **ref** (`list` or `ndarray`)</span>
<span class="sd">            A point on the Grassmann manifold used as reference to construct the tangent space.</span>
<span class="sd">       </span>
<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **points_manifold**: (`list`)</span>
<span class="sd">            Point on the tangent space.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Show an error message if points_tangent is not provided.</span>
        <span class="k">if</span> <span class="n">points_tangent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: No input data is provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Show an error message if ref is not provided.</span>
        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: No reference point is provided.&#39;</span><span class="p">)</span>

        <span class="c1"># Test points_tangent for type consistency.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `points_tangent` must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>

        <span class="c1"># Number of input matrices.</span>
        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">)</span>

        <span class="n">shape_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">p_dim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">p_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_tangent</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The input points are in different manifold.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_ref</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;The ref and points_grassmann are in different manifolds.&#39;</span><span class="p">)</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">p_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># -----------------------------------------------------------</span>

        <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="c1"># ref = ref[:,:p0]</span>

        <span class="c1"># Map the each point back to the manifold.</span>
        <span class="n">points_manifold</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">utrunc</span> <span class="o">=</span> <span class="n">points_tangent</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="n">p0</span><span class="p">]</span>
            <span class="n">ui</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">utrunc</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Exponential mapping.</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">vi</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">si</span><span class="p">)))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">si</span><span class="p">))),</span> <span class="n">vi</span><span class="p">)</span>

            <span class="c1"># Test orthogonality.</span>
            <span class="n">xtest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xtest</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xtest</span><span class="p">)[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">x0</span><span class="p">,</span> <span class="n">unused</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>  <span class="c1"># re-orthonormalizing.</span>

            <span class="n">points_manifold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">points_manifold</span></div>

<div class="viewcode-block" id="Grassmann.karcher_mean"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.karcher_mean">[docs]</a>    <span class="k">def</span> <span class="nf">karcher_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points_grassmann</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Karcher mean.</span>

<span class="sd">        This method computes the Karcher mean given a set of points on the Grassmann manifold. The Karcher mean is</span>
<span class="sd">        estimated by the minimization of the Frechet variance, where the Frechet variance corresponds to the sum of the</span>
<span class="sd">        square distances, defined on the Grassmann manifold, to a given point. The command to compute the Karcher mean</span>
<span class="sd">        given a seto of points on the Grassmann manifold is.</span>

<span class="sd">        In this case two values are returned corresponding to the ones related to the manifolds defined by the left and</span>
<span class="sd">        right singular eigenvectors.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **points_grassmann** (`list` or `ndarray`)</span>
<span class="sd">            Matrices (at least 2) corresponding to the points on the Grassmann manifold.</span>
<span class="sd">        </span>
<span class="sd">        * **kwargs** (`dictionary`)</span>
<span class="sd">            Contains the keywords for the used in the optimizers to find the Karcher mean. If ``gradient_descent`` is</span>
<span class="sd">            employed the keywords are `acc`, a boolean variable for the accelerated method; `tol`, tolerance with</span>
<span class="sd">            default value equal to 1e-3; and `maxiter`, maximum number of iterations with default value equal to 1000.</span>
<span class="sd">            If `stochastic_gradient_descent` is employed instead, `acc` is not used.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **kr_mean** (`list`)</span>
<span class="sd">            Karcher mean.</span>
<span class="sd">            </span>
<span class="sd">        * **kr_mean_psi** (`list`)</span>
<span class="sd">            Karcher mean for left singular eigenvectors if `points_grassmann` is not provided.</span>
<span class="sd">            </span>
<span class="sd">        * **kr_mean_phi** (`list`)</span>
<span class="sd">            Karcher mean for right singular eigenvectors if `points_grassmann` is not provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Show an error message if karcher_object is not provided.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">karcher_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `karcher_object` cannot be NoneType&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">karcher_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">karcher_object</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `distance_object` cannot be NoneType&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_object</span>

        <span class="c1"># Compute the Karcher mean for psi and phi if points_grassmann is not provided.</span>
        <span class="k">if</span> <span class="n">points_grassmann</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kr_mean_psi</span> <span class="o">=</span> <span class="n">karcher_fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kr_mean_phi</span> <span class="o">=</span> <span class="n">karcher_fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Return both mean values.  </span>
            <span class="k">return</span> <span class="n">kr_mean_psi</span><span class="p">,</span> <span class="n">kr_mean_phi</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Test the input data for type consistency.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `points_grassmann` must be either list or numpy.ndarray.&#39;</span><span class="p">)</span>

            <span class="c1"># Compute and test the number of input matrices necessary to compute the Karcher mean.</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: At least two matrices must be provided.&#39;</span><span class="p">)</span>

            <span class="c1"># Test the dimensionality of the input data.</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>

            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The input points do not belog to the same manifold.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">p0</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The input points do not belog to the manifold G(n,p).&#39;</span><span class="p">)</span>

            <span class="n">kr_mean</span> <span class="o">=</span> <span class="n">karcher_fun</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">kr_mean</span></div>

<div class="viewcode-block" id="Grassmann.gradient_descent"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.gradient_descent">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gradient_descent</span><span class="p">(</span><span class="n">data_points</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Karcher mean using the gradient descent method.</span>

<span class="sd">        This method computes the Karcher mean given a set of points on the Grassmann manifold. In this regard, the</span>
<span class="sd">        ``gradient_descent`` method is implemented herein also considering the acceleration scheme due to Nesterov.</span>
<span class="sd">        Further, this method is called by the method ``karcher_mean``.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **data_points** (`list`)</span>
<span class="sd">            Points on the Grassmann manifold.</span>
<span class="sd">        </span>
<span class="sd">        * **distance_fun** (`callable`)</span>
<span class="sd">            Distance function.</span>

<span class="sd">        * **kwargs** (`dictionary`)</span>
<span class="sd">            Contains the keywords for the used in the optimizers to find the Karcher mean.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **mean_element** (`list`)</span>
<span class="sd">            Karcher mean.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># acc is a boolean varible to activate the Nesterov acceleration scheme.</span>
        <span class="k">if</span> <span class="s1">&#39;acc&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Error tolerance</span>
        <span class="k">if</span> <span class="s1">&#39;tol&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span>

        <span class="c1"># Maximum number of iterations.</span>
        <span class="k">if</span> <span class="s1">&#39;maxiter&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">maxiter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;maxiter&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="c1"># Number of points.</span>
        <span class="n">n_mat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_points</span><span class="p">)</span>

        <span class="c1"># =========================================</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">rnk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
            <span class="n">rnk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>

        <span class="n">max_rank</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>
        <span class="n">fmean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
            <span class="n">fmean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Grassmann</span><span class="o">.</span><span class="n">frechet_variance</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data_points</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">))</span>

        <span class="n">index_0</span> <span class="o">=</span> <span class="n">fmean</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">fmean</span><span class="p">))</span>
        <span class="n">mean_element</span> <span class="o">=</span> <span class="n">data_points</span><span class="p">[</span><span class="n">index_0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">avg_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">itera</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_gamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">acc</span><span class="p">:</span>
            <span class="n">_gamma</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="n">data_points</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean_element</span><span class="p">))</span>

            <span class="n">avg_gamma</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
                <span class="n">avg_gamma</span> <span class="o">+=</span> <span class="n">_gamma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_mat</span>
            <span class="n">avg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_gamma</span><span class="p">)</span>

        <span class="c1"># Main loop</span>
        <span class="k">while</span> <span class="n">itera</span> <span class="o">&lt;=</span> <span class="n">maxiter</span><span class="p">:</span>
            <span class="n">_gamma</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="n">data_points</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean_element</span><span class="p">))</span>
            <span class="n">avg_gamma</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
                <span class="n">avg_gamma</span> <span class="o">+=</span> <span class="n">_gamma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_mat</span>

            <span class="n">test_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">avg_gamma</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test_0</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">itera</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Nesterov: Accelerated Gradient Descent</span>
            <span class="k">if</span> <span class="n">acc</span><span class="p">:</span>
                <span class="n">avg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_gamma</span><span class="p">)</span>
                <span class="n">l0</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">l</span> <span class="o">*</span> <span class="n">l</span><span class="p">))</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="p">(</span><span class="n">l0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">l1</span>
                <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ls</span><span class="p">)</span> <span class="o">*</span> <span class="n">avg</span><span class="p">[</span><span class="n">itera</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ls</span> <span class="o">*</span> <span class="n">avg</span><span class="p">[</span><span class="n">itera</span><span class="p">]</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">avg_gamma</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">exp_map</span><span class="p">(</span><span class="n">points_tangent</span><span class="o">=</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean_element</span><span class="p">))</span>

            <span class="n">test_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_element</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">test_1</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">mean_element</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mean_element</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">itera</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># return the Karcher mean.</span>
        <span class="k">return</span> <span class="n">mean_element</span></div>

<div class="viewcode-block" id="Grassmann.stochastic_gradient_descent"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.stochastic_gradient_descent">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stochastic_gradient_descent</span><span class="p">(</span><span class="n">data_points</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Karcher mean using the stochastic gradient descent method.</span>

<span class="sd">        This method computes the Karcher mean given a set of points on the Grassmann manifold. In this regard, the</span>
<span class="sd">        ``stochastic_gradient_descent`` method is implemented herein. Further, this method is called by the method</span>
<span class="sd">        ``karcher_mean``.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **data_points** (`list`)</span>
<span class="sd">            Points on the Grassmann manifold.</span>
<span class="sd">            </span>
<span class="sd">        * **distance_fun** (`callable`)</span>
<span class="sd">            Distance function.</span>

<span class="sd">        * **kwargs** (`dictionary`)</span>
<span class="sd">            Contains the keywords for the used in the optimizers to find the Karcher mean.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **mean_element** (`list`)</span>
<span class="sd">            Karcher mean.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;tol&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-3</span>

        <span class="k">if</span> <span class="s1">&#39;maxiter&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">maxiter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;maxiter&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="n">n_mat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_points</span><span class="p">)</span>

        <span class="n">rnk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
            <span class="n">rnk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>

        <span class="n">max_rank</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rnk</span><span class="p">)</span>

        <span class="n">fmean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mat</span><span class="p">):</span>
            <span class="n">fmean</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Grassmann</span><span class="o">.</span><span class="n">frechet_variance</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data_points</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">))</span>

        <span class="n">index_0</span> <span class="o">=</span> <span class="n">fmean</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">fmean</span><span class="p">))</span>

        <span class="n">mean_element</span> <span class="o">=</span> <span class="n">data_points</span><span class="p">[</span><span class="n">index_0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">itera</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_gamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">itera</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_mat</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="n">melem</span> <span class="o">=</span> <span class="n">mean_element</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">k</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">_gamma</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="p">[</span><span class="n">data_points</span><span class="p">[</span><span class="n">idx</span><span class="p">]],</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean_element</span><span class="p">))</span>

                <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">_gamma</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">X</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">exp_map</span><span class="p">(</span><span class="n">points_tangent</span><span class="o">=</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean_element</span><span class="p">))</span>

                <span class="n">_gamma</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">mean_element</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">test_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mean_element</span> <span class="o">-</span> <span class="n">melem</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test_1</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">itera</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">mean_element</span></div>

    <span class="c1"># Private method</span>
<div class="viewcode-block" id="Grassmann.frechet_variance"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.frechet_variance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">frechet_variance</span><span class="p">(</span><span class="n">point_grassmann</span><span class="p">,</span> <span class="n">points_grassmann</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Frechet variance.</span>

<span class="sd">        The Frechet variance corresponds to the summation of the square distances, on the manifold, to a given</span>
<span class="sd">        point also on the manifold. This method is employed in the minimization scheme used to find the Karcher mean.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **point_grassmann** (`list` or `ndarray`)</span>
<span class="sd">            Point on the Grassmann manifold where the Frechet variance is computed.</span>
<span class="sd">            </span>
<span class="sd">        * **points_grassmann** (`list` or `ndarray`)</span>
<span class="sd">            Points on the Grassmann manifold.  </span>
<span class="sd">            </span>
<span class="sd">        * **distance_fun** (`callable`)</span>
<span class="sd">            Distance function.      </span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **frechet_var** (`list`)</span>
<span class="sd">            Frechet variance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_dim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)):</span>
            <span class="n">p_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]))))</span>

        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_grassmann</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nargs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: At least two input matrices must be provided.&#39;</span><span class="p">)</span>

        <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">__estimate_distance</span><span class="p">([</span><span class="n">point_grassmann</span><span class="p">,</span> <span class="n">points_grassmann</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">p_dim</span><span class="p">,</span> <span class="n">distance_fun</span><span class="p">)</span>
            <span class="n">accum</span> <span class="o">+=</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">frechet_var</span> <span class="o">=</span> <span class="n">accum</span> <span class="o">/</span> <span class="n">nargs</span>
        <span class="k">return</span> <span class="n">frechet_var</span></div>

<div class="viewcode-block" id="Grassmann.interpolate"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">element_wise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a point on the Grassmann manifold given the samples in the ambient space (sample space).</span>

<span class="sd">        Interpolate a `point` on the Grassmann manifold given the `coordinates`, support points, and the `samples`.</span>
<span class="sd">        Further, the user must select the option `element_wise` to perform the interpolation in the entries of the input</span>
<span class="sd">        matrices, if `point` and `samples` are matrices. The samples related to `coordinates` are set using</span>
<span class="sd">        `manifold`. For example, the following command is used to perform the interpolation.</span>

<span class="sd">        On the other hand, if a scikit learn gaussian_process object is provided, one can use the following commands:</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **coordinates** (`list` or `ndarray`)</span>
<span class="sd">            Coordinate of the support samples.</span>
<span class="sd">            </span>
<span class="sd">        * **point** (`list` or `ndarray`)</span>
<span class="sd">            Point to be interpolated.      </span>

<span class="sd">        * **element_wise** (`bool`)</span>
<span class="sd">            Element wise interpolation. </span>
<span class="sd">            </span>
<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **interpolated** (`list`)</span>
<span class="sd">            Interpolated point.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find the Karcher mean.</span>
        <span class="n">ref_psi</span><span class="p">,</span> <span class="n">ref_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">karcher_mean</span><span class="p">()</span>

        <span class="c1"># Reshape the vector containing the singular values as a diagonal matrix.</span>
        <span class="n">sigma_m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)):</span>
            <span class="n">sigma_m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Project the points on the manifold to the tangent space created over the Karcher mean.</span>
        <span class="n">gamma_psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_psi</span><span class="p">)</span>
        <span class="n">gamma_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_map</span><span class="p">(</span><span class="n">points_grassmann</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_phi</span><span class="p">)</span>

        <span class="c1"># Perform the interpolation in the tangent space.</span>
        <span class="n">interp_psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_sample</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">gamma_psi</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">,</span>
                                             <span class="n">element_wise</span><span class="o">=</span><span class="n">element_wise</span><span class="p">)</span>
        <span class="n">interp_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_sample</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">gamma_phi</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">,</span>
                                             <span class="n">element_wise</span><span class="o">=</span><span class="n">element_wise</span><span class="p">)</span>
        <span class="n">interp_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_sample</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="n">sigma_m</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">,</span>
                                               <span class="n">element_wise</span><span class="o">=</span><span class="n">element_wise</span><span class="p">)</span>

        <span class="c1"># Map the interpolated point back to the manifold.</span>
        <span class="n">psi_tilde</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_map</span><span class="p">(</span><span class="n">points_tangent</span><span class="o">=</span><span class="p">[</span><span class="n">interp_psi</span><span class="p">],</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_psi</span><span class="p">)</span>
        <span class="n">phi_tilde</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_map</span><span class="p">(</span><span class="n">points_tangent</span><span class="o">=</span><span class="p">[</span><span class="n">interp_phi</span><span class="p">],</span> <span class="n">ref</span><span class="o">=</span><span class="n">ref_phi</span><span class="p">)</span>

        <span class="c1"># Estimate the interpolated solution.</span>
        <span class="n">psi_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psi_tilde</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">phi_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phi_tilde</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">interpolated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_tilde</span><span class="p">,</span> <span class="n">interp_sigma</span><span class="p">),</span> <span class="n">phi_tilde</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interpolated</span></div>

<div class="viewcode-block" id="Grassmann.interpolate_sample"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.interpolate_sample">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">element_wise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a point on the tangent space.</span>

<span class="sd">        Once the points on the Grassmann manifold are projected onto the tangent space standard interpolation can be</span>
<span class="sd">        performed. In this regard, the user should provide the data points, the coordinates of each input data point,</span>
<span class="sd">        and the point to be interpolated. Furthermore, additional parameters, depending on the selected interpolation</span>
<span class="sd">        method, can be provided via kwargs. In comparison to ``interpolate``, here the samples prodived are points on</span>
<span class="sd">        the TANGENT SPACE.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **coordinates** (`list` or `ndarray`)</span>
<span class="sd">            Coordinates of the input data points.</span>

<span class="sd">        * **samples** (`list` or `ndarray`)</span>
<span class="sd">            Matrices corresponding to the points on the tangent space.</span>

<span class="sd">        * **point** (`list` or `ndarray`)</span>
<span class="sd">            Coordinates of the point to be interpolated.</span>

<span class="sd">        * **element_wise** (`bool`)</span>
<span class="sd">            Boolean variable for the element wise intepolation of a matrix.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **interp_point** (`ndarray`)</span>
<span class="sd">            Interpolated point on the tangent space.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="c1"># Test if the sample is stored as a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="c1"># Test if the nodes are stored as a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `interp_object` cannot be NoneType&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span> <span class="ow">is</span> <span class="n">Grassmann</span><span class="o">.</span><span class="n">linear_interp</span><span class="p">:</span>
                <span class="n">element_wise</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span><span class="p">,</span> <span class="n">Kriging</span><span class="p">):</span>
                <span class="c1">#K = self.interp_object</span>
                <span class="n">element_wise</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interp_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span>

        <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">shape_ref</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input matrices have different shape.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">element_wise</span><span class="p">:</span>

            <span class="n">shape_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">interp_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape_ref</span><span class="p">)</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">val_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
                    <span class="n">val_data</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                        <span class="n">val_data</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]])</span>

                    <span class="c1"># if all the elements of val_data are the same.</span>
                    <span class="k">if</span> <span class="n">val_data</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">val_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_data</span><span class="p">):</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val_data</span><span class="p">)</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">val_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val_data</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">skl_str</span> <span class="o">=</span> <span class="s2">&quot;&lt;class &#39;sklearn.gaussian_process.gpr.GaussianProcessRegressor&#39;&gt;&quot;</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span><span class="p">,</span> <span class="n">Kriging</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">skl</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">val_data</span><span class="p">)</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">return_std</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>

                    <span class="n">interp_point</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_object</span><span class="p">,</span> <span class="n">Kriging</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Kriging only can be used in the elementwise interpolation.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interp_point</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interp_point</span></div>

    <span class="c1"># ==================================================================================================================</span>
    <span class="c1"># The pre-defined interpolators are implemented in this section. Any new pre-defined interpolator must be</span>
    <span class="c1"># implemented here with the decorator @staticmethod.</span>

<div class="viewcode-block" id="Grassmann.linear_interp"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.Grassmann.linear_interp">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">linear_interp</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate a point using the linear interpolation.</span>

<span class="sd">        For the linear interpolation the user are asked to provide the data points, the coordinates of the data points,</span>
<span class="sd">        and the coordinate of the point to be interpolated.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **coordinates** (`ndarray`)</span>
<span class="sd">            Coordinates of the input data points.</span>

<span class="sd">        * **samples** (`ndarray`)</span>
<span class="sd">            Matrices corresponding to the points on the Grassmann manifold.</span>

<span class="sd">        * **point** (`ndarray`)</span>
<span class="sd">            Coordinates of the point to be interpolated.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **interp_point** (`ndarray`)</span>
<span class="sd">            Interpolated point.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `coordinates` must be either list or ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `samples` must be either list or ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `point` must be either list or ndarray.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="n">myInterpolator</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
        <span class="n">interp_point</span> <span class="o">=</span> <span class="n">myInterpolator</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="n">interp_point</span> <span class="o">=</span> <span class="n">interp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">interp_point</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                            Diffusion Maps                                                            #</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="DiffusionMaps"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.DiffusionMaps">[docs]</a><span class="k">class</span> <span class="nc">DiffusionMaps</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the diffusion maps on the input data to reveal its lower dimensional embedded geometry.</span>

<span class="sd">    In this class, the diffusion maps create a connection between the spectral properties of the diffusion process and</span>
<span class="sd">    the intrinsic geometry of the data resulting in a multiscale representation of it. In this regard, an affinity</span>
<span class="sd">    matrix containing the degree of similarity of the data points is either estimated based on the euclidean distance,</span>
<span class="sd">    using a Gaussian kernel, or it is computed using any other Kernel definition passed to the main</span>
<span class="sd">    method (e.g., defining a kernel on the Grassmann manifold).</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **alpha** (`float`)</span>
<span class="sd">        Assumes a value between 0 and 1 and corresponding to different diffusion operators. In this regard, one can use</span>
<span class="sd">        this parameter to take into consideration the distribution of the data points on the diffusion process.</span>
<span class="sd">        It happens because the distribution of the data is not necessarily dependent on the geometry of the manifold.</span>
<span class="sd">        Therefore, if alpha` is equal to 1, the Laplace-Beltrami operator is approximated and the geometry of the</span>
<span class="sd">        manifold is recovered without taking the distribution of the points into consideration. On the other hand, when</span>
<span class="sd">        `alpha` is equal to 0.5 the Fokker-Plank operator is approximated and the distribution of points is taken into</span>
<span class="sd">        consideration. Further, when `alpha` is equal to zero the Laplace normalization is recovered.</span>

<span class="sd">    * **n_evecs** (`int`)</span>
<span class="sd">        The number of eigenvectors and eigenvalues used in the representation of the diffusion coordinates.</span>

<span class="sd">    * **sparse** (`bool`)</span>
<span class="sd">        Is a boolean variable to activate the `sparse` mode of the method.</span>

<span class="sd">    * **k_neighbors** (`int`)</span>
<span class="sd">        Used when `sparse` is True to select the k samples close to a given sample in the construction</span>
<span class="sd">        of an sparse graph defining the affinity of the input data. For instance, if `k_neighbors` is equal to 10, only</span>
<span class="sd">        the closest ten points of a given point are connect to a given point in the graph. As a consequence, the</span>
<span class="sd">        obtained affinity matrix is sparse which reduces the computational effort of the eigendecomposition of the</span>
<span class="sd">        transition kernel of the Markov chain.</span>
<span class="sd">        </span>
<span class="sd">    * **kernel_object** (`function`)</span>
<span class="sd">        An object of a callable object used to compute the kernel matrix. Three different options are provided:</span>

<span class="sd">        - Using the ``DiffusionMaps`` method ``gaussian_kernel`` as</span>
<span class="sd">          DiffusionMaps(kernel_object=DiffusionMaps.gaussian_kernel);</span>
<span class="sd">        - Using an user defined function as DiffusionMaps(kernel_object=user_kernel);</span>
<span class="sd">        - Passing a ``Grassmann`` class object DiffusionMaps(kernel_object=Grassmann_Object). In this case, the user has</span>
<span class="sd">          to select ``kernel_grassmann`` in order to define which kernel matrix will be used because when the the</span>
<span class="sd">          ``Grassmann`` class is used in a dataset a kernel matrix can be constructed with both the left and right</span>
<span class="sd">          singular eigenvectors.</span>

<span class="sd">    * **kernel_grassmann** (`str`)</span>
<span class="sd">        It assumes the values &#39;left&#39; and &#39;right&#39; for the left and right singular eigenvectors used to compute the kernel</span>
<span class="sd">        matrix, respectively. Moreover, if &#39;sum&#39; is selected, it means that the kernel matrix is composed by the sum of</span>
<span class="sd">        the kernel matrices estimated using the left and right singular eigenvectors. On the other hand, if &#39;prod&#39; is used</span>
<span class="sd">        instead, it means that the kernel matrix is composed by the product of the matrices estimated using the left and</span>
<span class="sd">        right singular eigenvectors.</span>
<span class="sd">    </span>
<span class="sd">    **Attributes:** </span>
<span class="sd">    </span>
<span class="sd">    * **kernel_matrix** (`ndarray`)</span>
<span class="sd">        Kernel matrix.</span>
<span class="sd">    </span>
<span class="sd">    * **transition_matrix** (`ndarray`)</span>
<span class="sd">        Transition kernel of a Markov chain on the data.</span>
<span class="sd">        </span>
<span class="sd">    * **dcoords** (`ndarray`)</span>
<span class="sd">        Diffusion coordinates</span>
<span class="sd">    </span>
<span class="sd">    * **evecs** (`ndarray`)</span>
<span class="sd">        Eigenvectors of the transition kernel of a Markov chanin on the data.</span>
<span class="sd">    </span>
<span class="sd">    * **evals** (`ndarray`)</span>
<span class="sd">        Eigenvalues of the transition kernel of a Markov chanin on the data.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_evecs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kernel_grassmann</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_evecs</span> <span class="o">=</span> <span class="n">n_evecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span> <span class="o">=</span> <span class="n">k_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="o">=</span> <span class="n">kernel_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="o">=</span> <span class="n">kernel_grassmann</span>

        <span class="c1"># from UQpy.DimensionReduction import Grassmann</span>
        <span class="c1"># from DimensionReduction import Grassmann</span>

        <span class="k">if</span> <span class="n">kernel_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">kernel_object</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel_object</span><span class="p">,</span> <span class="n">Grassmann</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="o">=</span> <span class="n">kernel_object</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either a callable kernel or a Grassmann class object must be provided.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: `alpha` must be a value between 0 and 1.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_evecs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_evecs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: `n_evecs` must be larger than or equal to one.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `n_evecs` must be integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sparse</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `sparse` must be a boolean variable.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sparse</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k_neighbors</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k_neighbors</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: `k_neighbors` must be larger than or equal to one.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: `k_neighbors` must be integer.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="DiffusionMaps.mapping"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.DiffusionMaps.mapping">[docs]</a>    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform diffusion maps to reveal the embedded geometry of datasets.</span>

<span class="sd">        In this method, the users have the option to work with input data defined by subspaces obtained via projection</span>
<span class="sd">        of input data points on the Grassmann manifold, or directly with the input data points. For example,</span>
<span class="sd">        considering that a ``Grassmann`` object is provided using the following command:</span>

<span class="sd">        one can instantiate the DiffusionMaps class and run the diffusion maps as follows:</span>

<span class="sd">        On the other hand, if the user wish to pass a dataset (samples) to compute the diffusion coordinates using the Gaussian</span>
<span class="sd">        kernel, one can use the following commands:</span>

<span class="sd">        In the latest case, if `epsilon` is not provided it is estimated based on the median of the square of the</span>
<span class="sd">        euclidian distances between data points.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **data** (`list`)</span>
<span class="sd">            Data points in the ambient space.</span>
<span class="sd">        </span>
<span class="sd">        * **epsilon** (`floar`)</span>
<span class="sd">            Parameter of the Gaussian kernel.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **dcoords** (`ndarray`)</span>
<span class="sd">            Diffusion coordinates.</span>

<span class="sd">        * **evals** (`ndarray`)</span>
<span class="sd">            eigenvalues.</span>

<span class="sd">        * **evecs** (`ndarray`)</span>
<span class="sd">            eigenvectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">n_evecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_evecs</span>
        <span class="n">sparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
        <span class="n">k_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="p">,</span> <span class="n">Grassmann</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Data cannot be NoneType.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="p">,</span> <span class="n">Grassmann</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: kernel_grassmann is not provided.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">psi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
                <span class="n">kernel_psi</span><span class="p">,</span> <span class="n">kernel_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
                <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">kernel_psi</span> <span class="o">+</span> <span class="n">kernel_phi</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_grassmann</span> <span class="o">==</span> <span class="s1">&#39;prod&#39;</span><span class="p">:</span>
                <span class="n">kernel_psi</span><span class="p">,</span> <span class="n">kernel_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
                <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">kernel_psi</span> <span class="o">*</span> <span class="n">kernel_phi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: the provided kernel_grassmann is not valid.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="o">==</span> <span class="n">DiffusionMaps</span><span class="o">.</span><span class="n">gaussian_kernel</span><span class="p">:</span>
            <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span> <span class="o">!=</span> <span class="n">DiffusionMaps</span><span class="o">.</span><span class="n">gaussian_kernel</span><span class="p">:</span>
            <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_object</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Not valid type for kernel_object&#39;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sparse_kernel</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="p">)</span>

        <span class="c1"># Compute the diagonal matrix D(i,i) = sum(Kernel(i,j)^alpha,j) and its inverse.</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">d_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__d_matrix</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># Compute L^alpha = D^(-alpha)*L*D^(-alpha).</span>
        <span class="n">l_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__l_alpha_normalize</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">,</span> <span class="n">d_inv</span><span class="p">)</span>

        <span class="n">d_star</span><span class="p">,</span> <span class="n">d_star_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__d_matrix</span><span class="p">(</span><span class="n">l_star</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">d_star_invd</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">d_star_inv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d_star_inv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d_star_inv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_star_invd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d_star_inv</span><span class="p">)</span>

        <span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">d_star_invd</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l_star</span><span class="p">)</span>

        <span class="c1"># Find the eigenvalues and eigenvectors of Ps.</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">spsl</span><span class="o">.</span><span class="n">eigs</span><span class="p">(</span><span class="n">transition_matrix</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">n_evecs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LR&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">transition_matrix</span><span class="p">)</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals</span><span class="p">))</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">evecs</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">])</span>

        <span class="c1"># Truncated eigenvalues and eigenvectors</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">n_evecs</span><span class="p">]</span>
        <span class="n">evecs</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_evecs</span><span class="p">]</span>

        <span class="c1"># Compute the diffusion coordinates</span>
        <span class="n">dcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">n_evecs</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_evecs</span><span class="p">):</span>
            <span class="n">dcoords</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">kernel_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">transition_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dcoords</span> <span class="o">=</span> <span class="n">dcoords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evecs</span> <span class="o">=</span> <span class="n">evecs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="n">evals</span>

        <span class="k">return</span> <span class="n">dcoords</span><span class="p">,</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span></div>

<div class="viewcode-block" id="DiffusionMaps.gaussian_kernel"><a class="viewcode-back" href="../../dimension_reduction_doc.html#UQpy.DimensionReduction.DiffusionMaps.gaussian_kernel">[docs]</a>    <span class="k">def</span> <span class="nf">gaussian_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Gaussian Kernel matrix.</span>

<span class="sd">        Estimate the affinity matrix using the Gaussian kernel. If no `epsilon` is provided the method estimates a</span>
<span class="sd">        suitable value taking the median of the square value of the pairwise euclidean distances of the points in the</span>
<span class="sd">        input dataset.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **data** (`list`)</span>
<span class="sd">            Input data.</span>

<span class="sd">        * **epsilon** (`float`)</span>
<span class="sd">            Parameter of the Gaussian kernel.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **Kernel matrix** (`ndarray`)</span>
<span class="sd">            Kernel matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
        <span class="n">k_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span>

        <span class="c1"># Compute the pairwise distances.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Set of 1-D arrays</span>
            <span class="n">distance_pairs</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Set of 2-D arrays</span>
            <span class="c1"># Check arguments: verify the consistency of input arguments.</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">distance_pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">id_pair</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pairs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Point i</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">id_pair</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Point j</span>

                <span class="n">x0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>

                <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span>

                <span class="n">distance_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The size of the input data is not consistent with this method.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute a suitable episilon when it is not provided by the user.</span>
            <span class="c1"># Compute epsilon as the median of the square of the euclidean distances</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distance_pairs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">kernel_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sd</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">distance_pairs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">kernel_matrix</span></div>

    <span class="c1"># Private method</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__sparse_kernel</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method: Construct a sparse kernel.</span>

<span class="sd">        Given the number the k nearest neighbors and a kernel matrix, return a sparse kernel matrix.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **kernel_matrix** (`list` or `ndarray`)</span>
<span class="sd">            Kernel matrix.</span>
<span class="sd">            </span>
<span class="sd">        * **alpha** (`float`)</span>
<span class="sd">            Assumes a value between 0 and 1 and corresponding to different diffusion operators.</span>
<span class="sd">            </span>
<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **D** (`list`)</span>
<span class="sd">            Matrix D.</span>

<span class="sd">        * **D_inv** (`list`)</span>
<span class="sd">            Inverse of matrix D.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">kernel_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">_nn_coord</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="p">)</span>
            <span class="n">kernel_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Consider increasing `k_neighbors` to have a connected graph.&#39;</span><span class="p">)</span>

        <span class="n">sparse_kernel_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sparse_kernel_matrix</span>

    <span class="c1"># Private method</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__d_matrix</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method: Compute the diagonal matrix D and its inverse.</span>

<span class="sd">        In the normalization process we have to estimate matrix D(i,i) = sum(Kernel(i,j)^alpha,j) and its inverse.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **kernel_matrix** (`list` or `ndarray`)</span>
<span class="sd">            Kernel matrix.</span>
<span class="sd">            </span>
<span class="sd">        * **alpha** (`float`)</span>
<span class="sd">            Assumes a value between 0 and 1 and corresponding to different diffusion operators.</span>
<span class="sd">            </span>
<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **d** (`list`)</span>
<span class="sd">            Matrix D.</span>

<span class="sd">        * **d_inv** (`list`)</span>
<span class="sd">            Inverse of matrix D.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">d_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">d_inv</span>

    <span class="c1"># Private method</span>
    <span class="k">def</span> <span class="nf">__l_alpha_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel_mat</span><span class="p">,</span> <span class="n">d_inv</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Private method: Compute and normalize the kernel matrix with the matrix D.</span>

<span class="sd">        In the normalization process we have to estimate matrix D(i,i) = sum(Kernel(i,j)^alpha,j) and its inverse.</span>
<span class="sd">        We now use this information to normalize the kernel matrix.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **kernel_mat** (`list` or `ndarray`)</span>
<span class="sd">            Kernel matrix.</span>

<span class="sd">        * **d_inv** (`list` or `ndarray`)</span>
<span class="sd">            Inverse of matrix D.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **normalized_kernel** (`list` or `ndarray`)</span>
<span class="sd">            Normalized kernel.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">d_inv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">d_alpha</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">d_inv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d_inv</span><span class="p">)</span>

        <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">d_alpha</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kernel_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d_alpha</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">normalized_kernel</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation_doc.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel_doc.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions_doc.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods_doc.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations_doc.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process_doc.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates_doc.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability_doc.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inference_doc.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dimension_reduction_doc.html">DimensionReduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities_doc.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news_doc.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Michael D. Shields.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>