
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>UQpy.SampleMethods &#8212; UQpy v3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for UQpy.SampleMethods</h1><div class="highlight"><pre>
<span></span><span class="c1"># UQpy is distributed under the MIT license.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018  -- Michael D. Shields</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated</span>
<span class="c1"># documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the</span>
<span class="c1"># rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="c1"># persons to whom the Software is furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all copies or substantial portions of the</span>
<span class="c1"># Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span>
<span class="c1"># COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="c1"># OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="sd">&quot;&quot;&quot;This module contains functionality for all the sampling methods supported in ``UQpy``.</span>

<span class="sd">The module currently contains the following classes:</span>

<span class="sd">- ``MCS``: Class to perform Monte Carlo sampling.</span>
<span class="sd">- ``LHS``: Class to perform Latin hypercube sampling.</span>
<span class="sd">- ``MCMC``: Class to perform Markov Chain Monte Carlo sampling.</span>
<span class="sd">- ``IS``: Class to perform Importance sampling.</span>
<span class="sd">- ``AKMCS``: Class to perform adaptive Kriging Monte Carlo sampling.</span>
<span class="sd">- ``STS``: Class to perform stratified sampling.</span>
<span class="sd">- ``RSS``: Class to perform refined stratified sampling.</span>
<span class="sd">- ``Strata``: Class to perform stratification of the unit hypercube.</span>
<span class="sd">- ``Simplex``: Class to uniformly sample from a simplex.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span>

<span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">UQpy.Utilities</span> <span class="k">import</span> <span class="o">*</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Monte Carlo Simulation</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCS">[docs]</a><span class="k">class</span> <span class="nc">MCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Monte Carlo sampling (MCS) of random variables.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        Probability distribution of each random variable. Must be an object (or a list of objects) of the</span>
<span class="sd">        ``Distribution`` class.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to be drawn from each distribution.</span>

<span class="sd">        The ``run`` method is automatically called if `nsamples` is provided. If `nsamples` is not provided, then the</span>
<span class="sd">        ``MCS`` object is created but samples are not generated.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (Boolean):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray` or `list`):</span>
<span class="sd">        Generated samples.</span>

<span class="sd">        If a list of ``DistributionContinuous1D`` objects is provided for ``dist_object``, then `samples` is an</span>
<span class="sd">        `ndarray` with ``samples.shape=(nsamples, len(dist_object))``.</span>

<span class="sd">        If a ``DistributionContinuous1D`` object is provided for ``dist_object`` then `samples` is an array with</span>
<span class="sd">        `samples.shape=(nsamples, 1)``.</span>

<span class="sd">        If a ``DistributionContinuousND`` object is provided for ``dist_object`` then `samples` is an array with</span>
<span class="sd">        ``samples.shape=(nsamples, ND)``.</span>

<span class="sd">        If a list of mixed ``DistributionContinuous1D`` and ``DistributionContinuousND`` objects is provided then</span>
<span class="sd">        `samples` is a list with ``len(samples)=nsamples`` and ``len(samples[i]) = len(dist_object)``.</span>

<span class="sd">    * **samplesU01** (`ndarray` (`list`)):</span>
<span class="sd">        Generated samples transformed to the unit hypercube.</span>

<span class="sd">        This attribute exists only if the ``transform_u01`` method is invoked by the user.</span>


<span class="sd">    **Methods**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Distribution</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="n">add_continuous_1d</span> <span class="o">=</span> <span class="n">add_continuous_1d</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionND</span><span class="p">):</span>
                    <span class="n">add_continuous_nd</span> <span class="o">=</span> <span class="n">add_continuous_nd</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">add_continuous_1d</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A UQpy.Distribution object must be provided.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="c1"># Instantiate the output attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="c1"># Run Monte Carlo sampling</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

<div class="viewcode-block" id="MCS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``MCS`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in the ``MCS`` class. If `nsamples` is</span>
<span class="sd">        provided, the ``run`` method is automatically called when the ``MCS`` object is defined. The user may also call</span>
<span class="sd">        the ``run`` method directly to generate samples. The ``run`` method of the ``MCS`` class can be invoked many</span>
<span class="sd">        times and each time the generated samples are appended to the existing samples.</span>

<span class="sd">        ** Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to be drawn from each distribution.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be appended to the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">            Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">            If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">            object itself can be passed directly.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` attribute of the ``MCS``</span>
<span class="sd">        class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if a random_state is provided.</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Number of samples must be defined.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples should be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Monte Carlo Sampling.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">temp_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                    <span class="n">temp_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: rvs method is missing.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_samples</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
                <span class="n">temp_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp_samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If self.samples already has existing samples, append the new samples to the existing attribute.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Monte Carlo Sampling Complete.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MCS.transform_u01"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCS.transform_u01">[docs]</a>    <span class="k">def</span> <span class="nf">transform_u01</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform random samples to uniform on the unit hypercube.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        The ``transform_u01`` method is an instance method that perform the transformation on an existing ``MCS``</span>
<span class="sd">        object. It takes no input.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``transform_u01`` method has no returns, although it creates and/or appends the `samplesU01` attribute of</span>
<span class="sd">        the ``MCS`` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">zi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">temp_samples_u01</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">][:]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;cdf&#39;</span><span class="p">):</span>
                        <span class="n">zi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: All Distributions must have a cdf method.&#39;</span><span class="p">)</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span>
                <span class="n">temp_samples_u01</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">temp_samples_u01</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Latin hypercube sampling  (LHS)</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="LHS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS">[docs]</a><span class="k">class</span> <span class="nc">LHS</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Latin hypercube sampling (MCS) of random variables.</span>

<span class="sd">    **Input:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">        All distributions in ``LHS`` must be independent. ``LHS`` does not generate correlated random variables.</span>
<span class="sd">        Therefore, for multi-variate designs the `dist_object` must be a list of ``DistributionContinuous1D`` objects</span>
<span class="sd">        or an object of the ``JointInd`` class.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to be drawn from each distribution.</span>

<span class="sd">    * **criterion** (`str` or `callable`):</span>
<span class="sd">        The criterion for pairing the generating sample points</span>
<span class="sd">            Options:</span>
<span class="sd">                1. &#39;random&#39; - completely random. \n</span>
<span class="sd">                2. &#39;centered&#39; - points only at the centre. \n</span>
<span class="sd">                3. &#39;maximin&#39; - maximizing the minimum distance between points. \n</span>
<span class="sd">                4. &#39;correlate&#39; - minimizing the correlation between the points. \n</span>
<span class="sd">                5. `callable` - User-defined method.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">    * ****kwargs**</span>
<span class="sd">        Additional arguments to be passed to the method specified by `criterion`</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        The generated LHS samples.</span>

<span class="sd">    * **samples_U01** (`ndarray`):</span>
<span class="sd">        The generated LHS samples on the unit hypercube.</span>

<span class="sd">    **Methods**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Check if a Distribution object is provided.</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D object must be provided.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D or JointInd object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">,</span> <span class="s1">&#39;maximin&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exit code: Supported lhs criteria: &#39;random&#39;, &#39;centered&#39;, &#39;maximin&#39;, &quot;</span>
                                          <span class="s2">&quot;&#39;correlate&#39;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of samples must be specified.&#39;</span><span class="p">)</span>

        <span class="c1"># Set printing options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="LHS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``LHS`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in the ``LHS`` class. If `nsamples` is</span>
<span class="sd">        provided, the ``run`` method is automatically called when the ``LHS`` object is defined. The user may also call</span>
<span class="sd">        the ``run`` method directly to generate samples. The ``run`` method of the ``LHS`` class cannot be invoked</span>
<span class="sd">        multiple times for sample size extension.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to be drawn from each distribution.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be overwrite the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` and `samples_U01` attributes</span>
<span class="sd">        of the ``LHS`` object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Latin Hypercube sampling...&#39;</span><span class="p">)</span>

        <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;maximin&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_min</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">u_lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: A valid criterion is required.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">u_lhs</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="s1">&#39;icdf&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">u_lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Successful execution of LHS design.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LHS.random"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS.random">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design by sampling randomly inside each bin.</span>

<span class="sd">        The ``random`` method takes a set of samples drawn randomly from within the Latin hypercube bins and performs a</span>
<span class="sd">        random shuffling of them to pair the variables.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The randomly shuffled set of LHS samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">order</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.max_min"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS.max_min">[docs]</a>    <span class="k">def</span> <span class="nf">max_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design that aims to maximize the minimum sample distance.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **iterations** (`int`):</span>
<span class="sd">            The number of iteration to run in the search for a maximin design.</span>

<span class="sd">        * **metric** (`str` or `callable`):</span>
<span class="sd">            The distance metric to use.</span>
<span class="sd">                Options:</span>
<span class="sd">                    1. `str` - Available options are those supported by ``scipy.spatial.distance``</span>
<span class="sd">                    2. User-defined function to compute the distance between samples. This function replaces the</span>
<span class="sd">                       ``scipy.spatial.distance.pdist`` method.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The maximin set of LHS samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span> <span class="s1">&#39;canberra&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;dice&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;kulsinski&#39;</span><span class="p">,</span> <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span> <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span> <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span> <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Exit code: Please provide a string corresponding to a distance metric&quot;</span>
                                          <span class="s2">&quot;supported by scipy.spatial.distance or provide a method to compute a user-&quot;</span>
                                          <span class="s2">&quot;defined distance.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of iterations must be an integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">d_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">pdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="n">d_func</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UQpy: Please provide a valid metric.&quot;</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d_func</span><span class="p">(</span><span class="n">lhs_samples</span><span class="p">)</span>
        <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d_func</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_min_dist</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">max_min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved maximum distance of &#39;</span><span class="p">,</span> <span class="n">max_min_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.correlate"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS.correlate">[docs]</a>    <span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design that aims to minimize spurious correlations.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **iterations** (`int`):</span>
<span class="sd">            The number of iteration to run in the search for a maximin design.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The minimum correlation set of LHS samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: number of iterations must be an integer.&#39;</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">lhs_samples</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="n">samples_try</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">samples_try</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_corr</span><span class="p">:</span>
                <span class="n">min_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r1</span><span class="p">))</span>
                <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">samples_try</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Achieved minimum correlation of &#39;</span><span class="p">,</span> <span class="n">min_corr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div>

<div class="viewcode-block" id="LHS.centered"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.LHS.centered">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">centered</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for generating a Latin hypercube design with samples centered in the bins.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            A set of samples drawn from within each LHS bin. In this method, the samples passed in are not used.</span>

<span class="sd">        * **random_state** (``numpy.random.RandomState`` object):</span>
<span class="sd">            A ``numpy.RandomState`` object that fixes the seed of the pseudo random number generation.</span>

<span class="sd">        * **a** (`ndarray`)</span>
<span class="sd">            An array of the bin lower-bounds.</span>

<span class="sd">        * **b** (`ndarray`)</span>
<span class="sd">            An array of the bin upper-bounds</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **lhs_samples** (`ndarray`)</span>
<span class="sd">            The centered set of LHS samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u_temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">lhs_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">u_temp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs_samples</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">u_temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lhs_samples</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Strata</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="Strata"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Strata">[docs]</a><span class="k">class</span> <span class="nc">Strata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling strata.</span>

<span class="sd">    This is the parent class for all spatial stratifications. This parent class only provides the framework for</span>
<span class="sd">    stratification and cannot be used directly for the stratification. Stratification is done by calling the child</span>
<span class="sd">    class for the desired stratification.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **seeds** (`ndarray`)</span>
<span class="sd">        Define the seed points for the strata. See specific subclass for definition of the seed points.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **seeds** (`ndarray`)</span>
<span class="sd">        Seed points for the strata. See specific subclass for definition of the seed points.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="n">seeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Strata.stratify"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Strata.stratify">[docs]</a>    <span class="k">def</span> <span class="nf">stratify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the stratification of the unit hypercube. It is overwritten by the subclass. This method must exist in</span>
<span class="sd">        any subclass of the ``Strata`` class.</span>

<span class="sd">        **Outputs/Returns:**</span>

<span class="sd">        The method has no returns, but it modifies the relevant attributes of the subclass.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="RectangularStrata"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularStrata">[docs]</a><span class="k">class</span> <span class="nc">RectangularStrata</span><span class="p">(</span><span class="n">Strata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling</span>
<span class="sd">    rectangular strata.</span>

<span class="sd">    ``RectangularStrata`` is a child class of the ``Strata`` class</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **nstrata** (`list` of `int`):</span>
<span class="sd">        A list of length `n` defining the number of strata in each of the `n` dimensions. Creates an equal</span>
<span class="sd">        stratification with strata widths equal to 1/`n_strata`. The total number of strata, `N`, is the product</span>
<span class="sd">        of the terms of `n_strata`.</span>

<span class="sd">        Example: `n_strata` = [2, 3, 2] creates a 3-dimensional stratification with:\n</span>
<span class="sd">                2 strata in dimension 0 with stratum widths 1/2\n</span>
<span class="sd">                3 strata in dimension 1 with stratum widths 1/3\n</span>
<span class="sd">                2 strata in dimension 2 with stratum widths 1/2\n</span>

<span class="sd">        The user must pass one of `nstrata` OR `input_file` OR `seeds` and `widths`</span>

<span class="sd">    * **input_file** (`str`):</span>
<span class="sd">        File path to an input file specifying stratum seeds and stratum widths.</span>

<span class="sd">        This is typically used to define irregular stratified designs.</span>

<span class="sd">        The user must pass one of `n_strata` OR `input_file` OR `seeds` and `widths`</span>

<span class="sd">    * **seeds** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` specifying the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">        coordinates of the stratum orthotope nearest the global origin.</span>

<span class="sd">        Example: A 2-dimensional stratification with 2 equal strata in each dimension:</span>

<span class="sd">            `origins` = [[0, 0], [0, 0.5], [0.5, 0], [0.5, 0.5]]</span>

<span class="sd">        The user must pass one of `n_strata` OR `input_file` OR `seeds` and `widths`</span>

<span class="sd">    * **widths** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` specifying the widths of all strata in each dimension</span>

<span class="sd">        Example: A 2-dimensional stratification with 2 strata in each dimension</span>

<span class="sd">            `widths` = [[0.5, 0.5], [0.5, 0.5], [0.5, 0.5], [0.5, 0.5]]</span>

<span class="sd">        The user must pass one of `n_strata` OR `input_file` OR `seeds` and `widths`</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **nstrata** (`list` of `int`):</span>
<span class="sd">        A list of length `n` defining the number of strata in each of the `n` dimensions. Creates an equal</span>
<span class="sd">        stratification with strata widths equal to 1/`n_strata`. The total number of strata, `N`, is the product</span>
<span class="sd">        of the terms of `n_strata`.</span>

<span class="sd">    * **seeds** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` specifying the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">        coordinates of the stratum orthotope nearest the global origin.</span>

<span class="sd">    * **widths** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` specifying the widths of all strata in each dimension</span>

<span class="sd">    * **volume** (`ndarray`):</span>
<span class="sd">        An array of dimension `(nstrata, )` containing the volume of each stratum. Stratum volumes are equal to the</span>
<span class="sd">        product of the strata widths.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstrata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="n">seeds</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">input_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstrata</span> <span class="o">=</span> <span class="n">nstrata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stratify</span><span class="p">()</span>

<div class="viewcode-block" id="RectangularStrata.stratify"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularStrata.stratify">[docs]</a>    <span class="k">def</span> <span class="nf">stratify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the rectangular stratification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Creating Rectangular stratification ...&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstrata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The strata are not fully defined. Must provide `n_strata`, `input_file`, &#39;</span>
                                       <span class="s1">&#39;or `seeds` and `widths`.&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read the strata from the specified input file</span>
                <span class="c1"># See documentation for input file formatting</span>
                <span class="n">array_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">array_tmp</span><span class="p">[:,</span> <span class="n">array_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>

                <span class="c1"># Check to see that the strata are space-filling</span>
                <span class="n">space_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The stratum design is not space-filling.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">space_fill</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The stratum design is over-filling.&#39;</span><span class="p">)</span>

        <span class="c1"># Define a rectilinear stratification by specifying the number of strata in each dimension via nstrata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fullfact</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstrata</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstrata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstrata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Rectangular stratification created.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectangularStrata.fullfact"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularStrata.fullfact">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fullfact</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a full-factorial design</span>

<span class="sd">        Note: This function has been modified from pyDOE, released under BSD License (3-Clause)\n</span>
<span class="sd">        Copyright (C) 2012 - 2013 - Michael Baudin\n</span>
<span class="sd">        Copyright (C) 2012 - Maria Christopoulou\n</span>
<span class="sd">        Copyright (C) 2010 - 2011 - INRIA - Michael Baudin\n</span>
<span class="sd">        Copyright (C) 2009 - Yann Collette\n</span>
<span class="sd">        Copyright (C) 2009 - CEA - Jean-Marc Martinez\n</span>
<span class="sd">        Original source code can be found at:\n</span>
<span class="sd">        https://pythonhosted.org/pyDOE/#\n</span>
<span class="sd">        or\n</span>
<span class="sd">        https://pypi.org/project/pyDOE/\n</span>
<span class="sd">        or\n</span>
<span class="sd">        https://github.com/tisimst/pyDOE/\n</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **levels** (`list`):</span>
<span class="sd">            A list of integers that indicate the number of levels of each input design factor.</span>

<span class="sd">        **Output:**</span>

<span class="sd">        * **ff** (`ndarray`):</span>
<span class="sd">            Full-factorial design matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Number of factors</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="c1"># Number of combinations</span>
        <span class="n">n_comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_comb</span><span class="p">,</span> <span class="n">n_factors</span><span class="p">))</span>

        <span class="n">level_repeat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">range_repeat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_factors</span><span class="p">):</span>
            <span class="n">range_repeat</span> <span class="o">//=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">lvl</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">level_repeat</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">lvl</span> <span class="o">*</span> <span class="n">range_repeat</span>
            <span class="n">level_repeat</span> <span class="o">*=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ff</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span>

        <span class="k">return</span> <span class="n">ff</span></div>

<div class="viewcode-block" id="RectangularStrata.plot_2d"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularStrata.plot_2d">[docs]</a>    <span class="k">def</span> <span class="nf">plot_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the rectangular stratification.</span>

<span class="sd">        This is an instance method of the ``RectangularStrata`` class that can be called to plot the boundaries of a</span>
<span class="sd">        two-dimensional ``RectangularStrata`` object on :math:`[0, 1]^2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">rect1</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                      <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div></div>


<div class="viewcode-block" id="VoronoiStrata"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiStrata">[docs]</a><span class="k">class</span> <span class="nc">VoronoiStrata</span><span class="p">(</span><span class="n">Strata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling</span>
<span class="sd">    Voronoi strata.</span>

<span class="sd">    ``VoronoiStrata`` is a child class of the ``Strata`` class.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **seeds** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` specifying the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">        coordinates of the point inside each stratum that defines the stratum.</span>

<span class="sd">        The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">    * **nseeds** (`int`):</span>
<span class="sd">        The number of seeds to randomly generate. Seeds are generated by random sampling on the unit hypercube.</span>

<span class="sd">        The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">    * **dimension** (`ndarray`):</span>
<span class="sd">        The dimension of the unit hypercube in which to generate random seeds. Used only if `nseeds` is provided.</span>

<span class="sd">        The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">    * **niters** (`int`)</span>
<span class="sd">        Number of iterations to perform to create a Centroidal Voronoi decomposition.</span>

<span class="sd">        If `niters = 0`, the Voronoi decomposition is based on the provided or generated seeds.</span>

<span class="sd">        If :math:`niters \ge 1`, the seed points are moved to the centroids of the Voronoi cells in each iteration and</span>
<span class="sd">        the a new Voronoi decomposition is performed. This process is repeated `niters` times to create a Centroidal</span>
<span class="sd">        Voronoi decomposition.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **seeds** (`ndarray`):</span>
<span class="sd">        An array of dimension `N x n` containing the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">        coordinates of the point inside each stratum that defines the stratum.</span>

<span class="sd">        If :math:`niters &gt; 1` the `seeds` attribute will differ from the `seeds` input due to the iterations.</span>

<span class="sd">    * **vertices** (`list`)</span>
<span class="sd">        A list of the vertices for each Voronoi stratum on the unit hypercube.</span>

<span class="sd">    * **voronoi** (`object` of ``scipy.spatial.Voronoi``)</span>
<span class="sd">        Defines a Voronoi decomposition of the set of reflected points. When creating the Voronoi decomposition on</span>
<span class="sd">        the unit hypercube, the code reflects the points on the unit hypercube across all faces of the unit hypercube.</span>
<span class="sd">        This causes the Voronoi decomposition to create edges along the faces of the hypercube.</span>

<span class="sd">        This object is not the Voronoi decomposition of the unit hypercube. It is the Voronoi decomposition of all</span>
<span class="sd">        points and their reflections from which the unit hypercube is extracted.</span>

<span class="sd">        To access the vertices in the unit hypercube, see the attribute `vertices`.</span>

<span class="sd">    * **volume** (`ndarray`):</span>
<span class="sd">        An array of dimension `(nstrata, )` containing the volume of each Voronoi stratum in the unit hypercube.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nseeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">niters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="n">seeds</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span> <span class="o">=</span> <span class="n">nseeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niters</span> <span class="o">=</span> <span class="n">niters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voronoi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: Ignoring &#39;nseeds&#39; and &#39;dimension&#39; attributes because &#39;seeds&#39; are provided&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stratify</span><span class="p">()</span>

<div class="viewcode-block" id="VoronoiStrata.stratify"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiStrata.stratify">[docs]</a>    <span class="k">def</span> <span class="nf">stratify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the Voronoi stratification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Creating Voronoi stratification ...&#39;</span><span class="p">)</span>

        <span class="n">initial_seeds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_seeds</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voronoi</span><span class="p">,</span> <span class="n">bounded_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="n">initial_seeds</span><span class="p">)</span>

            <span class="n">cent</span><span class="p">,</span> <span class="n">vol</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">bounded_regions</span><span class="p">:</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">cent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">vol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niters</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">voronoi</span><span class="p">,</span> <span class="n">bounded_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="n">initial_seeds</span><span class="p">)</span>

                <span class="n">cent</span><span class="p">,</span> <span class="n">vol</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">bounded_regions</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
                    <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="n">cent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">vol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

                <span class="n">initial_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cent</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="n">initial_seeds</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Voronoi stratification created.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="VoronoiStrata.voronoi_unit_hypercube"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiStrata.voronoi_unit_hypercube">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">voronoi_unit_hypercube</span><span class="p">(</span><span class="n">seeds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function reflects the seeds across all faces of the unit hypercube and creates a Voronoi decomposition of</span>
<span class="sd">        using all the points and their reflections. This allows a Voronoi decomposition that is bounded on the unit</span>
<span class="sd">        hypercube to be extracted.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **seeds** (`ndarray`):</span>
<span class="sd">            Coordinates of points in the unit hypercube from which to define the Voronoi decomposition.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **vor** (``scipy.spatial.Voronoi`` object):</span>
<span class="sd">            Voronoi decomposition of the complete set of points and their reflections.</span>

<span class="sd">        * **bounded_regions** (see `regions` attribute of ``scipy.spatial.Voronoi``)</span>
<span class="sd">            Indices of the Voronoi vertices forming each Voronoi region for those regions lying inside the unit</span>
<span class="sd">            hypercube.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Voronoi</span>

        <span class="c1"># Mirror the seeds in both low and high directions for each dimension</span>
        <span class="n">bounded_points</span> <span class="o">=</span> <span class="n">seeds</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">seeds_del</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">bounded_points</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">points_temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="o">-</span><span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">seeds_del</span><span class="p">])</span>
                <span class="n">points_temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">seeds_del</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">points_temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">seeds_del</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="o">-</span><span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
                <span class="n">points_temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">seeds_del</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">points_temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">seeds_del</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="o">-</span><span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">seeds_del</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:]])</span>
                <span class="n">points_temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">seeds_del</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">bounded_points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">seeds_del</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:]])</span>
            <span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">points_temp1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">points_temp2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">vor</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">bounded_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bounded_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">regions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vor</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">vor</span><span class="o">.</span><span class="n">point_region</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="n">bounded_regions</span> <span class="o">=</span> <span class="n">regions</span>

        <span class="k">return</span> <span class="n">vor</span><span class="p">,</span> <span class="n">bounded_regions</span></div>

<div class="viewcode-block" id="VoronoiStrata.compute_voronoi_centroid_volume"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiStrata.compute_voronoi_centroid_volume">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the centroid and volume of a Voronoi cell from its vertices.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **vertices** (`ndarray`):</span>
<span class="sd">            Coordinates of the vertices that define the Voronoi cell.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **centroid** (`ndarray`):</span>
<span class="sd">            Centroid of the Voronoi cell.</span>

<span class="sd">        * **volume** (`ndarray`):</span>
<span class="sd">            Volume of the Voronoi cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span><span class="p">,</span> <span class="n">ConvexHull</span>

        <span class="n">tess</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tess</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tess</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="n">dimension</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tess</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">tess</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">tess</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">volume</span>
            <span class="n">cent</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tess</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">tess</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">volume</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cent</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span></div></div>


<div class="viewcode-block" id="DelaunayStrata"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DelaunayStrata">[docs]</a><span class="k">class</span> <span class="nc">DelaunayStrata</span><span class="p">(</span><span class="n">Strata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a geometric decomposition of the n-dimensional unit hypercube into disjoint and space-filling</span>
<span class="sd">        Delaunay strata of n-dimensional simplexes.</span>

<span class="sd">        ``DelaunayStrata`` is a child class of the ``Strata`` class.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **seeds** (`ndarray`):</span>
<span class="sd">            An array of dimension `N x n` specifying the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">            coordinates of the vertices of the Delaunay cells.</span>

<span class="sd">            The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">            Note that, if `seeds` does not include all corners of the unit hypercube, they are added.</span>

<span class="sd">        * **nseeds** (`int`):</span>
<span class="sd">            The number of seeds to randomly generate. Seeds are generated by random sampling on the unit hypercube. In</span>
<span class="sd">            addition, the class also adds seed points at all corners of the unit hypercube.</span>

<span class="sd">            The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">        * **dimension** (`ndarray`):</span>
<span class="sd">            The dimension of the unit hypercube in which to generate random seeds. Used only if `nseeds` is provided.</span>

<span class="sd">            The user must provide `seeds` or `nseeds` and `dimension`</span>

<span class="sd">        * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">            Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">            If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">            object itself can be passed directly.</span>

<span class="sd">        * **verbose** (`Boolean`):</span>
<span class="sd">            A boolean declaring whether to write text to the terminal.</span>


<span class="sd">        **Attributes:**</span>

<span class="sd">        * **seeds** (`ndarray`):</span>
<span class="sd">            An array of dimension `N x n` containing the seeds of all strata. The seeds of the strata are the</span>
<span class="sd">            coordinates of the vertices of the Delaunay cells.</span>

<span class="sd">        * **centroids** (`ndarray`)</span>
<span class="sd">            A list of the vertices for each Voronoi stratum on the unit hypercube.</span>

<span class="sd">        * **delaunay** (`object` of ``scipy.spatial.Delaunay``)</span>
<span class="sd">            Defines a Delaunay decomposition of the set of seed points and all corner points.</span>

<span class="sd">        * **volume** (`ndarray`):</span>
<span class="sd">            An array of dimension `(nstrata, )` containing the volume of each Delaunay stratum in the unit hypercube.</span>

<span class="sd">        **Methods:**</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nseeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">seeds</span><span class="o">=</span><span class="n">seeds</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span> <span class="o">=</span> <span class="n">nseeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delaunay</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: Ignoring &#39;nseeds&#39; and &#39;dimension&#39; attributes because &#39;seeds&#39; are provided&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stratify</span><span class="p">()</span>

<div class="viewcode-block" id="DelaunayStrata.stratify"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DelaunayStrata.stratify">[docs]</a>    <span class="k">def</span> <span class="nf">stratify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">itertools</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Creating Delaaunay stratification ...&#39;</span><span class="p">)</span>

        <span class="n">initial_seeds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seeds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_seeds</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nseeds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Modify seeds to include corner points of (0,1) space</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
        <span class="n">initial_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">initial_seeds</span><span class="p">,</span> <span class="n">corners</span><span class="p">])</span>
        <span class="n">initial_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">initial_seeds</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delaunay</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">initial_seeds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">delaunay</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>  <span class="c1"># extract simplices from Delaunay triangulation</span>
            <span class="n">cent</span><span class="p">,</span> <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_delaunay_centroid_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delaunay</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">sim</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">,</span> <span class="n">cent</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vol</span><span class="p">])])</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Delaunay stratification created.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="DelaunayStrata.compute_delaunay_centroid_volume"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DelaunayStrata.compute_delaunay_centroid_volume">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_delaunay_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the centroid and volume of a Delaunay simplex from its vertices.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **vertices** (`ndarray`):</span>
<span class="sd">            Coordinates of the vertices of the simplex.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **centroid** (`numpy.ndarray`):</span>
<span class="sd">            Centroid of the Delaunay simplex.</span>

<span class="sd">        * **volume** (`numpy.ndarray`):</span>
<span class="sd">            Volume of the Delaunay simplex.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">ConvexHull</span>

        <span class="n">ch</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">volume</span>
        <span class="c1"># ch.volume: float = ch.volume</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Stratified Sampling  (STS)</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="STS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.STS">[docs]</a><span class="k">class</span> <span class="nc">STS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for Stratified Sampling ([9]_).</span>

<span class="sd">    This is the parent class for all stratified sampling methods. This parent class only provides the framework for</span>
<span class="sd">    stratified sampling and cannot be used directly for the sampling. Sampling is done by calling the child</span>
<span class="sd">    class for the desired stratification.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">    * **strata_object** (``Strata`` object)</span>
<span class="sd">        Defines the stratification of the unit hypercube. This must be provided and must be an object of a ``Strata``</span>
<span class="sd">        child class: ``RectangularStrata``, ``VoronoiStrata``, or ``DelaunayStrata``.</span>

<span class="sd">    * **nsamples_per_stratum** (`int` or `list`):</span>
<span class="sd">        Specifies the number of samples in each stratum. This must be either an integer, in which case an equal number</span>
<span class="sd">        of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the list must be</span>
<span class="sd">        equal to the number of strata.</span>

<span class="sd">        If `nsamples_per_stratum` is provided when the class is defined, the ``run`` method will be executed</span>
<span class="sd">        automatically.  If neither `nsamples_per_stratum` or `nsamples` are provided when the class is defined, the user</span>
<span class="sd">        must call the ``run`` method to perform stratified sampling.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Specify the total number of samples. If `nsamples` is specified, the samples will be drawn in proportion to</span>
<span class="sd">        the volume of the strata. Thus, each stratum will contain :math:`round(V_i*nsamples)` samples.</span>

<span class="sd">        If `nsamples` is provided when the class is defined, the ``run`` method will be executed</span>
<span class="sd">        automatically.  If neither `nsamples_per_stratum` or `nsamples` are provided when the class is defined, the user</span>
<span class="sd">        must call the ``run`` method to perform stratified sampling.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">        Default value: False</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        The generated samples following the prescribed distribution.</span>

<span class="sd">    * **samplesU01** (`ndarray`)</span>
<span class="sd">        The generated samples on the unit hypercube.</span>

<span class="sd">    * **weights** (`ndarray`)</span>
<span class="sd">        Individual sample weights.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span> <span class="o">=</span> <span class="n">strata_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="n">nsamples_per_stratum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Check if a Distribution object is provided.</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D object must be provided.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D or JointInd object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">random_state</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: STS object is created&quot;</span><span class="p">)</span>

        <span class="c1"># If nsamples_per_stratum or nsamples is provided, execute run method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="STS.transform_samples"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.STS.transform_samples">[docs]</a>    <span class="k">def</span> <span class="nf">transform_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform samples in the unit hypercube :math:`[0, 1]^n` to the prescribed distribution using the inverse CDF.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **samplesU01** (`ndarray`):</span>
<span class="sd">            `ndarray` containing the generated samples on [0, 1]^dimension.</span>

<span class="sd">        **Outputs:**</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            `ndarray` containing the generated samples following the prescribed distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">samples_u_to_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">samples01</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">samples01</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">samples_u_to_x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">samples01</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples_u_to_x</span></div>

<div class="viewcode-block" id="STS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.STS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes stratified sampling.</span>

<span class="sd">        This method performs the sampling for each of the child classes by running two methods:</span>
<span class="sd">        ``create_samplesu01``, and ``transform_samples``. The ``create_samplesu01`` method is</span>
<span class="sd">        unique to each child class and therefore must be overwritten when a new child class is defined. The</span>
<span class="sd">        ``transform_samples`` method is common to all stratified sampling classes and is therefore defined by the parent</span>
<span class="sd">        class. It does not need to be modified.</span>

<span class="sd">        If `nsamples` or `nsamples_per_stratum` is provided when the class is defined, the ``run`` method will be</span>
<span class="sd">        executed automatically.  If neither `nsamples_per_stratum` or `nsamples` are provided when the class is defined,</span>
<span class="sd">        the user must call the ``run`` method to perform stratified sampling.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples_per_stratum** (`int` or `list`):</span>
<span class="sd">            Specifies the number of samples in each stratum. This must be either an integer, in which case an equal</span>
<span class="sd">            number of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the</span>
<span class="sd">            list must be equal to the number of strata.</span>

<span class="sd">            If `nsamples_per_stratum` is provided when the class is defined, the ``run`` method will be executed</span>
<span class="sd">            automatically.  If neither `nsamples_per_stratum` or `nsamples` are provided when the class is defined, the</span>
<span class="sd">            user must call the ``run`` method to perform stratified sampling.</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Specify the total number of samples. If `nsamples` is specified, the samples will be drawn in proportion to</span>
<span class="sd">            the volume of the strata. Thus, each stratum will contain :math:`round(V_i*nsamples)` samples where</span>
<span class="sd">            :math:`V_i \le 1` is the volume of stratum `i` in the unit hypercube.</span>

<span class="sd">            If `nsamples` is provided when the class is defined, the ``run`` method will be executed</span>
<span class="sd">            automatically.  If neither `nsamples_per_stratum` or `nsamples` are provided when the class is defined, the</span>
<span class="sd">            user must call the ``run`` method to perform stratified sampling.</span>

<span class="sd">        **Outputs:**</span>

<span class="sd">        The ``run`` method has no output, although it modifies the `samples`, `samplesu01`, and `weights` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check inputs of run methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="n">nsamples_per_stratum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_checks</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: Performing Stratified Sampling&quot;</span><span class="p">)</span>

        <span class="c1"># Call &quot;create_sampleu01&quot; method and generate samples in  the unit hypercube</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_samplesu01</span><span class="p">(</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">)</span>

        <span class="c1"># Compute inverse cdf of samplesU01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: Stratified Sampling is completed&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_run_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;UQpy: &#39;nsamples&#39; must be an integer.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: STS class is executing proportional sampling, thus ignoring &quot;</span>
                          <span class="s2">&quot;&#39;nsamples_per_stratum&#39;.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UQpy: Length of &#39;nsamples_per_stratum&#39; must match the number of strata.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UQpy: &#39;nsamples_per_stratum&#39; must be an integer or a list.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Creating dummy method for create_samplesu01. These methods are overwritten in child classes.</span>
<div class="viewcode-block" id="STS.create_samplesu01"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.STS.create_samplesu01">[docs]</a>    <span class="k">def</span> <span class="nf">create_samplesu01</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the specific stratified sampling algorithm. This method is overwritten by each child class of ``STS``.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples_per_stratum** (`int` or `list`):</span>
<span class="sd">            Specifies the number of samples in each stratum. This must be either an integer, in which case an equal</span>
<span class="sd">            number of samples are drawn from each stratum, or a list. If it is provided as a list, the length of the</span>
<span class="sd">            list must be equal to the number of strata.</span>

<span class="sd">            Either `nsamples_per_stratum` or `nsamples` must be provided.</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Specify the total number of samples. If `nsamples` is specified, the samples will be drawn in proportion to</span>
<span class="sd">            the volume of the strata. Thus, each stratum will contain :math:`round(V_i*nsamples)` samples where</span>
<span class="sd">            :math:`V_i \le 1` is the volume of stratum `i` in the unit hypercube.</span>

<span class="sd">            Either `nsamples_per_stratum` or `nsamples` must be provided.</span>

<span class="sd">        **Outputs:**</span>

<span class="sd">        The ``create_samplesu01`` method has no output, although it modifies the `samplesu01` and `weights` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="RectangularSTS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularSTS">[docs]</a><span class="k">class</span> <span class="nc">RectangularSTS</span><span class="p">(</span><span class="n">STS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes Stratified Sampling using Rectangular Stratification.</span>

<span class="sd">    ``RectangularSTS`` is a child class of ``STS``. ``RectangularSTS`` takes in all parameters defined in the parent</span>
<span class="sd">    ``STS`` class with differences note below. Only those inputs and attributes that differ from the parent class are</span>
<span class="sd">    listed below. See documentation for ``STS`` for additional details.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **strata_object** (``RectangularStrata`` object):</span>
<span class="sd">        The `strata_object` for ``RectangularSTS`` must be an object of type ``RectangularStrata`` class.</span>

<span class="sd">    * **sts_criterion** (`str`):</span>
<span class="sd">        Random or Centered samples inside the rectangular strata.</span>
<span class="sd">        Options:</span>
<span class="sd">        1. &#39;random&#39; - Samples are drawn randomly within the strata. \n</span>
<span class="sd">        2. &#39;centered&#39; - Samples are drawn at the center of the strata. \n</span>

<span class="sd">        Default: &#39;random&#39;</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sts_criterion</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strata_object</span><span class="p">,</span> <span class="n">RectangularStrata</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: strata_object must be an object of RectangularStrata class&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">=</span> <span class="n">sts_criterion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random&#39;</span><span class="p">,</span> <span class="s1">&#39;centered&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: Supported sts_criteria: &#39;random&#39;, &#39;centered&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s1">&#39;centered&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UQpy: &#39;nsamples&#39; attribute is not consistent with number of seeds for &#39;centered&#39; &quot;</span>
                                     <span class="s2">&quot;sampling&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples_per_stratum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;centered&quot;</span><span class="p">:</span>
                <span class="n">nsamples_per_stratum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist_object</span><span class="o">=</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="o">=</span><span class="n">strata_object</span><span class="p">,</span>
                         <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="RectangularSTS.create_samplesu01"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularSTS.create_samplesu01">[docs]</a>    <span class="k">def</span> <span class="nf">create_samplesu01</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the ``create_samplesu01`` method in the parent class to generate samples in rectangular strata on the</span>
<span class="sd">        unit hypercube. It has the same inputs and outputs as the ``create_samplesu01`` method in the parent class. See</span>
<span class="sd">        the ``STS`` class for additional details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">samples_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sts_criterion</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                    <span class="n">samples_temp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                                           <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                                           <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                                                           <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples_temp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">samples_in_strata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_temp</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="VoronoiSTS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiSTS">[docs]</a><span class="k">class</span> <span class="nc">VoronoiSTS</span><span class="p">(</span><span class="n">STS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes Stratified Sampling using Voronoi Stratification.</span>

<span class="sd">    ``VoronoiSTS`` is a child class of ``STS``. ``VoronoiSTS`` takes in all parameters defined in the parent</span>
<span class="sd">    ``STS`` class with differences note below. Only those inputs and attributes that differ from the parent class are</span>
<span class="sd">    listed below. See documentation for ``STS`` for additional details.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **strata_object** (``VoronoiStrata`` object):</span>
<span class="sd">        The `strata_object` for ``VoronoiSTS`` must be an object of the ``VoronoiStrata`` class.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Check strata_object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strata_object</span><span class="p">,</span> <span class="n">VoronoiStrata</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: strata_object must be an object of VoronoiStrata class&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist_object</span><span class="o">=</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="o">=</span><span class="n">strata_object</span><span class="p">,</span>
                         <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="VoronoiSTS.create_samplesu01"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiSTS.create_samplesu01">[docs]</a>    <span class="k">def</span> <span class="nf">create_samplesu01</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the ``create_samplesu01`` method in the parent class to generate samples in Voronoi strata on the</span>
<span class="sd">        unit hypercube. It has the same inputs and outputs as the ``create_samplesu01`` method in the parent class. See</span>
<span class="sd">        the ``STS`` class for additional details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span><span class="p">,</span> <span class="n">ConvexHull</span>

        <span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">vertices</span><span class="p">)):</span>  <span class="c1"># For each bounded region (Voronoi stratification)</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">seed_and_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">vertices</span><span class="p">,</span> <span class="n">seed</span><span class="p">])</span>

            <span class="c1"># Create Dealunay Triangulation using seed and vertices of each stratum</span>
            <span class="n">delaunay_obj</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">seed_and_vertices</span><span class="p">)</span>

            <span class="c1"># Compute volume of each delaunay</span>
            <span class="n">volume</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">)):</span>
                <span class="n">vert</span> <span class="o">=</span> <span class="n">delaunay_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">seed_and_vertices</span><span class="p">[</span><span class="n">vert</span><span class="p">])</span>
                <span class="n">volume</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>

            <span class="n">temp_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">delaunay_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>
                <span class="n">simplex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">temp_prob</span><span class="p">)</span>

                <span class="n">new_samples</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">seed_and_vertices</span><span class="p">[</span><span class="n">delaunay_obj</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">simplex</span><span class="p">]],</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                      <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

                <span class="n">samples_in_strata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_samples</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DelaunaySTS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DelaunaySTS">[docs]</a><span class="k">class</span> <span class="nc">DelaunaySTS</span><span class="p">(</span><span class="n">STS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes Stratified Sampling using Delaunay Stratification.</span>

<span class="sd">    ``DelaunaySTS`` is a child class of ``STS``. ``DelaunaySTS`` takes in all parameters defined in the parent</span>
<span class="sd">    ``STS`` class with differences note below. Only those inputs and attributes that differ from the parent class are</span>
<span class="sd">    listed below. See documentation for ``STS`` for additional details.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **strata_object** (``DelaunayStrata`` object):</span>
<span class="sd">        The `strata_object` for ``DelaunaySTS`` must be an object of the ``DelaunayStrata`` class.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strata_object</span><span class="p">,</span> <span class="n">DelaunayStrata</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: strata_object must be an object of DelaunayStrata class&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist_object</span><span class="o">=</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">strata_object</span><span class="o">=</span><span class="n">strata_object</span><span class="p">,</span>
                         <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="n">nsamples_per_stratum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="DelaunaySTS.create_samplesu01"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DelaunaySTS.create_samplesu01">[docs]</a>    <span class="k">def</span> <span class="nf">create_samplesu01</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples_per_stratum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the ``create_samplesu01`` method in the parent class to generate samples in Delaunay strata on the</span>
<span class="sd">        unit hypercube. It has the same inputs and outputs as the ``create_samplesu01`` method in the parent class. See</span>
<span class="sd">        the ``STS`` class for additional details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">delaunay</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>  <span class="c1"># extract simplices from Delaunay triangulation</span>
            <span class="n">samples_temp</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">delaunay</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">simplex</span><span class="p">],</span>
                                   <span class="n">nsamples</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">count</span><span class="p">]),</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">samples_in_strata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samples_temp</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">count</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">count</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span>
                            <span class="n">count</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_stratum</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">samples_in_strata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Refined Stratified Sampling (RSS)</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="RSS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RSS">[docs]</a><span class="k">class</span> <span class="nc">RSS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for Refined Stratified Sampling [10]_, [11]_.</span>

<span class="sd">    This is the parent class for all refined stratified sampling methods. This parent class only provides the</span>
<span class="sd">    framework for refined stratified sampling and cannot be used directly for the sampling. Sampling is done by</span>
<span class="sd">    calling the child class for the desired algorithm.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **sample_object** (``SampleMethods`` object(s)):</span>
<span class="sd">        Generally, this must be an object of a ``UQpy.SampleMethods`` class. Each child class of ``RSS`` has it&#39;s</span>
<span class="sd">        own constraints on which specific types of ``SampleMethods`` it can accept. These are described in the child</span>
<span class="sd">        class documentation below.</span>

<span class="sd">    * **runmodel_object** (``RunModel`` object):</span>
<span class="sd">        A ``RunModel`` object, which is used to evaluate the model.</span>

<span class="sd">        `runmodel_object` is optional. If it is provided, the specific ``RSS`` subclass with use it to compute the</span>
<span class="sd">        gradient of the model in each stratum for gradient-enhanced refined stratified sampling. If it is not</span>
<span class="sd">        provided, the ``RSS`` subclass will default to random stratum refinement.</span>

<span class="sd">    * **krig_object** (`class` object):</span>
<span class="sd">        A object defining a Kriging surrogate model, this object must have ``fit`` and ``predict`` methods.</span>

<span class="sd">        May be an object of the ``UQpy`` ``Kriging`` class or an object of the ``scikit-learn``</span>
<span class="sd">        ``GaussianProcessRegressor``</span>

<span class="sd">        `krig_object` is only used to compute the gradient in gradient-enhanced refined stratified sampling. It must</span>
<span class="sd">        be provided if a `runmodel_object` is provided.</span>

<span class="sd">    * **local** (`Boolean`):</span>
<span class="sd">        In gradient enhanced refined stratified sampling, the gradient is updated after each new sample is added.</span>
<span class="sd">        This parameter is used to determine whether the gradient is updated for every stratum or only locally in the</span>
<span class="sd">        strata nearest the refined stratum.</span>

<span class="sd">        If `local = True`, gradients are only updated in localized regions around the refined stratum.</span>

<span class="sd">        Used only in gradient-enhanced refined stratified sampling.</span>

<span class="sd">    * **max_train_size** (`int`):</span>
<span class="sd">        In gradient enhanced refined stratified sampling, if `local=True` `max_train_size` specifies the number of</span>
<span class="sd">        nearest points at which to update the gradient.</span>

<span class="sd">        Used only in gradient-enhanced refined stratified sampling.</span>

<span class="sd">    * **step_size** (`float`)</span>
<span class="sd">        Defines the size of the step to use for gradient estimation using central difference method.</span>

<span class="sd">        Used only in gradient-enhanced refined stratified sampling.</span>

<span class="sd">    * **qoi_name** (`dict`):</span>
<span class="sd">        Name of the quantity of interest from the `runmodel_object`. If the quantity of interest is a dictionary,</span>
<span class="sd">        this is used to convert it to a list</span>

<span class="sd">        Used only in gradient-enhanced refined stratified sampling.</span>

<span class="sd">    * **n_add** (`int`):</span>
<span class="sd">        Number of samples to be added per iteration.</span>

<span class="sd">        Default: 1.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Total number of samples to be drawn (including the initial samples).</span>

<span class="sd">        If `nsamples` is provided when instantiating the class, the ``run`` method will automatically be called. If</span>
<span class="sd">        `nsamples` is not provided, an ``RSS`` subclass can be executed by invoking the ``run`` method and passing</span>
<span class="sd">        `nsamples`.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">        Default value: False</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    Each of the above inputs are saved as attributes, in addition to the following created attributes.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The generated stratified samples following the prescribed distribution.</span>

<span class="sd">        * **samplesU01** (`ndarray`)</span>
<span class="sd">            The generated samples on the unit hypercube.</span>

<span class="sd">        * **weights** (`ndarray`)</span>
<span class="sd">            Individual sample weights.</span>

<span class="sd">        * **strata_object** (Object of ``Strata`` subclass)</span>
<span class="sd">            Defines the stratification of the unit hypercube. This is an object of the ``Strata`` subclass</span>
<span class="sd">            corresponding to the appropriate strata type.</span>

<span class="sd">        **Methods:**</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Initialize attributes that are common to all approaches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span> <span class="o">=</span> <span class="n">sample_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span> <span class="o">=</span> <span class="n">runmodel_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RunModel&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: runmodel_object must be an object of the RunModel class.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">runmodel_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">local</span> <span class="o">=</span> <span class="n">local</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="o">=</span> <span class="n">max_train_size</span>
            <span class="k">if</span> <span class="n">krig_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">krig_object</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">krig_object</span><span class="p">,</span> <span class="s1">&#39;predict&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: krig_object must have &#39;fit&#39; and &#39;predict&#39; methods.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span> <span class="o">=</span> <span class="n">step_size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - Running the initial sample set.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: GE-RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: RSS - A RSS class object has been initiated.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: nsamples msut be a positive integer.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RSS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RSS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``RSS`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in any ``RSS`` class. If `nsamples` is</span>
<span class="sd">        provided, the ``run`` method is automatically called when the ``RSS`` object is defined. The user may also call</span>
<span class="sd">        the ``run`` method directly to generate samples. The ``run`` method of the ``RSS`` class can be invoked many</span>
<span class="sd">        times and each time the generated samples are appended to the existing samples.</span>

<span class="sd">        The ``run`` method is inherited from the parent class and should not be modified by the subclass. It operates by</span>
<span class="sd">        calling a ``run_rss`` method that is uniquely defined for each subclass. All ``RSS`` subclasses must posses a</span>
<span class="sd">        ``run_rss`` method as defined below.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Total number of samples to be drawn.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be appended to the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        **Output/Return:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples`, `samplesU01, `weights`, and</span>
<span class="sd">        `strata_object` attributes of the ``RSS`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;UQpy: nsamples must be a positive integer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;UQpy Error: The number of requested samples must be larger than the existing &#39;</span>
                                      <span class="s1">&#39;sample set.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">run_rss</span><span class="p">()</span></div>

<div class="viewcode-block" id="RSS.estimate_gradient"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RSS.estimate_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimating gradients with a Kriging metamodel (surrogate).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **x** (`ndarray`):</span>
<span class="sd">            Samples in the training data.</span>

<span class="sd">        * **y** (`ndarray`):</span>
<span class="sd">            Function values evaluated at the samples in the training data.</span>

<span class="sd">        * **xt** (`ndarray`):</span>
<span class="sd">            Samples where gradients need to be evaluated.</span>

<span class="sd">        **Outputs:**</span>

<span class="sd">        * **gr** (`ndarray`):</span>
<span class="sd">            First-order gradient evaluated at the points &#39;xt&#39; using central difference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">nopt</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">predict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">LinearNDInterpolator</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span>

        <span class="n">gr</span> <span class="o">=</span> <span class="n">gradient</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">xt</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="n">tck</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">df_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gr</span></div>

    <span class="k">def</span> <span class="nf">update_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_point</span><span class="p">):</span>
        <span class="c1"># Adding new sample to training points, samplesU01 and samples attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
            <span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_object</span><span class="o">.</span><span class="n">dist_object</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">new_point</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">identify_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strata_metric</span><span class="p">,</span> <span class="n">p_</span><span class="p">):</span>
        <span class="n">bin2break_</span><span class="p">,</span> <span class="n">p_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">p_</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strata_metric</span> <span class="o">==</span> <span class="n">strata_metric</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p_left</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strata_metric</span> <span class="o">==</span> <span class="n">strata_metric</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bin2break_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break_</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
            <span class="n">strata_metric</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_left</span> <span class="o">-=</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strata_metric</span> <span class="o">==</span> <span class="n">strata_metric</span><span class="o">.</span><span class="n">max</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_left</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">bin2break_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">bin2break_</span><span class="p">,</span> <span class="n">tmp</span><span class="p">])</span>
        <span class="n">bin2break_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">bin2break_</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bin2break_</span>

<div class="viewcode-block" id="RSS.run_rss"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RSS.run_rss">[docs]</a>    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is overwritten by each subclass in order to perform the refined stratified sampling.</span>

<span class="sd">        This must be an instance method of the class and, although it has no returns it should appropriately modify the</span>
<span class="sd">        following attributes of the class: `samples`, `samplesU01`, `weights`, `strata_object`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="RectangularRSS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularRSS">[docs]</a><span class="k">class</span> <span class="nc">RectangularRSS</span><span class="p">(</span><span class="n">RSS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes Refined Stratified Sampling using Rectangular Stratification.</span>

<span class="sd">    ``RectangularRSS`` is a child class of ``RSS``. ``RectangularRSS`` takes in all parameters defined in the parent</span>
<span class="sd">    ``RSS`` class with differences note below. Only those inputs and attributes that differ from the parent class</span>
<span class="sd">    are listed below. See documentation for ``RSS`` for additional details.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **sample_object** (``RectangularSTS`` object):</span>
<span class="sd">        The `sample_object` for ``RectangularRSS`` must be an object of the ``RectangularSTS`` class.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_object</span><span class="p">,</span> <span class="n">RectangularSTS</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: sample_object must be an object of the RectangularSTS class.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sample_object</span><span class="o">.</span><span class="n">strata_object</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sample_object</span><span class="o">=</span><span class="n">sample_object</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="n">runmodel_object</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="n">krig_object</span><span class="p">,</span>
                         <span class="n">local</span><span class="o">=</span><span class="n">local</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="n">max_train_size</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="n">qoi_name</span><span class="p">,</span>
                         <span class="n">n_add</span><span class="o">=</span><span class="n">n_add</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="RectangularRSS.run_rss"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.RectangularRSS.run_rss">[docs]</a>    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the ``run_rss`` method in the parent class to perform refined stratified sampling with rectangular</span>
<span class="sd">        strata. It is an instance method that does not take any additional input arguments. See</span>
<span class="sd">        the ``RSS`` class for additional details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gerss</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rss</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span></div>

    <span class="k">def</span> <span class="nf">_gerss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method generates samples using Gradient Enhanced Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing GE-RSS with rectangular stratification...&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the vector of gradients at each training point</span>
        <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="c1"># Primary loop for adding samples and performing refinement.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

            <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
            <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                    <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span>

            <span class="c1"># ################################</span>
            <span class="c1"># --------------------------------</span>
            <span class="c1"># 1. Determine the strata to break</span>
            <span class="c1"># --------------------------------</span>

            <span class="c1"># Compute the gradients at the existing sample points</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span> <span class="o">+</span>
                                                   <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">))</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Recompute the gradient only at the nearest neighbor points.</span>
                <span class="n">dy_dx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                                                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                          <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">+</span>
                                                              <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span>
                                                                  <span class="n">neighbors</span><span class="p">]))</span>

            <span class="c1"># Define the gradient vector for application of the Delta Method</span>
            <span class="n">dy_dx1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Estimate the variance within each stratum by assuming a uniform distribution over the stratum.</span>
            <span class="c1"># All input variables are independent</span>
            <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># Estimate the variance over the stratum by Delta Method</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># &#39;p&#39; is number of samples to be added in the current iteration</span>
            <span class="n">bin2break</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_bins</span><span class="p">(</span><span class="n">strata_metric</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">p_</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># #############################################</span>
            <span class="c1"># ---------------------------------------------</span>
            <span class="c1"># 2. Update each strata and generate new sample</span>
            <span class="c1"># ---------------------------------------------</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="c1"># Update the strata_object for all new points</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="n">new_points</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_stratum_and_generate_sample</span><span class="p">(</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 3. Update sample attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_samples</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="c1"># ###############################</span>
            <span class="c1"># -------------------------------</span>
            <span class="c1"># 4. Execute model at new samples</span>
            <span class="c1"># -------------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_points</span><span class="p">),</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method generates samples using Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing RSS with rectangular stratification...&#39;</span><span class="p">)</span>

        <span class="c1"># Primary loop for adding samples and performing refinement.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>
            <span class="c1"># ################################</span>
            <span class="c1"># --------------------------------</span>
            <span class="c1"># 1. Determine the strata to break</span>
            <span class="c1"># --------------------------------</span>
            <span class="c1"># Estimate the weight corresponding to each stratum</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># &#39;p&#39; is number of samples to be added in the current iteration</span>
            <span class="n">bin2break</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_bins</span><span class="p">(</span><span class="n">strata_metric</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">p_</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># #############################################</span>
            <span class="c1"># ---------------------------------------------</span>
            <span class="c1"># 2. Update each strata and generate new sample</span>
            <span class="c1"># ---------------------------------------------</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="c1"># Update the strata_object for all new points, &#39;p&#39; is number of samples to be added in the current iteration</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="n">new_points</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_stratum_and_generate_sample</span><span class="p">(</span><span class="n">bin2break</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 3. Update sample attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_samples</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_stratum_and_generate_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_</span><span class="p">):</span>
        <span class="c1"># Cut the stratum in the direction of maximum length</span>
        <span class="n">cut_dir_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dir2break</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">cut_dir_temp</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cut_dir_temp</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Divide the stratum bin2break in the direction dir2break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="p">:]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="p">:]])</span>
        <span class="c1"># print(self.samplesU01[bin_, dir2break], self.strata_object.seeds[bin_, dir2break] + \</span>
        <span class="c1">#       self.strata_object.widths[bin_, dir2break])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span>
            <span class="c1"># print(&quot;retain&quot;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span> <span class="o">+</span> \
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="n">bin_</span><span class="p">,</span> <span class="n">dir2break</span><span class="p">]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">bin_</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">bin_</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="n">bin_</span><span class="p">])</span>

        <span class="c1"># Add a uniform random sample inside the new stratum</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">widths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>


<div class="viewcode-block" id="VoronoiRSS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiRSS">[docs]</a><span class="k">class</span> <span class="nc">VoronoiRSS</span><span class="p">(</span><span class="n">RSS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Executes Refined Stratified Sampling using Voronoi Stratification.</span>

<span class="sd">    ``VoronoiRSS`` is a child class of ``RSS``. ``VoronoiRSS`` takes in all parameters defined in the parent</span>
<span class="sd">    ``RSS`` class with differences note below. Only those inputs and attributes that differ from the parent class</span>
<span class="sd">    are listed below. See documentation for ``RSS`` for additional details.</span>

<span class="sd">    **Inputs:**</span>

<span class="sd">    * **sample_object** (``SampleMethods`` object):</span>
<span class="sd">        The `sample_object` for ``VoronoiRSS`` can be an object of any ``SampleMethods`` class that possesses the</span>
<span class="sd">        following attributes: `samples` and `samplesU01`</span>

<span class="sd">        This can be any ``SampleMethods`` object because ``VoronoiRSS`` creates its own `strata_object`. It does not use</span>
<span class="sd">        a `strata_object` inherited from an ``STS`` object.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">step_size</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sample_object</span><span class="p">,</span> <span class="s1">&#39;samplesU01&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span> <span class="o">=</span> <span class="n">VoronoiStrata</span><span class="p">(</span><span class="n">seeds</span><span class="o">=</span><span class="n">sample_object</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sample_object</span><span class="o">=</span><span class="n">sample_object</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="o">=</span><span class="n">runmodel_object</span><span class="p">,</span> <span class="n">krig_object</span><span class="o">=</span><span class="n">krig_object</span><span class="p">,</span>
                         <span class="n">local</span><span class="o">=</span><span class="n">local</span><span class="p">,</span> <span class="n">max_train_size</span><span class="o">=</span><span class="n">max_train_size</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="n">qoi_name</span><span class="p">,</span>
                         <span class="n">n_add</span><span class="o">=</span><span class="n">n_add</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="VoronoiRSS.run_rss"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.VoronoiRSS.run_rss">[docs]</a>    <span class="k">def</span> <span class="nf">run_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overwrites the ``run_rss`` method in the parent class to perform refined stratified sampling with Voronoi</span>
<span class="sd">        strata. It is an instance method that does not take any additional input arguments. See</span>
<span class="sd">        the ``RSS`` class for additional details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gerss</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rss</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span></div>

    <span class="k">def</span> <span class="nf">_gerss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method generates samples using Gradient Enhanced Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_boundary_points_and_construct_delaunay</span><span class="p">()</span>

        <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

        <span class="c1"># Primary loop for adding samples and performing refinement.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

            <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">DelaunayStrata</span><span class="o">.</span><span class="n">compute_delaunay_centroid_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

            <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
            <span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                    <span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span>

            <span class="c1"># ################################</span>
            <span class="c1"># --------------------------------</span>
            <span class="c1"># 1. Determine the strata to break</span>
            <span class="c1"># --------------------------------</span>

            <span class="c1"># Compute the gradients at the existing sample points</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Use the entire sample set to train the surrogate model (more expensive option)</span>
                <span class="n">dy_dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="p">),</span> <span class="n">qoi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use only max_train_size points to train the surrogate model (more economical option)</span>
                <span class="c1"># Build a mapping from the new vertex indices to the old vertex indices.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Find the nearest neighbors to the most recently added point</span>
                <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
                <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_train_size</span><span class="p">)</span>
                <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">))</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># For every simplex, check if at least dimension-1 vertices are in the neighbor set.</span>
                <span class="c1"># Only update the gradient in simplices that meet this criterion.</span>
                <span class="n">update_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">18</span>
                    <span class="n">v_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                    <span class="n">v_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_set</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_list</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_in_U01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">18</span><span class="p">)]))):</span>
                            <span class="n">update_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                <span class="n">update_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">update_list</span><span class="p">)</span>

                <span class="c1"># Initialize the gradient vector</span>
                <span class="n">dy_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>

                <span class="c1"># For those simplices that will not be updated, use the previous gradient</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dy_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dy_dx_old</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">new_to_old</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="p">:]</span>

                <span class="c1"># For those simplices that will be updated, compute the new gradient</span>
                <span class="n">dy_dx</span><span class="p">[</span><span class="n">update_array</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]),</span>
                                                                <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qoi</span><span class="p">)[</span><span class="n">neighbors</span><span class="p">]),</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">update_array</span><span class="p">])</span>

            <span class="c1"># Determine the simplex to break and draw a new sample</span>

            <span class="c1"># Estimate the variance over each simplex by Delta Method. Moments of the simplices are computed using</span>
            <span class="c1"># Eq. (19) from the following reference:</span>
            <span class="c1"># Good, I.J. and Gaskins, R.A. (1971). The Centroid Method of Numerical Integration. Numerische</span>
            <span class="c1">#       Mathematik. 16: 343--359.</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]][:,</span> <span class="n">k</span><span class="p">])</span>
                    <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">var</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">dy_dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">dy_dx_old</span> <span class="o">=</span> <span class="n">dy_dx</span>

            <span class="c1"># &#39;p&#39; is number of samples to be added in the current iteration</span>
            <span class="n">bin2add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_bins</span><span class="p">(</span><span class="n">strata_metric</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">p_</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum variance</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="n">new_points</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_sample</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 2. Update sample attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_samples</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 3. Update strata attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_strata</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="c1"># ###############################</span>
            <span class="c1"># -------------------------------</span>
            <span class="c1"># 4. Execute model at new samples</span>
            <span class="c1"># -------------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method generates samples using Refined Stratified Sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract the boundary vertices and use them in the Delaunay triangulation / mesh generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_boundary_points_and_construct_delaunay</span><span class="p">()</span>

        <span class="c1"># Primary loop for adding samples and performing refinement.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># Number of points to add in this iteration</span>

            <span class="c1"># ################################</span>
            <span class="c1"># --------------------------------</span>
            <span class="c1"># 1. Determine the strata to break</span>
            <span class="c1"># --------------------------------</span>

            <span class="c1"># Compute the centroids and the volumes of each simplex cell in the mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">DelaunayStrata</span><span class="o">.</span><span class="n">compute_delaunay_centroid_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

            <span class="c1"># Determine the simplex to break and draw a new sample</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">nsimplex</span><span class="p">):</span>
                <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># &#39;p&#39; is number of samples to be added in the current iteration</span>
            <span class="n">bin2add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_bins</span><span class="p">(</span><span class="n">strata_metric</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">p_</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

            <span class="c1"># Create &#39;p&#39; sub-simplex within the simplex with maximum variance</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="n">new_points</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_sample</span><span class="p">(</span><span class="n">bin2add</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 2. Update sample attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_samples</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="c1"># ###########################</span>
            <span class="c1"># ---------------------------</span>
            <span class="c1"># 3. Update strata attributes</span>
            <span class="c1"># ---------------------------</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_strata</span><span class="p">(</span><span class="n">new_point</span><span class="o">=</span><span class="n">new_points</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method create a subsimplex inside a Dealaunay Triangle and generate a random sample inside it using</span>
<span class="sd">        Simplex class.</span>


<span class="sd">        **Input:**</span>

<span class="sd">        * **bin_** (`int or float`):</span>
<span class="sd">            Index of delaunay triangle.</span>


<span class="sd">        **Outputt:**</span>

<span class="sd">        * **new** (`ndarray`):</span>
<span class="sd">            An array of new sample.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">itertools</span>
        <span class="n">tmp_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bin_</span><span class="p">),</span> <span class="p">:]]</span>
        <span class="n">col_one</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">)</span>  <span class="c1"># node: an array containing mid-point of edges</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp_vertices</span><span class="p">[</span><span class="n">col_one</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="c1"># Using the Simplex class to generate a new sample in the sub-simplex</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">Simplex</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">sub_simplex</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">_update_strata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method update the `mesh` and `strata_object` attributes of RSS class for each iteration.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **new_point** (`ndarray`):</span>
<span class="sd">            An array of new samples generated at current iteration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p_</span> <span class="o">=</span> <span class="n">new_point</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Update the matrices to have recognize the new point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_</span><span class="p">,</span> <span class="n">i_</span> <span class="o">+</span> <span class="n">p_</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">old_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span>

        <span class="c1"># Update the Delaunay triangulation mesh to include the new point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">add_points</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">new_point</span><span class="p">])</span>

        <span class="c1"># Compute the strata weights.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="p">,</span> <span class="n">bounded_regions</span> <span class="o">=</span> <span class="n">VoronoiStrata</span><span class="o">.</span><span class="n">voronoi_unit_hypercube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplesU01</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">bounded_regions</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span> <span class="o">+</span> <span class="p">[</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">centroid</span><span class="p">,</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">VoronoiStrata</span><span class="o">.</span><span class="n">compute_voronoi_centroid_volume</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_boundary_points_and_construct_delaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method add the corners of [0, 1]^dimension hypercube to the existing samples, which are used to construct a</span>
<span class="sd">        Delaunay Triangulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial.qhull</span> <span class="k">import</span> <span class="n">Delaunay</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">training_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">1e-10</span><span class="p">))</span> <span class="ow">or</span> \
                    <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata_object</span><span class="o">.</span><span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_to_samplesU01</span><span class="p">,</span> <span class="p">])</span>

        <span class="c1"># Define the simplex mesh to be used for gradient estimation and sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_vertices</span><span class="p">,</span> <span class="n">furthest_site</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">)</span></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                        Generating random samples inside a Simplex</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="Simplex"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Simplex">[docs]</a><span class="k">class</span> <span class="nc">Simplex</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate uniform random samples inside an n-dimensional simplex.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **nodes** (`ndarray` or `list`):</span>
<span class="sd">        The vertices of the simplex.</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        The number of samples to be generated inside the simplex.</span>

<span class="sd">        If `nsamples` is provided when the object is defined, the ``run`` method will be called automatically. If</span>
<span class="sd">        `nsamples` is not provided when the object is defined, the user must invoke the ``run`` method and specify</span>
<span class="sd">        `nsamples`.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        New random samples distributed uniformly inside the simplex.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: Size of simplex (nodes) is not consistent.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: Number of samples to be generated &#39;nsamples&#39; should be a positive &quot;</span>
                                          <span class="s2">&quot;integer.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="Simplex.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Simplex.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the random sampling in the ``Simplex`` class.</span>

<span class="sd">        The ``run`` method is the function that performs random sampling in the ``Simplex`` class. If `nsamples` is</span>
<span class="sd">        provided called when the ``Simplex`` object is defined, the ``run`` method is automatically. The user may also</span>
<span class="sd">        call the ``run`` method directly to generate samples. The ``run`` method of the ``Simplex`` class can be invoked</span>
<span class="sd">        many times and each time the generated samples are appended to the existing samples.</span>

<span class="sd">        **Input:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to be generated inside the simplex.</span>

<span class="sd">            If the ``run`` method is invoked multiple times, the newly generated samples will be appended to the</span>
<span class="sd">            existing samples.</span>

<span class="sd">        **Output/Return:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` attribute of the ``Simplex``</span>
<span class="sd">        class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dimension</span><span class="p">])</span>
                <span class="n">ad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">):</span>
                    <span class="n">b_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
                        <span class="n">ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                        <span class="n">b_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="n">ad</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">b_</span><span class="p">))</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="n">sample</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">dimension</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                  Adaptive Kriging-Monte Carlo Simulation (AK-MCS)</span>
<span class="c1">########################################################################################################################</span>
<div class="viewcode-block" id="AKMCS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS">[docs]</a><span class="k">class</span> <span class="nc">AKMCS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adaptively sample for construction of a Kriging surrogate for different objectives including reliability,</span>
<span class="sd">    optimization, and global fit.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">        List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">    * **runmodel_object** (``RunModel`` object):</span>
<span class="sd">        A ``RunModel`` object, which is used to evaluate the model.</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        The initial samples at which to evaluate the model.</span>

<span class="sd">        Either `samples` or `nstart` must be provided.</span>

<span class="sd">    * **krig_object** (`class` object):</span>
<span class="sd">        A Kriging surrogate model, this object must have ``fit`` and ``predict`` methods.</span>

<span class="sd">        May be an object of the ``UQpy`` ``Kriging`` class or an object of the ``scikit-learn``</span>
<span class="sd">        ``GaussianProcessRegressor``</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Total number of samples to be drawn (including the initial samples).</span>

<span class="sd">        If `nsamples` is provided when instantiating the class, the ``run`` method will automatically be called. If</span>
<span class="sd">        `nsamples` is not provided, ``AKMCS`` can be executed by invoking the ``run`` method and passing `nsamples`.</span>

<span class="sd">    * **nlearn** (`int`):</span>
<span class="sd">        Number of samples generated for evaluation of the learning function. Samples for the learning set are drawn</span>
<span class="sd">        using ``LHS``.</span>

<span class="sd">    * **nstart** (`int`):</span>
<span class="sd">        Number of initial samples, randomly generated using ``LHS``.</span>

<span class="sd">        Either `samples` or `nstart` must be provided.</span>

<span class="sd">    * **qoi_name** (`dict`):</span>
<span class="sd">        Name of the quantity of interest. If the quantity of interest is a dictionary, this is used to convert it to</span>
<span class="sd">        a list</span>

<span class="sd">    * **learning_function** (`str` or `function`):</span>
<span class="sd">        Learning function used as the selection criteria to identify new samples.</span>

<span class="sd">        Built-in options:</span>
<span class="sd">                    1. &#39;U&#39; - U-function \n</span>
<span class="sd">                    2. &#39;EFF&#39; - Expected Feasibility Function \n</span>
<span class="sd">                    3. &#39;Weighted-U&#39; - Weighted-U function \n</span>
<span class="sd">                    4. &#39;EIF&#39; - Expected Improvement Function \n</span>
<span class="sd">                    5. &#39;EGIF&#39; - Expected Global Improvement Fit \n</span>

<span class="sd">        `learning_function` may also be passed as a user-defined callable function. This function must accept a Kriging</span>
<span class="sd">        surrogate model object with ``fit`` and ``predict`` methods, the set of learning points at which to evaluate the</span>
<span class="sd">        learning function, and it may also take an arbitrary number of additional parameters that are passed to</span>
<span class="sd">        ``AKMCS`` as `**kwargs`.</span>

<span class="sd">    * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>

<span class="sd">    * **verbose** (`Boolean`):</span>
<span class="sd">        A boolean declaring whether to write text to the terminal.</span>

<span class="sd">        Default value: False.</span>

<span class="sd">    * **kwargs**</span>
<span class="sd">        Used to pass parameters to `learning_function`.</span>

<span class="sd">        For built-in `learning_functions`, see the requisite inputs in the method list below.</span>

<span class="sd">        For user-defined `learning_functions`, these will be defined by the requisite inputs to the user-defined method.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        `ndarray` containing the samples at which the model is evaluated.</span>

<span class="sd">    * **lf_values** (`list`)</span>
<span class="sd">        The learning function evaluated at new sample points.</span>


<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">,</span> <span class="n">runmodel_object</span><span class="p">,</span> <span class="n">krig_object</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nlearn</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                 <span class="n">nstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qoi_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">learning_function</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">n_add</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Initialize the internal variables of the class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span> <span class="o">=</span> <span class="n">runmodel_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span> <span class="o">=</span> <span class="n">nlearn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span> <span class="o">=</span> <span class="n">qoi_name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="n">learning_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span> <span class="o">=</span> <span class="n">dist_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span> <span class="o">=</span> <span class="n">n_add</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_pf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Initialize and run preliminary error checks.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EFF&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">,</span> <span class="s1">&#39;EIF&#39;</span><span class="p">,</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy Error: The provided learning function is not recognized.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">==</span> <span class="s1">&#39;EIGF&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigf</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">==</span> <span class="s1">&#39;EIF&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;eif_stop&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eif_stop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eif</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;u_stop&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">==</span> <span class="s1">&#39;Weighted-U&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;u_stop&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;a&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="s1">&#39;epsilon&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="s1">&#39;eff_stop&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.001</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff</span>

        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist_object</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DistributionContinuous1D</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D object must be provided.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist_object</span><span class="p">,</span> <span class="p">(</span><span class="n">DistributionContinuous1D</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: A DistributionContinuous1D or JointInd object must be provided.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">krig_object</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">krig_object</span><span class="p">,</span> <span class="s1">&#39;predict&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span> <span class="o">=</span> <span class="n">krig_object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: krig_object must have &#39;fit&#39; and &#39;predict&#39; methods.&quot;</span><span class="p">)</span>

        <span class="c1"># If the initial sample design does not exists, run the initial calculations.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: User should provide either &#39;samples&#39; or &#39;nstart&#39; value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Generating the initial sample set using Latin hypercube sampling.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">(</span><span class="n">dist_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nstart</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Running the initial sample set using RunModel.&#39;</span><span class="p">)</span>

        <span class="c1"># Evaluate model at the training points</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: There should be no model evaluation or Number of samples and model &quot;</span>
                                          <span class="s2">&quot;evaluation in RunModel object should be same.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;UQpy: Number of samples to be generated &#39;nsamples&#39; should be a positive &quot;</span>
                                          <span class="s2">&quot;integer.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="AKMCS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the ``AKMCS`` learning iterations.</span>

<span class="sd">        The ``run`` method is the function that performs iterations in the ``AKMCS`` class. If `nsamples` is</span>
<span class="sd">        provided when defining the ``AKMCS`` object, the ``run`` method is automatically called. The user may also</span>
<span class="sd">        call the ``run`` method directly to generate samples. The ``run`` method of the ``AKMCS`` class can be invoked</span>
<span class="sd">        many times.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Total number of samples to be drawn (including the initial samples).</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            Samples at which to evaluate the model.</span>

<span class="sd">        * **append_samples** (`boolean`)</span>
<span class="sd">            Append new samples and model evaluations to the existing samples and model evaluations.</span>

<span class="sd">            If ``append_samples = False``, all previous samples and the corresponding quantities of interest from their</span>
<span class="sd">            model evaluations are deleted.</span>

<span class="sd">            If ``append_samples = True``, samples and their resulting quantities of interest are appended to the</span>
<span class="sd">            existing ones.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The ``run`` method has no returns, although it creates and/or appends the `samples` attribute of the</span>
<span class="sd">        ``AKMCS`` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="n">nsamples</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># New samples are appended to existing samples, if append_samples is TRUE</span>
            <span class="k">if</span> <span class="n">append_samples</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS - Evaluating the model at the sample set using RunModel.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="n">append_samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Performing AK-MCS design...&#39;</span><span class="p">)</span>

        <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span>

        <span class="c1"># Train the initial Kriging model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">predict</span>

        <span class="c1"># ---------------------------------------------</span>
        <span class="c1"># Primary loop for learning and adding samples.</span>
        <span class="c1"># ---------------------------------------------</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">):</span>
            <span class="c1"># Initialize the population of samples at which to evaluate the learning function and from which to draw</span>
            <span class="c1"># in the sampling.</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">learning_set</span> <span class="o">=</span> <span class="n">LHS</span><span class="p">(</span><span class="n">dist_object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nlearn</span><span class="p">,</span>
                                    <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">samples</span>

            <span class="c1"># Find all of the points in the population that have not already been integrated into the training set</span>
            <span class="n">rest_pop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_set</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

            <span class="c1"># Apply the learning function to identify the new point to run the model.</span>

            <span class="n">new_point</span><span class="p">,</span> <span class="n">lf</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span><span class="p">,</span> <span class="n">rest_pop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_add</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_object</span><span class="p">)</span>

            <span class="c1"># Add the new points to the training set and to the sample set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">new_point</span><span class="p">)])</span>

            <span class="c1"># Run the model at the new points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">new_point</span><span class="p">,</span> <span class="n">append_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># If the quantity of interest is a dictionary, convert it to a list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">qoi_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">runmodel_object</span><span class="o">.</span><span class="n">qoi_list</span>

            <span class="c1"># Retrain the surrogate model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qoi</span><span class="p">,</span> <span class="n">nopt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">krig_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">krig_object</span><span class="o">.</span><span class="n">predict</span>

            <span class="c1"># Exit the loop, if error criteria is satisfied</span>
            <span class="k">if</span> <span class="n">ind</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UQpy: Learning stops at iteration: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration:&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: AKMCS complete&#39;</span><span class="p">)</span></div>

    <span class="c1"># ------------------</span>
    <span class="c1"># LEARNING FUNCTIONS</span>
    <span class="c1"># ------------------</span>
<div class="viewcode-block" id="AKMCS.eigf"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.eigf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eigf</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expected Improvement for Global Fit (EIGF) learning function. See [7]_ for a detailed explanation.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **surr** (`class` object):</span>
<span class="sd">            A Kriging surrogate model, this object must have a ``predict`` method as defined in `krig_object` parameter.</span>

<span class="sd">        * **pop** (`ndarray`):</span>
<span class="sd">            An array of samples defining the learning set at which points the EIGF is evaluated</span>

<span class="sd">        * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">        * **parameters** (`dictionary`)</span>
<span class="sd">            Dictionary containing all necessary parameters and the stopping criterion for the learning function. For</span>
<span class="sd">            ``EIGF``, this dictionary is empty as no stopping criterion is specified.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The initial samples at which to evaluate the model.</span>

<span class="sd">        * **qoi** (`list`):</span>
<span class="sd">            A list, which contaains the model evaluations.</span>

<span class="sd">        * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">            List of ``Distribution`` objects corresponding to each random variable.</span>


<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **new_samples** (`ndarray`):</span>
<span class="sd">            Samples selected for model evaluation.</span>

<span class="sd">        * **indicator** (`boolean`):</span>
<span class="sd">            Indicator for stopping criteria.</span>

<span class="sd">            `indicator = True` specifies that the stopping criterion has been met and the AKMCS.run method stops.</span>

<span class="sd">        * **eigf_lf** (`ndarray`)</span>
<span class="sd">            EIGF learning function evaluated at the new sample points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the inconsistency in the shape of &#39;g&#39; and &#39;sig&#39; array</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Evaluation of the learning function</span>
        <span class="c1"># First, find the nearest neighbor in the training set for each point in the population.</span>
        <span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">qoi_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qoi</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)])</span>

        <span class="c1"># Compute the learning function at every point in the population.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">qoi_array</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_add</span><span class="p">):]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">eigf_lf</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">eigf_lf</span><span class="p">,</span> <span class="n">indicator</span></div>

<div class="viewcode-block" id="AKMCS.u"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.u">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        U-function for reliability analysis. See [3] for a detailed explanation.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **surr** (`class` object):</span>
<span class="sd">            A Kriging surrogate model, this object must have a ``predict`` method as defined in `krig_object` parameter.</span>

<span class="sd">        * **pop** (`ndarray`):</span>
<span class="sd">            An array of samples defining the learning set at which points the U-function is evaluated</span>

<span class="sd">        * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">        * **parameters** (`dictionary`)</span>
<span class="sd">            Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here</span>
<span class="sd">            this includes the parameter `u_stop`.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The initial samples at which to evaluate the model.</span>

<span class="sd">        * **qoi** (`list`):</span>
<span class="sd">            A list, which contaains the model evaluations.</span>

<span class="sd">        * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">            List of ``Distribution`` objects corresponding to each random variable.</span>


<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **new_samples** (`ndarray`):</span>
<span class="sd">            Samples selected for model evaluation.</span>

<span class="sd">        * **indicator** (`boolean`):</span>
<span class="sd">            Indicator for stopping criteria.</span>

<span class="sd">            `indicator = True` specifies that the stopping criterion has been met and the AKMCS.run method stops.</span>

<span class="sd">        * **u_lf** (`ndarray`)</span>
<span class="sd">            U learning function evaluated at the new sample points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the inconsistency in the shape of &#39;g&#39; and &#39;sig&#39; array</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="n">n_add</span><span class="p">]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">u_lf</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">u_lf</span><span class="p">,</span> <span class="n">indicator</span></div>

<div class="viewcode-block" id="AKMCS.weighted_u"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.weighted_u">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">weighted_u</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probability Weighted U-function for reliability analysis. See [5]_ for a detailed explanation.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **surr** (`class` object):</span>
<span class="sd">            A Kriging surrogate model, this object must have a ``predict`` method as defined in `krig_object` parameter.</span>

<span class="sd">        * **pop** (`ndarray`):</span>
<span class="sd">            An array of samples defining the learning set at which points the weighted U-function is evaluated</span>

<span class="sd">        * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">        * **parameters** (`dictionary`)</span>
<span class="sd">            Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here</span>
<span class="sd">            this includes the parameter `u_stop`.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The initial samples at which to evaluate the model.</span>

<span class="sd">        * **qoi** (`list`):</span>
<span class="sd">            A list, which contaains the model evaluations.</span>

<span class="sd">        * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">            List of ``Distribution`` objects corresponding to each random variable.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **new_samples** (`ndarray`):</span>
<span class="sd">            Samples selected for model evaluation.</span>

<span class="sd">        * **w_lf** (`ndarray`)</span>
<span class="sd">            Weighted U learning function evaluated at the new sample points.</span>

<span class="sd">        * **indicator** (`boolean`):</span>
<span class="sd">            Indicator for stopping criteria.</span>

<span class="sd">            `indicator = True` specifies that the stopping criterion has been met and the AKMCS.run method stops.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the inconsistency in the shape of &#39;g&#39; and &#39;sig&#39; array</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">p1</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">p2</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_object</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">max_p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">u_</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">((</span><span class="n">max_p</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_p</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">u_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[:</span><span class="n">n_add</span><span class="p">]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;u_stop&#39;</span><span class="p">]:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">w_lf</span> <span class="o">=</span> <span class="n">u_</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">w_lf</span><span class="p">,</span> <span class="n">indicator</span></div>

<div class="viewcode-block" id="AKMCS.eff"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.eff">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eff</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expected Feasibility Function (EFF) for reliability analysis, see [6]_ for a detailed explanation.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **surr** (`class` object):</span>
<span class="sd">            A Kriging surrogate model, this object must have a ``predict`` method as defined in `krig_object` parameter.</span>

<span class="sd">        * **pop** (`ndarray`):</span>
<span class="sd">            An array of samples defining the learning set at which points the EFF is evaluated</span>

<span class="sd">        * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">        * **parameters** (`dictionary`)</span>
<span class="sd">            Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here</span>
<span class="sd">            these include `a`, `epsilon`, and `eff_stop`.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The initial samples at which to evaluate the model.</span>

<span class="sd">        * **qoi** (`list`):</span>
<span class="sd">            A list, which contaains the model evaluations.</span>

<span class="sd">        * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">            List of ``Distribution`` objects corresponding to each random variable.</span>


<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **new_samples** (`ndarray`):</span>
<span class="sd">            Samples selected for model evaluation.</span>

<span class="sd">        * **indicator** (`boolean`):</span>
<span class="sd">            Indicator for stopping criteria.</span>

<span class="sd">            `indicator = True` specifies that the stopping criterion has been met and the AKMCS.run method stops.</span>

<span class="sd">        * **eff_lf** (`ndarray`)</span>
<span class="sd">            EFF learning function evaluated at the new sample points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the inconsistency in the shape of &#39;g&#39; and &#39;sig&#39; array</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Reliability threshold: a_ = 0</span>
        <span class="c1"># EGRA method: epsilon = 2*sigma(x)</span>
        <span class="n">a_</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;eff_a&#39;</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;eff_epsilon&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">sig</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">-</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_</span> <span class="o">+</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span>
        <span class="n">eff</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">a_</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="o">-</span><span class="n">sig</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">t3</span><span class="p">))</span>
        <span class="n">eff</span> <span class="o">+=</span> <span class="n">ep</span> <span class="o">*</span> <span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="o">-</span><span class="n">n_add</span><span class="p">:]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">eff</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;eff_stop&#39;</span><span class="p">]:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">eff_lf</span> <span class="o">=</span> <span class="n">eff</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">eff_lf</span><span class="p">,</span> <span class="n">indicator</span></div>

<div class="viewcode-block" id="AKMCS.eif"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.AKMCS.eif">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eif</span><span class="p">(</span><span class="n">surr</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_add</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">qoi</span><span class="p">,</span> <span class="n">dist_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expected Improvement Function (EIF) for Efficient Global Optimization (EFO). See [4]_ for a detailed</span>
<span class="sd">        explanation.</span>


<span class="sd">        **Inputs:**</span>

<span class="sd">        * **surr** (`class` object):</span>
<span class="sd">            A Kriging surrogate model, this object must have a ``predict`` method as defined in `krig_object` parameter.</span>

<span class="sd">        * **pop** (`ndarray`):</span>
<span class="sd">            An array of samples defining the learning set at which points the EIF is evaluated</span>

<span class="sd">        * **n_add** (`int`):</span>
<span class="sd">            Number of samples to be added per iteration.</span>

<span class="sd">            Default: 1.</span>

<span class="sd">        * **parameters** (`dictionary`)</span>
<span class="sd">            Dictionary containing all necessary parameters and the stopping criterion for the learning function. Here</span>
<span class="sd">            this includes the parameter `eif_stop`.</span>

<span class="sd">        * **samples** (`ndarray`):</span>
<span class="sd">            The initial samples at which to evaluate the model.</span>

<span class="sd">        * **qoi** (`list`):</span>
<span class="sd">            A list, which contaains the model evaluations.</span>

<span class="sd">        * **dist_object** ((list of) ``Distribution`` object(s)):</span>
<span class="sd">            List of ``Distribution`` objects corresponding to each random variable.</span>


<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * **new_samples** (`ndarray`):</span>
<span class="sd">            Samples selected for model evaluation.</span>

<span class="sd">        * **indicator** (`boolean`):</span>
<span class="sd">            Indicator for stopping criteria.</span>

<span class="sd">            `indicator = True` specifies that the stopping criterion has been met and the AKMCS.run method stops.</span>

<span class="sd">        * **eif_lf** (`ndarray`)</span>
<span class="sd">            EIF learning function evaluated at the new sample points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">surr</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Remove the inconsistency in the shape of &#39;g&#39; and &#39;sig&#39; array</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">pop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">fm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">qoi</span><span class="p">)</span>
        <span class="n">eif</span> <span class="o">=</span> <span class="p">(</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">+</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">((</span><span class="n">fm</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">eif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_add</span><span class="p">):]</span>

        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">eif</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fm</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;eif_stop&#39;</span><span class="p">]:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">new_samples</span> <span class="o">=</span> <span class="n">pop</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">eif_lf</span> <span class="o">=</span> <span class="n">eif</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">new_samples</span><span class="p">,</span> <span class="n">eif_lf</span><span class="p">,</span> <span class="n">indicator</span></div></div>

<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Class Markov Chain Monte Carlo</span>
<span class="c1">########################################################################################################################</span>


<div class="viewcode-block" id="MCMC"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCMC">[docs]</a><span class="k">class</span> <span class="nc">MCMC</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate samples from arbitrary user-specified probability density function using Markov Chain Monte Carlo.</span>

<span class="sd">    This is the parent class for all MCMC algorithms. This parent class only provides the framework for MCMC and cannot</span>
<span class="sd">    be used directly for sampling. Sampling is done by calling the child class for the specific MCMC algorithm.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **dimension** (`int`):</span>
<span class="sd">        A scalar value defining the dimension of target density function. Either `dimension` and `nchains` or `seed`</span>
<span class="sd">        must be provided.</span>

<span class="sd">    * **pdf_target** ((`list` of) callables):</span>
<span class="sd">        Target density function from which to draw random samples. Either `pdf_target` or `log_pdf_target` must be</span>
<span class="sd">        provided (the latter should be preferred for better numerical stability).</span>

<span class="sd">        If `pdf_target` is a callable, it refers to the joint pdf to sample from, it must take at least one input `x`,</span>
<span class="sd">        which are the point(s) at which to evaluate the pdf. Within MCMC the `pdf_target` is evaluated as:</span>
<span class="sd">        ``p(x) = pdf_target(x, *args_target)``</span>

<span class="sd">        where `x` is a ndarray of shape (nsamples, dimension) and `args_target` are additional positional arguments that</span>
<span class="sd">        are provided to MCMC via its `args_target` input.</span>

<span class="sd">        If `pdf_target` is a list of callables, it refers to independent marginals to sample from. The marginal in</span>
<span class="sd">        dimension `j` is evaluated as: ``p_j(xj) = pdf_target[j](xj, *args_target[j])`` where `x` is a ndarray of shape</span>
<span class="sd">        (nsamples, dimension)</span>

<span class="sd">    * **log_pdf_target** ((`list` of) callables):</span>
<span class="sd">        Logarithm of the target density function from which to draw random samples. Either `pdf_target` or</span>
<span class="sd">        `log_pdf_target` must be provided (the latter should be preferred for better numerical stability).</span>

<span class="sd">        Same comments as for input `pdf_target`.</span>

<span class="sd">    * **args_target** ((`list` of) `tuple`):</span>
<span class="sd">        Positional arguments of the pdf / log-pdf target function. See `pdf_target`</span>

<span class="sd">    * **seed** (`ndarray`):</span>
<span class="sd">        Seed of the Markov chain(s), shape ``(nchains, dimension)``. Default: zeros(`nchains` x `dimension`).</span>

<span class="sd">        If `seed` is not provided, both `nchains` and `dimension` must be provided.</span>

<span class="sd">    * **nburn** (`int`):</span>
<span class="sd">        Length of burn-in - i.e., number of samples at the beginning of the chain to discard (note: no thinning during</span>
<span class="sd">        burn-in). Default is 0, no burn-in.</span>

<span class="sd">    * **jump** (`int`):</span>
<span class="sd">        Thinning parameter, used to reduce correlation between samples. Setting `jump=n` corresponds to	skipping `n-1`</span>
<span class="sd">        states between accepted states of the chain. Default is 1 (no thinning).</span>

<span class="sd">    * **nchains** (`int`):</span>
<span class="sd">        The number of Markov chains to generate. Either `dimension` and `nchains` or `seed` must be provided.</span>

<span class="sd">    * **save_log_pdf** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to save log-pdf values along with the samples. Default: False</span>

<span class="sd">    * **verbose** (`boolean`)</span>
<span class="sd">        Set ``verbose = True`` to print status messages to the terminal during execution.</span>

<span class="sd">    * **concat_chains** (`bool`):</span>
<span class="sd">        Boolean that indicates whether to concatenate the chains after a run, i.e., samples are stored as an `ndarray`</span>
<span class="sd">        of shape (nsamples * nchains, dimension) if True, (nsamples, nchains, dimension) if False. Default: True</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`)</span>
<span class="sd">        Set of MCMC samples following the target distribution, `ndarray` of shape (`nsamples` * `nchains`, `dimension`)</span>
<span class="sd">        or (nsamples, nchains, dimension) (see input `concat_chains`).</span>

<span class="sd">    * **log_pdf_values** (`ndarray`)</span>
<span class="sd">        Values of the log pdf for the accepted samples, `ndarray` of shape (nchains * nsamples,) or (nsamples, nchains)</span>

<span class="sd">    * **nsamples** (`list`)</span>
<span class="sd">        Total number of samples; The `nsamples` attribute tallies the total number of generated samples. After each</span>
<span class="sd">        iteration, it is updated by 1. At the end of the simulation, the `nsamples` attribute equals the user-specified</span>
<span class="sd">        value for input `nsamples` given to the child class.</span>

<span class="sd">    * **nsamples_per_chain** (`list`)</span>
<span class="sd">        Total number of samples per chain; Similar to the attribute `nsamples`, it is updated during iterations as new</span>
<span class="sd">        samples are saved.</span>

<span class="sd">    * **niterations** (`list`)</span>
<span class="sd">        Total number of iterations, updated on-the-fly as the algorithm proceeds. It is related to number of samples as</span>
<span class="sd">        niterations=nburn+jump*nsamples_per_chain.</span>

<span class="sd">    * **acceptance_rate** (`list`)</span>
<span class="sd">        Acceptance ratio of the MCMC chains, computed separately for each chain.</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/20 by Audrey Olivier</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nburn</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nburn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nburn should be an integer &gt;= 0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">jump</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jump</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: jump should be an integer &gt;= 1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">=</span> <span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Check target pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span>
            <span class="n">pdf_</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span> <span class="o">=</span> <span class="n">save_log_pdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span> <span class="o">=</span> <span class="n">concat_chains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_target</span> <span class="o">=</span> <span class="n">log_pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdf_target</span> <span class="o">=</span> <span class="n">pdf_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_target</span> <span class="o">=</span> <span class="n">args_target</span>

        <span class="c1"># Initialize a few more variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total nb of iterations, grows if you call run several times</span>

<div class="viewcode-block" id="MCMC.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCMC.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run the MCMC algorithm.</span>

<span class="sd">        This function samples from the MCMC chains and appends samples to existing ones (if any). This method leverages</span>
<span class="sd">        the ``run_iterations`` method that is specific to each algorithm.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`):</span>
<span class="sd">            Number of samples to generate.</span>

<span class="sd">        * **nsamples_per_chain** (`int`)</span>
<span class="sd">            Number of samples to generate per chain.</span>

<span class="sd">        Either `nsamples` or `nsamples_per_chain` must be provided (not both). Not that if `nsamples` is not a multiple</span>
<span class="sd">        of `nchains`, `nsamples` is set to the next largest integer that is a multiple of `nchains`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize the runs: allocate space for the new samples and log pdf values</span>
        <span class="n">final_nsamples</span><span class="p">,</span> <span class="n">final_nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_samples</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running MCMC...&#39;</span><span class="p">)</span>

        <span class="c1"># Run nsims iterations of the MCMC algorithm, starting at current_state</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">&lt;</span> <span class="n">final_nsamples_per_chain</span><span class="p">:</span>
            <span class="c1"># update the total number of iterations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># run iteration</span>
            <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_one_iteration</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)</span>
            <span class="c1"># Update the chain, only if burn-in is over and the sample is not being jumped over</span>
            <span class="c1"># also increase the current number of samples and samples_per_chain</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">jump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: MCMC run successfully !&#39;</span><span class="p">)</span>

        <span class="c1"># Concatenate chains maybe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_chains</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_concatenate_chains</span><span class="p">()</span></div>

<div class="viewcode-block" id="MCMC.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MCMC.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC algorithm, starting at `current_state`.</span>

<span class="sd">        This method is over-written for each different MCMC algorithm. It must return the new state and associated</span>
<span class="sd">        log-pdf, which will be passed as inputs to the ``run_one_iteration`` method at the next iteration.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **current_state** (`ndarray`):</span>
<span class="sd">            Current state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **current_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the current state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        **Outputs/Returns:**</span>

<span class="sd">        * **new_state** (`ndarray`):</span>
<span class="sd">            New state of the chain(s), `ndarray` of shape ``(nchains, dimension)``.</span>

<span class="sd">        * **new_log_pdf** (`ndarray`):</span>
<span class="sd">            Log-pdf of the new state of the chain(s), `ndarray` of shape ``(nchains, )``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span></div>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Helper functions that can be used by all algorithms</span>
    <span class="c1"># Methods update_samples, update_accept_ratio and sample_candidate_from_proposal can be called in the run stage.</span>
    <span class="c1"># Methods preprocess_target, preprocess_proposal, check_seed and check_integers can be called in the init stage.</span>

    <span class="k">def</span> <span class="nf">_concatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples, nchains, dimension) to</span>
<span class="sd">        (nsamples * nchains, dimension), and log_pdf_values from (nsamples, nchains) to (nsamples * nchains, ).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_unconcatenate_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of concatenate_chains.</span>

<span class="sd">        Utility function that reshapes (in place) attribute samples from (nsamples * nchains, dimension) to</span>
<span class="sd">        (nsamples, nchains, dimension), and log_pdf_values from (nsamples * nchains) to (nsamples, nchains).</span>

<span class="sd">        No input / output.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize necessary attributes and variables before running the chain forward.</span>

<span class="sd">        Utility function that allocates space for samples and log likelihood values, initialize sample_index,</span>
<span class="sd">        acceptance ratio. If some samples already exist, allocate space to append new samples to the old ones. Computes</span>
<span class="sd">        the number of forward iterations nsims to be run (depending on burnin and jump parameters).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * nchains (int): number of chains run in parallel</span>
<span class="sd">        * nsamples (int): number of samples to be generated</span>
<span class="sd">        * nsamples_per_chain (int): number of samples to be generated per chain</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * nsims (int): Number of iterations to perform</span>
<span class="sd">        * current_state (ndarray of shape (nchains, dim)): Current state of the chain to start from.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either nsamples or nsamples_per_chain must be provided (not both)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples_per_chain</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples_per_chain must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: nsamples must be an integer &gt;= 0.&#39;</span><span class="p">)</span>
            <span class="n">nsamples_per_chain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># very first call of run, set current_state as the seed and initialize self.samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nburn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>    <span class="c1"># if nburn is 0, save the seed, run one iteration less </span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_log_pdf</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span>
            <span class="n">final_nsamples</span><span class="p">,</span> <span class="n">final_nsamples_per_chain</span> <span class="o">=</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span>

        <span class="k">else</span><span class="p">:</span>    <span class="c1"># fetch previous samples to start the new run, current state is last saved sample</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>   <span class="c1"># the chains were previously concatenated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenate_chains</span><span class="p">()</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsamples_per_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">final_nsamples</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span>
            <span class="n">final_nsamples_per_chain</span> <span class="o">=</span> <span class="n">nsamples_per_chain</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span>

        <span class="k">return</span> <span class="n">final_nsamples</span><span class="p">,</span> <span class="n">final_nsamples_per_chain</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span>

    <span class="k">def</span> <span class="nf">_update_acceptance_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_accept</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update acceptance rate of the chains.</span>

<span class="sd">        Utility function, uses an iterative function to update the acceptance rate of all the chains separately.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * new_accept (list (length nchains) of bool): indicates whether the current state was accepted (for each chain</span>
<span class="sd">          separately).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span> <span class="o">=</span> <span class="p">[</span><span class="n">na</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">*</span> <span class="n">a</span>
                                <span class="k">for</span> <span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_accept</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_rate</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">,</span> <span class="n">pdf_</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x. If the target is given as a list of callables (marginal pdfs), the list of</span>
<span class="sd">        log margianals is also returned.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf_ ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided.</span>
<span class="sd">        * pdf_ ((list of) callables): Target density function from which to draw random samples. Either pdf_target or</span>
<span class="sd">          log_pdf_target must be provided.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target.</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>
<span class="sd">        * evaluate_log_pdf_marginals (list of callables): List of callables to compute the log pdf of the marginals</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">log_pdf_</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When log_pdf_target is a list, args should be a list (of tuples) of same &#39;</span>
                                     <span class="s1">&#39;length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf_</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">))))</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">log_pdf_</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">))]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf_</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pdf_</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pdf_</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf_</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdf_</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: When pdf_target is given as a list, args should also be a list of same &#39;</span>
                                     <span class="s1">&#39;length.&#39;</span><span class="p">)</span>
                <span class="n">evaluate_log_pdf_marginals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf_</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                              <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))),</span>
                        <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf_</span><span class="p">))</span>
                        <span class="p">))</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf_</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">))]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: pdf_target must be a callable or list of callables&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span><span class="p">,</span> <span class="n">evaluate_log_pdf_marginals</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">nchains</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess input seed.</span>

<span class="sd">        Utility function (static method), that checks the dimension of seed, assign [0., 0., ..., 0.] if not provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * seed (ndarray): seed for MCMC</span>
<span class="sd">        * dim (int): dimension of target density</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nchains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either `seed` or `dimension` and `nchains` must be provided.&#39;</span><span class="p">)</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchains</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input seed should be an array of shape (dimension, ) or (nchains, dimension).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Wrong dimensions between seed and dimension.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nchains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nchains</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: The number of chains and the seed shape are inconsistent.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seed</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_methods_proposal</span><span class="p">(</span><span class="n">proposal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if proposal has required methods.</span>

<span class="sd">        Utility function (static method), that checks that the given proposal distribution has 1) a rvs method and 2) a</span>
<span class="sd">        log pdf or pdf method. If a pdf method exists but no log_pdf, the log_pdf methods is added to the proposal</span>
<span class="sd">        object. Used in the MH and MMH initializations.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * proposal (Distribution object): proposal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal should be a Distribution object&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span></div>


<span class="c1">#################################################################################################################</span>


<div class="viewcode-block" id="MH"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MH">[docs]</a><span class="k">class</span> <span class="nc">MH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings algorithm</span>

<span class="sd">    **References**</span>

<span class="sd">    1. Gelman et al., &quot;Bayesian data analysis&quot;, Chapman and Hall/CRC, 2013</span>
<span class="sd">    2. R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>


<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal distribution, must have a log_pdf/pdf and rvs method. Default: standard multivariate normal</span>

<span class="sd">    * **proposal_is_symmetric** (`bool`):</span>
<span class="sd">        Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False, set to True if default proposal is used</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># Initialize algorithm specific inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either input proposal or dimension must be provided.&#39;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">JointInd</span><span class="p">,</span> <span class="n">Normal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">JointInd</span><span class="p">([</span><span class="n">Normal</span><span class="p">()]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="MH.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MH.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compute acceptance ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">:</span>  <span class="c1"># proposal is symmetric</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
            <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidate</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">)</span> <span class="o">-</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">current_state</span> <span class="o">-</span> <span class="n">candidate</span><span class="p">)</span>
            <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,))</span>  <span class="c1"># this vector will be used to compute accept_ratio of each chain</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>


<span class="c1">####################################################################################################################</span>

<div class="viewcode-block" id="MMH"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MMH">[docs]</a><span class="k">class</span> <span class="nc">MMH</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Component-wise Modified Metropolis-Hastings algorithm.</span>

<span class="sd">    In this algorithm, candidate samples are drawn separately in each dimension, thus the proposal consists of a list</span>
<span class="sd">    of 1d distributions. The target pdf can be given as a joint pdf or a list of marginal pdfs in all dimensions. This</span>
<span class="sd">    will trigger two different algorithms.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. S.-K. Au and J. L. Beck,“Estimation of small failure probabilities in high dimensions by subset simulation,”</span>
<span class="sd">       Probabilistic Eng. Mech., vol. 16, no. 4, pp. 263–277, Oct. 2001.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **proposal** ((`list` of) ``Distribution`` object(s)):</span>
<span class="sd">        Proposal distribution(s) in one dimension, must have a log_pdf/pdf and rvs method.</span>

<span class="sd">        The proposal object may be a list of ``DistributionContinuous1D`` objects or a ``JointInd`` object.</span>
<span class="sd">        Default: standard normal</span>

<span class="sd">    * **proposal_is_symmetric** ((`list` of) `bool`):</span>
<span class="sd">        Indicates whether the proposal distribution is symmetric, affects computation of acceptance probability alpha</span>
<span class="sd">        Default: False, set to True if default proposal is used</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proposal_is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># If proposal is not provided: set it as a list of standard gaussians</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">Normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="n">proposal_is_symmetric</span>

        <span class="c1"># set default proposal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="n">Normal</span><span class="p">(),</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="c1"># Proposal is provided, check it</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only one Distribution is provided, check it and transform it to a list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">JointInd</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">marginals</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal given as a list should be of length dimension&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># a list of proposals is provided</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal given as a list should be of length dimension&#39;</span><span class="p">)</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_methods_proposal</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">]</span>

        <span class="c1"># check the symmetry of proposal, assign False as default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Proposal_is_symmetric should be a (list of) boolean(s)&#39;</span><span class="p">)</span>

        <span class="c1"># check with algo type is used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;marginals&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">=</span> <span class="s1">&#39;joint&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="MMH.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.MMH.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for MMH algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The target pdf is provided via its marginals</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_type</span> <span class="o">==</span> <span class="s1">&#39;marginals&#39;</span><span class="p">:</span>
            <span class="c1"># Evaluate the current log_pdf</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                                                  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)]</span>

            <span class="c1"># Sample candidate (independently in each dimension)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="n">candidate_j</span><span class="p">)</span>

                <span class="c1"># Compute acceptance ratio</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span>
                                          <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">))</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate_j</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">current_log_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_log_pdf_marginals</span><span class="p">)</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="c1"># The target pdf is provided as a joint pdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">):</span>
                <span class="n">candidate_j</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_j</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Compute log_pdf_target of candidate sample</span>
                <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

                <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_is_symmetric</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># proposal is symmetric</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If the proposal is non-symmetric, one needs to account for it in computing acceptance ratio</span>
                    <span class="n">log_prop_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">log_pdf</span>
                    <span class="n">log_proposal_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_prop_j</span><span class="p">(</span><span class="n">candidate_j</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">-</span>
                                          <span class="n">log_prop_j</span><span class="p">(</span><span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">candidate_j</span><span class="p">))</span>
                    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">log_p_candidate</span> <span class="o">-</span> <span class="n">current_log_pdf</span> <span class="o">-</span> <span class="n">log_proposal_ratio</span>
                <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">r_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate_j</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">log_ratios</span><span class="p">)):</span>
                    <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">r_</span>
                    <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                        <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                        <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                        <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">candidate</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="Stretch"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Stretch">[docs]</a><span class="k">class</span> <span class="nc">Stretch</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Affine-invariant sampler with Stretch moves, parallel implementation.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. J. Goodman and J. Weare, “Ensemble samplers with affine invariance,” Commun. Appl. Math. Comput. Sci.,vol.5,</span>
<span class="sd">       no. 1, pp. 65–80, 2010.</span>
<span class="sd">    2. Daniel Foreman-Mackey, David W. Hogg, Dustin Lang, and Jonathan Goodman. &quot;emcee: The MCMC Hammer&quot;.</span>
<span class="sd">       Publications of the Astronomical Society of the Pacific, 125(925):306–312,2013.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **scale** (`float`):</span>
<span class="sd">        Scale parameter. Default: 2.</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scale</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">flag_seed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nchains</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Either `seed` or `dimension` and `nchains` must be provided.&#39;</span><span class="p">)</span>
            <span class="n">flag_seed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># Check nchains = ensemble size for the Stretch algorithm</span>
        <span class="k">if</span> <span class="n">flag_seed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the Stretch algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check Stretch algorithm inputs: proposal_type and proposal_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input scale must be of type float.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="Stretch.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.Stretch.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for Stretch algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start the loop over nsamples - this code uses the parallel version of the stretch algorithm</span>
        <span class="n">all_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">all_inds</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="c1"># Separate the full ensemble into two sets, use one as a complementary ensemble to the other and vice-versa</span>
        <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">set1</span> <span class="o">=</span> <span class="p">(</span><span class="n">inds</span> <span class="o">==</span> <span class="n">split</span><span class="p">)</span>

            <span class="c1"># Get current and complementary sets</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_state</span><span class="p">[</span><span class="n">inds</span> <span class="o">==</span> <span class="n">j01</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">j01</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">curr_set</span><span class="p">,</span> <span class="n">comp_set</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">split</span><span class="p">],</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">split</span><span class="p">]</span>  <span class="c1"># current and complementary sets respectively</span>
            <span class="n">ns</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_set</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_set</span><span class="p">)</span>

            <span class="c1"># Sample new state for S1 based on S0</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">zz</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">unif_rvs</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>  <span class="c1"># sample Z</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>  <span class="c1"># compute log(Z ** (d - 1))</span>
            <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">nc</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">nc</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">ns</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">rint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># sample X_{j} from complementary set</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">comp_set</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">comp_set</span><span class="p">[</span><span class="n">rint</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">curr_set</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
                <span class="n">zz</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">])</span>  <span class="c1"># new candidates</span>

            <span class="c1"># Compute new likelihood, can be done in parallel :)</span>
            <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

            <span class="c1"># Compute acceptance rate</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">all_inds</span><span class="p">[</span><span class="n">set1</span><span class="p">]),</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">u_rv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">all_inds</span><span class="p">[</span><span class="n">set1</span><span class="p">],</span> <span class="n">factors</span><span class="p">,</span> <span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">unif_rvs</span><span class="p">):</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u_rv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f</span> <span class="o">+</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div></div>


<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DRAM"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DRAM">[docs]</a><span class="k">class</span> <span class="nc">DRAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Delayed Rejection Adaptive Metropolis algorithm</span>

<span class="sd">    In this algorithm, the proposal density is Gaussian and its covariance C is being updated from samples as</span>
<span class="sd">    C = sp * C_sample where C_sample is the sample covariance. Also, the delayed rejection scheme is applied, i.e,</span>
<span class="sd">    if a candidate is not accepted another one is generated from the proposal with covariance gamma_2 ** 2 * C.</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. Heikki Haario, Marko Laine, Antonietta Mira, and Eero Saksman. &quot;DRAM: Efficient adaptive MCMC&quot;. Statistics</span>
<span class="sd">       and Computing, 16(4):339–354, 2006</span>
<span class="sd">    2. R.C. Smith, &quot;Uncertainty Quantification - Theory, Implementation and Applications&quot;, CS&amp;E, 2014</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **initial_cov** (`ndarray`):</span>
<span class="sd">        Initial covariance for the gaussian proposal distribution. Default: I(dim)</span>

<span class="sd">    * **k0** (`int`):</span>
<span class="sd">        Rate at which covariance is being updated, i.e., every k0 iterations. Default: 100</span>

<span class="sd">    * **sp** (`float`):</span>
<span class="sd">        Scale parameter for covariance updating. Default: 2.38 ** 2 / dim</span>

<span class="sd">    * **gamma_2** (`float`):</span>
<span class="sd">        Scale parameter for delayed rejection. Default: 1 / 5</span>

<span class="sd">    * **save_cov** (`bool`):</span>
<span class="sd">        If True, updated covariance is saved in attribute `adaptive_covariance`. Default: False</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">initial_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k0</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma_2</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">save_covariance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># Check the initial covariance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">initial_covariance</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                  <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input initial_covariance should be a 2D ndarray of shape (dimension, dimension)&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">=</span> <span class="n">k0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">=</span> <span class="n">gamma_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="o">=</span> <span class="n">save_covariance</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;k0&#39;</span><span class="p">,</span> <span class="s1">&#39;sp&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma_2&#39;</span><span class="p">,</span> <span class="s1">&#39;save_covariance&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># initialize the sample mean and sample covariance that you need</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_covariance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="DRAM.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DRAM.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DRAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">UQpy.Distributions</span> <span class="k">import</span> <span class="n">MVNormal</span>
        <span class="n">mvp</span> <span class="o">=</span> <span class="n">MVNormal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Sample candidate</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="n">current_cov</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">):</span>
            <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="n">current_cov</span><span class="p">)</span>
            <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>

        <span class="c1"># Compute log_pdf_target of candidate sample</span>
        <span class="n">log_p_candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># Compare candidate with current sample and decide or not to keep the candidate (loop over nc chains)</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">inds_delayed</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># indices of chains that will undergo delayed rejection</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">log_p_cand</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_candidate</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">log_p_cand</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>    <span class="c1"># enter delayed rejection</span>
                <span class="n">inds_delayed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>    <span class="c1"># these indices will enter the delayed rejection part</span>

        <span class="c1"># Delayed rejection</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># performed delayed rejection for some chains</span>
            <span class="n">current_states_delayed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidates_delayed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="n">candidate2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
            <span class="c1"># Sample other candidates closer to the current one</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">):</span>
                <span class="n">current_states_delayed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">candidates_delayed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">mvp</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
                <span class="n">candidate2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">current_states_delayed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mvp</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">nsamples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="p">))</span>
            <span class="c1"># Evaluate their log_target</span>
            <span class="n">log_p_candidate2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_cand2</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_delayed</span> <span class="o">-</span> <span class="n">candidate2</span><span class="p">)</span>
            <span class="n">log_prop_cand_curr</span> <span class="o">=</span> <span class="n">mvp</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">candidates_delayed</span> <span class="o">-</span> <span class="n">current_states_delayed</span><span class="p">)</span>
            <span class="c1"># Accept or reject</span>
            <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">cand2</span><span class="p">,</span> <span class="n">log_p_cand2</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">u_rv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds_delayed</span><span class="p">,</span> <span class="n">candidate2</span><span class="p">,</span> <span class="n">log_p_candidate2</span><span class="p">,</span>
                                                              <span class="n">log_prop_cand_cand2</span><span class="p">,</span> <span class="n">log_prop_cand_curr</span><span class="p">,</span> <span class="n">unif_rvs</span><span class="p">):</span>
                <span class="n">alpha_cand_cand2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_p_cand2</span><span class="p">))</span>
                <span class="n">alpha_cand_curr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_p_candidate</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]))</span>
                <span class="n">log_alpha2</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_p_cand2</span> <span class="o">-</span> <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">j2</span> <span class="o">+</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_cand2</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)))</span> <span class="o">-</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha_cand_curr</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">))))</span>
                <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u_rv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">log_alpha2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cand2</span>
                    <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_p_cand2</span>
                    <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Adaptive part: update the covariance</span>
        <span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="c1"># update covariance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_update_mean_covariance</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span><span class="p">,</span> <span class="n">new_sample</span><span class="o">=</span><span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:],</span> <span class="n">previous_mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_mean</span><span class="p">[</span><span class="n">nc</span><span class="p">],</span>
                <span class="n">previous_covariance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_covariance</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_covariance</span> <span class="ow">and</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adaptive_covariance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Update the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_update_mean_covariance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">new_sample</span><span class="p">,</span> <span class="n">previous_mean</span><span class="p">,</span> <span class="n">previous_covariance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterative formula to compute a new sample mean and covariance based on previous ones and new sample.</span>

<span class="sd">        New covariance is computed only of previous_covariance is provided.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * n (int): Number of samples used to compute the new mean</span>
<span class="sd">        * new_sample (ndarray (dim, )): new sample</span>
<span class="sd">        * previous_mean (ndarray (dim, )): Previous sample mean, to be updated with new sample value</span>
<span class="sd">        * previous_covariance (ndarray (dim, dim)): Previous sample covariance, to be updated with new sample value</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * new_mean (ndarray (dim, )): Updated sample mean</span>
<span class="sd">        * new_covariance (ndarray (dim, dim)): Updated sample covariance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">previous_mean</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">new_sample</span>
        <span class="k">if</span> <span class="n">previous_covariance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_mean</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">new_sample</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sample</span> <span class="o">-</span> <span class="n">previous_mean</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">new_covariance</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">previous_covariance</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">delta_n</span><span class="p">,</span> <span class="n">delta_n</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_mean</span><span class="p">,</span> <span class="n">new_covariance</span></div>

<span class="c1">####################################################################################################################</span>


<div class="viewcode-block" id="DREAM"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DREAM">[docs]</a><span class="k">class</span> <span class="nc">DREAM</span><span class="p">(</span><span class="n">MCMC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DiffeRential Evolution Adaptive Metropolis algorithm</span>

<span class="sd">    **References:**</span>

<span class="sd">    1. J.A. Vrugt et al. &quot;Accelerating Markov chain Monte Carlo simulation by differential evolution with</span>
<span class="sd">       self-adaptive randomized subspace sampling&quot;. International Journal of Nonlinear Sciences and Numerical</span>
<span class="sd">       Simulation, 10(3):273–290, 2009.[68]</span>
<span class="sd">    2. J.A. Vrugt. &quot;Markov chain Monte Carlo simulation using the DREAM software package: Theory, concepts, and</span>
<span class="sd">       MATLAB implementation&quot;. Environmental Modelling &amp; Software, 75:273–316, 2016.</span>

<span class="sd">    **Algorithm-specific inputs:**</span>

<span class="sd">    * **delta** (`int`):</span>
<span class="sd">        Jump rate. Default: 3</span>

<span class="sd">    * **c** (`float`):</span>
<span class="sd">        Differential evolution parameter. Default: 0.1</span>

<span class="sd">    * **c_star** (`float`):</span>
<span class="sd">        Differential evolution parameter, should be small compared to width of target. Default: 1e-6</span>

<span class="sd">    * **n_cr** (`int`):</span>
<span class="sd">        Number of crossover probabilities. Default: 3</span>

<span class="sd">    * **p_g** (`float`):</span>
<span class="sd">        Prob(gamma=1). Default: 0.2</span>

<span class="sd">    * **adapt_cr** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs adaptation of crossover probabilities (adapts every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no adaptation</span>

<span class="sd">    * **check_chains** (`tuple`):</span>
<span class="sd">        (iter_max, rate) governs discarding of outlier chains (discard every rate iterations if iter&lt;iter_max).</span>
<span class="sd">        Default: (-1, 1), i.e., no check on outlier chains</span>

<span class="sd">    **Methods:**</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">concat_chains</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">delta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">c_star</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">n_cr</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">p_g</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">adapt_cr</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">check_chains</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_target</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="n">args_target</span><span class="p">,</span>
                         <span class="n">dimension</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">nburn</span><span class="o">=</span><span class="n">nburn</span><span class="p">,</span> <span class="n">jump</span><span class="o">=</span><span class="n">jump</span><span class="p">,</span> <span class="n">save_log_pdf</span><span class="o">=</span><span class="n">save_log_pdf</span><span class="p">,</span>
                         <span class="n">concat_chains</span><span class="o">=</span><span class="n">concat_chains</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">nchains</span><span class="o">=</span><span class="n">nchains</span><span class="p">)</span>

        <span class="c1"># Check nb of chains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: For the DREAM algorithm, a seed must be provided with at least two samples.&#39;</span><span class="p">)</span>

        <span class="c1"># Check user-specific algorithms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">=</span> <span class="n">c_star</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span> <span class="o">=</span> <span class="n">n_cr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_g</span> <span class="o">=</span> <span class="n">p_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adapt_cr</span> <span class="o">=</span> <span class="n">adapt_cr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span> <span class="o">=</span> <span class="n">check_chains</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;delta&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c_star&#39;</span><span class="p">,</span> <span class="s1">&#39;n_cr&#39;</span><span class="p">,</span> <span class="s1">&#39;p_g&#39;</span><span class="p">],</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">typ</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be of type &#39;</span> <span class="o">+</span> <span class="n">typ</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;adapt_cr&#39;</span><span class="p">,</span> <span class="s1">&#39;check_chains&#39;</span><span class="p">]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Inputs &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39; must be a tuple of 2 integers.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input save_log_pdf must be True in order to check outlier chains&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize a few other variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j_ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cross_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span><span class="p">,))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Initialization of &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; algorithm complete.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># If nsamples is provided, run the algorithm</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nsamples_per_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nsamples_per_chain</span><span class="o">=</span><span class="n">nsamples_per_chain</span><span class="p">)</span>

<div class="viewcode-block" id="DREAM.run_one_iteration"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DREAM.run_one_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">run_one_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run one iteration of the MCMC chain for DREAM algorithm, starting at current state - see ``MCMC`` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)])</span>
        <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cr</span>

        <span class="c1"># Dynamic part: evolution of chains</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span>
        <span class="n">lmda</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">std_x_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
            <span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">d_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">as_</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_diff</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">d_ind</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="n">bs_</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_diff</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">draw</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">d_ind</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d_ind</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)]</span>
        <span class="n">multi_rvs</span> <span class="o">=</span> <span class="n">Multinomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_prob</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">multi_rvs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># id = np.random.choice(self.n_CR, size=(self.nchains, ), replace=True, p=self.pCR)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span>
                          <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="n">subset_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_j</span> <span class="o">&lt;</span> <span class="n">cross</span><span class="p">[</span><span class="n">id_j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">z_j</span><span class="p">,</span> <span class="n">id_j</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">id_</span><span class="p">)]</span>  <span class="c1"># subset A of selected dimensions</span>
        <span class="n">d_star</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">a_j</span> <span class="ow">in</span> <span class="n">subset_a</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subset_a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
                <span class="n">d_star</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">gamma_d</span> <span class="o">=</span> <span class="mf">2.38</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">d_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_star</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Binomial</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p_g</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">g</span><span class="p">[</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma_d</span><span class="p">[</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">norm_vars</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                                                 <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">subset_a</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">dx</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_star</span> <span class="o">*</span> <span class="n">norm_vars</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                           <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">lmda</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_state</span><span class="p">[</span><span class="n">as_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_state</span><span class="p">[</span><span class="n">bs_</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">current_state</span> <span class="o">+</span> <span class="n">dx</span>

        <span class="c1"># Evaluate log likelihood of candidates</span>
        <span class="n">logp_candidates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>

        <span class="c1"># Accept or reject</span>
        <span class="n">accept_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">unif_rvs</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">()</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="n">lpc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">log_p_curr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">logp_candidates</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">current_log_pdf</span><span class="p">)):</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unif_rvs</span><span class="p">[</span><span class="n">nc</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">lpc</span> <span class="o">-</span> <span class="n">log_p_curr</span>
            <span class="k">if</span> <span class="n">accept</span><span class="p">:</span>
                <span class="n">current_state</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="n">current_log_pdf</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">lpc</span>
                <span class="n">accept_vec</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">j_ind</span><span class="p">[</span><span class="n">id_</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">j_ind</span><span class="p">[</span><span class="n">id_</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dx</span><span class="p">[</span><span class="n">nc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">std_x_tmp</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span><span class="p">[</span><span class="n">id_</span><span class="p">[</span><span class="n">nc</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Save the acceptance rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_acceptance_rate</span><span class="p">(</span><span class="n">accept_vec</span><span class="p">)</span>

        <span class="c1"># update selection cross prob</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_cr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">adapt_cr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cross_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">j_ind</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cross_prob</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_prob</span><span class="p">)</span>
        <span class="c1"># check outlier chains (only if you have saved at least 100 values already)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niterations</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_outlier_chains</span><span class="p">(</span><span class="n">replace_with_best</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_state</span><span class="p">,</span> <span class="n">current_log_pdf</span></div>

<div class="viewcode-block" id="DREAM.check_outlier_chains"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.DREAM.check_outlier_chains">[docs]</a>    <span class="k">def</span> <span class="nf">check_outlier_chains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replace_with_best</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check outlier chains in DREAM algorithm.</span>

<span class="sd">        This function checks for outlier chains as part of the DREAM algorithm, potentially replacing outlier chains</span>
<span class="sd">        (i.e. the samples and log_pdf_values) with &#39;good&#39; chains. The function does not have any returned output but it</span>
<span class="sd">        prints out the number of outlier chains.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **replace_with_best** (`bool`):</span>
<span class="sd">            Indicates whether to replace outlier chains with the best (most probable) chain. Default: False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_log_pdf</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: Input save_log_pdf must be True in order to check outlier chains&#39;</span><span class="p">)</span>
        <span class="n">start_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">avgs_logpdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nsamples_per_chain</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">best_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">avg_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">avgs_logpdf</span><span class="p">)</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="n">ind3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="mf">0.75</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind1</span><span class="p">],</span> <span class="n">avg_sorted</span><span class="p">[</span><span class="n">ind3</span><span class="p">]</span>
        <span class="n">qr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span>

        <span class="n">outlier_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nchains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">avgs_logpdf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">q1</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">qr</span><span class="p">:</span>
                <span class="n">outlier_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">replace_with_best</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_pdf_values</span><span class="p">[</span><span class="n">start_</span><span class="p">:,</span> <span class="n">best_</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Chain </span><span class="si">{}</span><span class="s1"> is an outlier chain&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">outlier_num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Detected </span><span class="si">{}</span><span class="s1"> outlier chains&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outlier_num</span><span class="p">))</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#                                         Importance Sampling</span>
<span class="c1">########################################################################################################################</span>

<div class="viewcode-block" id="IS"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.IS">[docs]</a><span class="k">class</span> <span class="nc">IS</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample from a user-defined target density using importance sampling.</span>


<span class="sd">    **Inputs:**</span>

<span class="sd">    * **nsamples** (`int`):</span>
<span class="sd">        Number of samples to generate - see ``run`` method. If not `None`, the `run` method is called when the object is</span>
<span class="sd">        created. Default is None.</span>

<span class="sd">    * **pdf_target** (callable):</span>
<span class="sd">        Callable that evaluates the pdf of the target distribution. Either log_pdf_target or pdf_target must be</span>
<span class="sd">        specified (the former is preferred).</span>

<span class="sd">    * **log_pdf_target** (callable)</span>
<span class="sd">        Callable that evaluates the log-pdf of the target distribution. Either log_pdf_target or pdf_target must be</span>
<span class="sd">        specified (the former is preferred).</span>

<span class="sd">    * **args_target** (`tuple`):</span>
<span class="sd">        Positional arguments of the target log_pdf / pdf callable.</span>

<span class="sd">    * **proposal** (``Distribution`` object):</span>
<span class="sd">        Proposal to sample from. This ``UQpy.Distributions`` object must have an rvs method and a log_pdf (or pdf)</span>
<span class="sd">        method.</span>

<span class="sd">    * **verbose** (`boolean`)</span>
<span class="sd">        Set ``verbose = True`` to print status messages to the terminal during execution.</span>

<span class="sd">    * **random_state** (None or `int` or ``numpy.random.RandomState`` object):</span>
<span class="sd">        Random seed used to initialize the pseudo-random number generator. Default is None.</span>

<span class="sd">        If an integer is provided, this sets the seed for an object of ``numpy.random.RandomState``. Otherwise, the</span>
<span class="sd">        object itself can be passed directly.</span>


<span class="sd">    **Attributes:**</span>

<span class="sd">    * **samples** (`ndarray`):</span>
<span class="sd">        Set of samples, `ndarray` of shape (nsamples, dim)</span>

<span class="sd">    * **unnormalized_log_weights** (`ndarray`)</span>
<span class="sd">        Unnormalized log weights, i.e., log_w(x) = log_target(x) - log_proposal(x), `ndarray` of shape (nsamples, )</span>

<span class="sd">    * **weights** (`ndarray`):</span>
<span class="sd">        Importance weights, weighted so that they sum up to 1, `ndarray` of shape (nsamples, )</span>

<span class="sd">    * **unweighted_samples** (`ndarray`):</span>
<span class="sd">        Set of un-weighted samples (useful for instance for plotting), computed by calling the `resample` method</span>

<span class="sd">    **Methods:**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Last Modified: 10/05/2020 by Audrey Olivier</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_pdf_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">proposal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Initialize proposal: it should have an rvs and log pdf or pdf method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span> <span class="o">=</span> <span class="n">proposal</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="n">Distribution</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should be of type Distribution.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;rvs&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have an rvs method&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;log_pdf&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;UQpy: The proposal should have a log_pdf or pdf method&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                                                <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))))</span>

        <span class="c1"># Initialize target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf_</span><span class="o">=</span><span class="n">log_pdf_target</span><span class="p">,</span> <span class="n">pdf_</span><span class="o">=</span><span class="n">pdf_target</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args_target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: random_state must be None, an int or an np.random.RandomState object.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the samples and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Run IS if nsamples is provided</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nsamples</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)</span>

<div class="viewcode-block" id="IS.run"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.IS.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate and weight samples.</span>

<span class="sd">        This function samples from the proposal and appends samples to existing ones (if any). It then weights the</span>
<span class="sd">        samples as log_w_unnormalized) = log(target)-log(proposal).</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of weighted samples to generate.</span>

<span class="sd">        * **Output/Returns:**</span>

<span class="sd">        This function has no returns, but it updates the output attributes `samples`, `unnormalized_log_weights` and</span>
<span class="sd">        `weights` of the ``IS`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Running Importance Sampling...&#39;</span><span class="p">)</span>
        <span class="c1"># Sample from proposal</span>
        <span class="n">new_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># Compute un-scaled weights of new samples</span>
        <span class="n">new_log_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_log_target</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal</span><span class="o">.</span><span class="n">log_pdf</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_samples</span><span class="p">)</span>

        <span class="c1"># Save samples and weights (append to existing if necessary)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">new_samples</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">new_log_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">new_samples</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">,</span> <span class="n">new_log_weights</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Take the exponential and normalize the weights</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unnormalized_log_weights</span><span class="p">))</span>
        <span class="c1"># note: scaling with max avoids having NaN of Inf when taking the exp</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">sum_w</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: Importance Sampling performed successfully&#39;</span><span class="p">)</span>

        <span class="c1"># If a set of unweighted samples exist, delete them as they are not representative of the distribution anymore</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;UQpy: unweighted samples are being deleted, call the resample method to regenerate them&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="c1"># def resample(self, method=&#39;multinomial&#39;, nsamples=None):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Resample to get a set of un-weighted samples that represent the target pdf.</span>
    <span class="c1">#</span>
    <span class="c1">#     Utility function that creates a set of un-weighted samples from a set of weighted samples. Can be useful for</span>
    <span class="c1">#     plotting for instance.</span>
    <span class="c1">#</span>
    <span class="c1">#     **Inputs:**</span>
    <span class="c1">#</span>
    <span class="c1">#     * **method** (`str`)</span>
    <span class="c1">#         Resampling method, as of V3 only multinomial resampling is supported. Default: &#39;multinomial&#39;.</span>
    <span class="c1">#     * **nsamples** (`int`)</span>
    <span class="c1">#         Number of un-weighted samples to generate. Default: None (same number of samples is generated as number of</span>
    <span class="c1">#         existing samples).</span>
    <span class="c1">#</span>
    <span class="c1">#     **Output/Returns:**</span>
    <span class="c1">#</span>
    <span class="c1">#     * (`ndarray`)</span>
    <span class="c1">#         Un-weighted samples that represent the target pdf, `ndarray` of shape (nsamples, dimension)</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     from .Utilities import resample</span>
    <span class="c1">#     return resample(self.samples, self.weights, method=method, size=nsamples)</span>

<div class="viewcode-block" id="IS.resample"><a class="viewcode-back" href="../../samplemethods_doc.html#UQpy.SampleMethods.IS.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample to get a set of un-weighted samples that represent the target pdf.</span>

<span class="sd">        Utility function that creates a set of un-weighted samples from a set of weighted samples. Can be useful for</span>
<span class="sd">        plotting for instance.</span>

<span class="sd">        The ``resample`` method is not called automatically when instantiating the ``IS`` class or when invoking its</span>
<span class="sd">        ``run`` method.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * **method** (`str`)</span>
<span class="sd">            Resampling method, as of V3 only multinomial resampling is supported. Default: &#39;multinomial&#39;.</span>
<span class="sd">        * **nsamples** (`int`)</span>
<span class="sd">            Number of un-weighted samples to generate. Default: None (sets `nsamples` equal to the number of</span>
<span class="sd">            existing weighted samples).</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        The method has no returns, but it computes the following attribute of the ``IS`` object.</span>

<span class="sd">        * **unweighted_samples** (`ndarray`)</span>
<span class="sd">            Un-weighted samples that represent the target pdf, `ndarray` of shape (nsamples, dimension)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">:</span>
            <span class="n">multinomial_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">multinomial_run</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multinomial_run</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unweighted_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Exit code: Current available method: multinomial&#39;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_preprocess_target</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">,</span> <span class="n">pdf_</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess the target pdf inputs.</span>

<span class="sd">        Utility function (static method), that transforms the log_pdf, pdf, args inputs into a function that evaluates</span>
<span class="sd">        log_pdf_target(x) for a given x.</span>

<span class="sd">        **Inputs:**</span>

<span class="sd">        * log_pdf_ ((list of) callables): Log of the target density function from which to draw random samples. Either</span>
<span class="sd">          pdf_target or log_pdf_target must be provided</span>
<span class="sd">        * pdf_ ((list of) callables): Target density function from which to draw random samples.</span>
<span class="sd">        * args (tuple): Positional arguments of the pdf target</span>

<span class="sd">        **Output/Returns:**</span>

<span class="sd">        * evaluate_log_pdf (callable): Callable that computes the log of the target density function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># log_pdf is provided</span>
        <span class="k">if</span> <span class="n">log_pdf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_pdf_</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">log_pdf_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="c1"># pdf is provided</span>
        <span class="k">elif</span> <span class="n">pdf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">pdf_</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
                <span class="n">evaluate_log_pdf</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf_</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">320</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;UQpy: pdf_target must be a callable&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;UQpy: log_pdf_target or pdf_target should be provided.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evaluate_log_pdf</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Uncertainty quantification with Python </p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=SURG&repo=UQpy&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation_doc.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../runmodel_doc.html">RunModel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../distributions_doc.html">Distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../samplemethods_doc.html">SampleMethods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations_doc.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stochastic_process_doc.html">StochasticProcess</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surrogates_doc.html">Surrogates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reliability_doc.html">Reliability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../inference_doc.html">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities_doc.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../news_doc.html">News</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Michael D. Shields.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/SURG/UQpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>